\documentclass{beamer}

\usepackage[utf8]{inputenc}
\usepackage{listings}
\usepackage{xcolor}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
	keywordstyle=\color{orange},
	otherkeywords={handle,perform},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
	basicstyle=\ttfamily\footnotesize,
	identifierstyle=\color{blue},
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}

\lstset{style=mystyle}
\setbeamercovered{invisible}

%Information to be included in the title page:
\title{Projet de recherche}
\subtitle{Résumé de l'article \textbf{Handling Algebraic effects}}
\author{Jordan Ischard}
\institute{Université d'Orléans}
\date{2020-2021}



\begin{document}



\AtBeginSection
{
  \begin{frame}
    \frametitle{Sommaire}
    \tableofcontents[currentsection,subsectionstyle=show/shaded/hide]
  \end{frame}
}

\AtBeginSubsection
{
  \begin{frame} 
	\frametitle{Sommaire}
	\tableofcontents[subsectionstyle=show/shaded/hide]
  \end{frame}
}



\frame{\titlepage}

\section{Introduction}

\subsection{Problème de l'impératif dans un langage fonctionnel}
\begin{frame}
\frametitle{Ajout de principes impératifs dans un langage fonctionnel}

	\begin{block}{But}<1->
		Ajouter des fonctionnalités en plus dans les langages fonctionnels
	\end{block}

	\begin{alertblock}{Problème}<2->
		Ajoute des effets de bords que les langages fonctionnels purs non pas.
	\end{alertblock}

	\begin{exampleblock}{Exemple}<3->
		On peut avoir des effets de bords pour les appels mémoires ou encore
		les entrées/sorties.
	\end{exampleblock}

	\begin{block}{Idée}<4->
		Créer une structure qui va gérer ces effets.
	\end{block}
\end{frame}

\subsection{Proposition pour gérer les effets}
\begin{frame}[fragile]
	\frametitle{Réponses déjà proposées}

	\begin{block}{Les Monades}<1->
		Eugenio Moggi a proposé le principe de \alert{Monade} pour gérer les effets.
	\end{block}

	\begin{exampleblock}{Les Monades en Haskell}<2->
		\begin{lstlisting}[language=Haskell]
instance Monad Maybe where
	return x = Just x
			
	Nothing >>= f = Nothing
	Just x >>= f  = f x
					
	fail _ = Nothing
		\end{lstlisting}
	\end{exampleblock}

	\begin{block}{Les théories d'équations}<3->
		Plotkin et Power ont proposé des opérations comme source des effets et une
		\alert{théorie d'équation} pour décrire leurs propriétés.
	\end{block}
\end{frame}

\section{Gestion des effets dans l'article}

\subsection{Intuition et principe}
\begin{frame}
	\frametitle{Comment gérer les effets ?}
	\begin{block}{Intuition}<1->
		Reprendre le principe de Plotkin et Power et l'associer aux travaux de Benton et Kennedy sur
		les gestionnaires.
	\end{block}

	\begin{block}{Principe}<2->
		Les effets vont avoir pour source des \alert{opérations} et vont être géré par 
		un \alert{tableaux associatifs (map)} contenu dans un gestionnaire. 
	\end{block}
\end{frame}

\subsection{Mise en place dans une syntaxe}
\begin{frame}[fragile]
	\frametitle{Qu'ajoute-on pour mettre en place la gestion des effets ?}
	\begin{block}{Syntaxe ajouté}<1->
		On part de la syntaxe proposé par Levy dans son article sur \textit{call-by-push-value}.
		\begin{align*}
			source~de~l'effet~:~&\textbf{op}_V(x:\beta.M')\\
			structure~de~gestion~:~&M~\textbf{handled~with}~H~to~x:A.N\\
			gestionnaire~:~&\{\textbf{op}_{z:\alpha}(k:\beta \rightarrow \underline{C}) \mapsto M_{\textbf{op}}\}_{\textbf{op} : \alpha \rightarrow \beta}
		\end{align*}
	\end{block}

	\begin{block}{Fonctionnement}<2->
		On reprend la strucutre de gestion ci-dessus 
		avec $\textbf{op}_V(y.M') \in M$ et $\{\textbf{op}_z(k) \mapsto M_ {\textbf{op}}\} \in H$.
			\alert{\[M_{\textbf{op}}[V/z,M'[W/y]~\textbf{handled~with}~H~\textbf{to}~x:A.N/k(W)]\]}
	\end{block}
\end{frame}

\subsection{Exemple}
\begin{frame}
	\frametitle{dérogation à la lecture seule}
	
	\only<1>{
	\begin{exampleblock}{Valeur Temporaire sans modification dans la mémoire}<1>
		Le gestionnaire définit pour l'effet est le suivant : 
		\[H_{temporary} = \{\textbf{get}_{l:\textbf{loc}}(k:\textbf{nat} \rightarrow \underline{C}) \mapsto k(n)\}\]

		Prenons l'expression suivante : 
		\begin{align*}
			& \textbf{let}~n:\textbf{nat}~\textbf{be}~20~\textbf{in}\\
			& \textbf{get}_l(x:\textbf{nat}.\textbf{get}_l(y:\textbf{nat}.\textbf{return}~x+y))\\
			&\textbf{handled~with}~H_{temporary}~\textbf{to}~z:A.\textbf{return}~z+2
		\end{align*}
	\end{exampleblock}}

	\only<2>{
	\begin{exampleblock}{Valeur Temporaire sans modification dans la mémoire}
		\[H_{temporary} = \{\textbf{get}_{l:\textbf{loc}}(k:\textbf{nat} \rightarrow \underline{C}) \mapsto k(\alert{n})\}\]

		Prenons l'expression suivante : 
		\begin{align*}
			& \alert{\textbf{let}~n:\textbf{nat}~\textbf{be}~20~\textbf{in}}\\
			& \textbf{get}_l(x:\textbf{nat}.\textbf{get}_l(y:\textbf{nat}.\textbf{return}~x+y))\\
			&\textbf{handled~with}~H_{temporary}~\textbf{to}~z:A.\textbf{return}~z+2
		\end{align*}
	\end{exampleblock}}

	\only<3>{
	\begin{exampleblock}{Valeur Temporaire sans modification dans la mémoire}
		\[\textcolor{orange}{H_{temporary}} = \{\alert{\textbf{get}_{y:\textbf{loc}}\textcolor{blue}{(k:\textbf{nat} \rightarrow \underline{C})}} \mapsto k(20)\}\]

		Prenons l'expression suivante : 
		\begin{align*}
			& \alert{\textbf{get}_l(\textcolor{blue}{x:\textbf{nat}.\textbf{get}_l(y:\textbf{nat}.\textbf{return}~x+y)})}\\
			&\textbf{handled~with}~\textcolor{orange}{H_{temporary}}~\textbf{to}~z:A.\textbf{return}~z+2
		\end{align*}
	\end{exampleblock}}

	\only<4>{
	\begin{exampleblock}{Valeur Temporaire sans modification dans la mémoire}
		\[\textcolor{orange}{H_{temporary}} = \{\alert{\textbf{get}_{y:\textbf{loc}}\textcolor{blue}{(k:\textbf{nat} \rightarrow \underline{C})}} \mapsto k(20)\}\]

		Prenons l'expression suivante : 
		\begin{align*}
			& \alert{\textbf{get}_l(\textcolor{blue}{y:\textbf{nat}.\textbf{return}~20+y})}\\
			&\textbf{handled~with}~\textcolor{orange}{H_{temporary}}~\textbf{to}~z:A.\textbf{return}~z+2
		\end{align*}
	\end{exampleblock}}

	\only<5>{
	\begin{exampleblock}{Valeur Temporaire sans modification dans la mémoire}
		\[H_{temporary} = \{\textbf{get}_{y:\textbf{loc}}(k:\textbf{nat} \rightarrow \underline{C}) \mapsto k(20)\}\]

		Prenons l'expression suivante : 
		\begin{align*}
			& \alert{\textbf{return}~20+20}\\
			&\textbf{handled~with}~H_{temporary}~\textbf{to}~\alert{z:A.\textbf{return}~z+2}
		\end{align*}
	\end{exampleblock}}

	\only<6-7>{
	\begin{exampleblock}{Valeur Temporaire sans modification dans la mémoire}
		\[H_{temporary} = \{\textbf{get}_{y:\textbf{loc}}(k:\textbf{nat} \rightarrow \underline{C}) \mapsto k(20)\}\]

		Prenons l'expression suivante : 
		\begin{align*}
			& \alert{\textbf{return}~40+2}
		\end{align*}
	\end{exampleblock}}

	\only<7>{
	\begin{alertblock}{La réponse}
		C'est 42 ! 
	\end{alertblock}}
\end{frame}

\section{Validé des gestionnaires}

\subsection{Gestionnaire générique indécidable}
\begin{frame}
	\frametitle{Les gestionnaires en général sont indécidable}
	\begin{block}{Limite des gestionnaires}<1->
		En général la validité des gestionnaires est \alert{indécidable}.
	\end{block}

	\begin{block}{Comment palier à se problème}<2->
		Deux approches sont possibles : 
		\begin{enumerate}
			\item Obliger l'utilisateur a utiliser des gestionnaires que l'on sait valide (donc prédéfinis dans le langage) : \alert{la responsabilité est au créateur du langage}
			\item Laisser l'utilisateur faire comme il le souhaite tout en lui laissant la possibiliter de faire des gestionnaires
			invalide : \alert{la responsabilité est à l'utilisateur}.
		\end{enumerate}
	\end{block}
\end{frame}

\subsection{Sous-ensemble décidable}
\begin{frame}
	\frametitle{Gestionnaire décidable sous certaines conditions}
	TODO : principe de gestionnaire simple, de famille uniformément simple etc.
\end{frame}

\section{Confrontation}

\subsection{Les divergences}
\begin{frame}
	\frametitle{Motivation et fonctionnement divergent}
	\begin{columns}
		\column{0.5\textwidth}
		\begin{block}{Langage de l'article}
			\begin{enumerate}
				\item Créer pour voir l'aspect mathématique de la gestion d'effets algébriques
				\item Temps de travail conséquent
				\item La source d'un effet est une \alert{opération}
				\item Activation \alert{implicite} de l'effet
				\item Gestionnaire global implicite car l'activation est implicite
			\end{enumerate}
		\end{block}
		\column{0.5\textwidth}
		\begin{block}{Langage \textbf{erpl}}
			\begin{enumerate}
				\item Créer pour avoir une version allégé du langage Ocaml
				\item Un an de travail séparé par 6 mois 
				\item La source d'un effet est un \alert{type}
				\item Activation \alert{explicite} de l'effet
				\item Pas de gestionnaire global, tout activation sans gestionnaire provoque une erreur
			\end{enumerate}
		\end{block}
	\end{columns}
\end{frame}

\subsection{Exemple de conversion entre langage}
\begin{frame}[fragile]
	\frametitle{Passage du langage de l'article vers \textbf{erpl}}

	\begin{exampleblock}{Reprise de l'exemple précédent}<1->
		$\textbf{let}~n:\textbf{nat}~\textbf{be}~20~\textbf{in}$\\
		$\textbf{get}_l(x:\textbf{nat}.\textbf{get}_l(y:\textbf{nat}.\textbf{return}~x+y))$\\
		$\textbf{handled~with}~\{\textbf{get}_{l:\textbf{loc}}(k:\textbf{nat} \rightarrow \underline{C}) \mapsto k(n)\}~\textbf{to}~z:A.\textbf{return}~z+2$
	\end{exampleblock}

	\begin{exampleblock}{Reprise de l'exemple converti en \textbf{erpl}}<2>

		\begin{lstlisting}[language=caml]
type memory = Get of 'a ref -> 'a 
            | Set of 'a ref * 'a -> unit;;

let get = Get(fun x -> !x) and n = 20 in
          handle ((fun x -> fun y -> x + y + 2) 
                 (perform (get,l))) (perform (get,l)) 
          with (Get f,x),k -> k n ;;
		\end{lstlisting}
	\end{exampleblock}
\end{frame}

\subsection{Difficulté d'implémentation}
\begin{frame}
	\frametitle{Une histoire d'appels systèmes}
	\begin{block}{Comment ça fonctionne ?}<1->
		En prenant, le principe d'opération comme source d'effet on implique une gestion des opérations particuliers.

		Quand on a pas de gestionnaire, les opérations se \textit{gèrent elles-même}.
	\end{block}

	\begin{block}{Idée}<2->
		Créer un gestionnaire globale implicite ajouté à la compilation. 
	\end{block}

	\begin{alertblock}{Problèmes d'appels systèmes}<3->
		Cela veut dire que notre
		gestionnaire globale doit être capable de faire des appels systèmes et donc que le langage en soit capable.

		\alert{Pas facilement intégrable !}
	\end{alertblock}
\end{frame}

\section{Conclusion}
\begin{frame}
	\frametitle{Que peut-on conclure ?}
	TODO : expliquer le problème de l'appel système et du gestionnaire global implicite

	
\end{frame}



\end{document}