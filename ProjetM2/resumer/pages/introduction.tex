	Le pionnier dans la gestion des effets algébriques est \textbf{Eugenio Moggi}. Il proposa une représentation uniforme de calcul d'effets grâce aux \textbf{Monades} \cite{DBLP:conf/ac/BentonHM00}. 
	Cette représentation est utilisé dans le langage \textbf{Haskell}.
	
	\begin{definition}
		Une \textbf{Monade} est une structure permettant de manipuler les langages fonctionnels purs
		avec des traits impératifs.
		On peut représenter une monade comme un triplet constitué de : 
		\begin{enumerate}
			\item un \textbf{constructeur de type} appelé \textit{type monadique}, qui associe au type $t$ le type $Mt$.
			\item une \textbf{fonction $unit/return$} qui construit à partir d'un élément de type 
			sous-jacent $a$ un autre élément de type monadique $Ma$. Cette fonction a la signature suivante : $unit/return~:~t \rightarrow Mt$.
			\item une \textbf{fonction $bind$}, représenté par l'opérateur infixe $>>=$, associant à un type monadique
			et une fonction d'association un autre type monadique. Cette opérateur à la signature suivante : $>>=~:~Mt \rightarrow (t \rightarrow Mu) \rightarrow Mu$.
		\end{enumerate}
	\end{definition}

	Les effets et leurs gestions sont utiles pour représenter les exceptions, les états mémoires, le non-déterminisme, les I/O, etc. \textbf{Moggi} ne fut pas le seul à proposer une gestion des effets, en effet \textbf{Plotkin et Power} proposerons plus tard une représentation basée sur un ensemble d'opérations qui représente la sources des effets et une théorie d'équations, pour ces dites opérations, qui décrit leurs propriétés.
	
	L'intuition derrière est que chaque calcul retourne soit une \textbf{valeur}, soit effectue une \textbf{opération} avec un retour déterminant la continuation. Les arguments de cette opération représente donc les potentiels continuations.
	
	\begin{exemple}
		On prend une opération binaire de choix \textbf{choose}. C'est une opération qui choisit de manière non déterministe un booléen à retourner :
		\[\textbf{choose(return true,return false)}\]
		
		On a deux possibilités : soit on continue avec le calcul donné par le première argument soit on continue avec le calcul donné par le second.
	\end{exemple}

	Les deux représentations permettent de géré les effets et il est possible de passer d'une représentation à l'autre pour la plupart des effets. Ces effets sont appelés \textbf{effets Algébriques}. Les exemples utilisés sont algébriques.
	\medbreak
	
	La vision algébrique des effets a permis de les combiner et de raisonner dessus. Cependant, le gestionnaire d'exception apporte un challenge.
	\smallbreak
	
	Soit la monade $\_ + \textbf{exc}$ pour l'ensemble des exceptions $\textbf{exc}$. Cette monade est représentée par une opération $\textbf{raise}_e()$ pour chaque $e \in \textbf{exc}$ et aucune équations. $\textbf{raise}_e()$ ne prend par d'arguments et il n'y a pas de continuation directement après une levée d'exception. Maintenant la monade défini, comment créer le gestionnaire d'exception ? L'approche commune est la suivante:
	\[\textbf{handle}_e(M,N)\]
		
	$M$ s'effectue à moins qu'une exception $e$ soit levée, dans ce cas on effectue $N$. Cette construction binaire manque d'une certaine propriété caractérisant les opérations spécifiés dans les équations qui les décrivent.
	
	\begin{exemple}
		Cette propriété correspond à l'opération de commutation avec le contexte d'évaluation $\varepsilon[\_]$.\\
		On aimerait garder les équations suivantes : 
		\begin{align*}
			\varepsilon[\textbf{choose}(M,N)] &= \textbf{choose}(\varepsilon[M],\varepsilon[N]) & \varepsilon[\textbf{raise}_e()] &= \textbf{raise}_e()\\
		\end{align*}
		mais pas : 
		\[\varepsilon[\textbf{handle}(M,N)] = \textbf{handle}(\varepsilon[M],\varepsilon[N])\]
	
		Or les propriétés naturelles sont communes à toutes les opérations spécifiées par des équations, donc la solution proposée n'est pas suffisante.
	\end{exemple} 

	Dans le papier on donne une explication algébrique des gestionnaires d'exceptions. L'idée principale est que :
	\begin{enumerate}
		\item les gestionnaires correspondent à des modèles de théorie équationnelle;
		\item la sémantique des gestionnaires est donné à l'aide d'homomorphismes uniques qui ciblent de tels modèles et est induit par la propriété universelle du modèle libre. 
	\end{enumerate}

	On souhaite adopte une vision générale suggéré par Benton et Kennedy. Dans leur approche, la valeur de retour est passé à la continuation définit par l'utilisateur. Cette idée se généralise à tous les effets algébrique, permettant à un nouveau concept de programmation de gérer les effets algébriques. 
	
	Conceptuellement, les opérations algébriques et les gestionnaires d'effets sont duals : le premier peut être nommé \textit{constructeur d'effets} car il crée l'effet et le second peut être nommé \textit{destructeur d'effets} car il produit un calcul en lien avec l'effet créé.
	\smallbreak
	
	Le projet recherche a pour but de choisir un article et de le résumer. Mon résumé restera fidèle à l'article en gardant
	la forme du papier tout en allègeant le fond. En effet, il m'est plus important de montrer le concept général via des exemples ainsi
	que les résultats importants sur la validité des gestionnaires que d'expliquer la logique mathématique interne.

	De plus, le projet recherche étant lié à un autre module projet, je vais ajouter une plus-value à mon résumer. Durant ma 
	1ère année de master, j'ai eu l'occasion d'implémenter une représentation des effets algébrique dans un noyau de langage fonctionnel créé lors de mon stage de fin de licence. Je vais donc profiter d'une section supplémentaire pour comparer les deux approches.
	
	