\documentclass[10pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[a4paper,margin=1.5cm]{geometry}
\usepackage[T1]{fontenc}
\usepackage[french]{babel}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{enumitem}
\usepackage{pifont}
\usepackage{hyperref}
\usepackage{textcomp}
\usepackage{ulem}
\usepackage{multicol}

\begin{document}
		
	\title{\textbf{Rapport de stage \\ Développement d'un noyau de programmation synchrone}}
	\date{25 Mars 2019}
	\author{Jordan Ischard\\3ème année de licence Informatque \\ Université d'Orléans}
	\maketitle
	\newpage
	
	
	\tableofcontents
	\newpage
	
	\section{Présentation de l'équipe}
		\paragraph{Remerciement}
		Avant tout développement sur mon sujet de stage, j'aimerais remercier mes 2 professeurs qui m'ont encadré, pour m'avoir permis de faire ce stage de recherche et de m'avoir aidé tout le long de celui-ci. J'ai beaucoup appris grâce à eux. Je remercie donc Madame Bousdira et Monsieur Dabrowski pour tout.
		\bigbreak
		
		
		Le Laboratoire d'Informatique Fondamentale d'Orléans (LIFO) est un laboratoire de l'Université d'Orléans et de l'INSA Centre-Val de Loire. 
		\smallbreak
		Les recherches menées au LIFO concernent la science informatique et les STIC. Elles vont de l'algorithmique au traitement des langues naturelles, de l'apprentissage au parallélisme massif, de la vérification et la certification à la sécurité des systèmes, du Big Data aux systèmes embarqués. Le laboratoire est structuré en cinq équipes :
		\begin{enumerate}
			\item[-] Contraintes et Apprentissage (CA)
			\item[-] Graphes, Algorithmes et Modèles de Calcul (GAMoC)
			\item[-] Langages, Modèles et Vérification (LMV)
			\item[-] Pamda
			\item[-] Sécurité des Données et des Systèmes (SDS)
		\end{enumerate}
		\medbreak
		
		Afin d'offrir une autre approche du laboratoire et de promouvoir la coopération entre équipes, les thématiques transversales suivantes ont été définies :
		\begin{enumerate}
			\item[-] Masse de données et calcul haute performance
			\item[-] Modélisation et algorithmique
			\item[-] Sécurité et sûreté
		\end{enumerate}
		\medbreak
		
		J'ai eu l'occasion de travailler avec une partie de l'équipe LMV, dans l'optique d'un stage rémunéré de 3 mois; voici la description de l'équipe LMV.
		\medbreak
		
		L'objectif de l'équipe LMV est de contribuer à l'amélioration de la compréhension des problèmes de sureté et de sécurité des systèmes  informatiques. Des logiques «ordres partiels» aux langages de programmation usuels, les membres de l'équipes travaillent sur ces questions à différents niveaux d'abstraction et selon différents points de vue tout en cherchant à comprendre les relations fondamentales entre ces différentes approches. L'équipe est structurée autour de deux axes : la correction de programmes et la vérification de systèmes.
		\begin{enumerate}
			\item[-] Le premier axe s'intéresse au développement de techniques liées aussi bien à la vérification de propriétés spécifiques qu'à la satisfaction de propriétés fonctionnelles quelconques. Dans les deux cas les propriétés peuvent être assurées par construction ou a posteriori (vérification déductive).
			\item[-] Le second axe repose d'une part sur l'étude de techniques à base de systèmes de réécriture comme par exemple les problèmes d'accessibilité dans les systèmes de réécriture et d'autre part sur l'étude des logiques dites «ordres partiels» et leur utilisation dans le cadre du développement d'outils de vérification efficaces.
		\end{enumerate}
		\newpage
		
		
		
	\section{Introduction}

		
		
		Le stage a pour intitulé \textit{Programmation réactive synchrone, implantation d’une machine virtuelle}. Il se place dans la thématique \textit{Sémantique des systèmes concurrents}. L’objectif de ce stage est de réaliser l’implantation d’une machine virtuelle (type JVM) destinée à exécuter un langage réactif synchrone purement fonctionnel encadré par deux maîtres de conférence : Mme Bousdira et Mr Dabrowski.
		\smallbreak
		Pour cela une recherche préliminaire sur des machines existantes sera faite en premier lieu pour se mettre à niveau. Ensuite une recherche sur la programmation réactive servira à comprendre les enjeux du sujet et à cerner les différentes contraintes que la réactivité apporte. Les recherches étant faite on pourra s'atteler à la création de notre propre machine concurrente. Pour finir, on pourra conclure par un résumé le travail effectué, des choix qui pourrait être améliorés, des voies qui n'ont pas été choisies et ce qu'il reste à faire.
		\newpage
		
		
	
	\section{Préliminaires}
	 
	 	Ayant un niveau de 3ème année de licence informatique, j'ai beaucoup de lacunes par rapport au travail demandé, il m'a fallu me mettre à niveau. Pour cela, trois articles ont été étudiés : 
	 	\begin{enumerate}
	 		\item[-] \hyperref[ReactiveML]{[1]} expliquant le fonctionnement du ReactiveML un langage de programmation réactif
	 		\item[-] \hyperref[ZINC]{[2]} développant toute la réflexion que l'on doit avoir pour créer un langage de programmation
		 	\item[-] \hyperref[Calculi]{[3]} expliquant le fonctionnement des machines avec les $\lambda$-calculs
		 \end{enumerate}
 		 Pour mieux structurer ma démarche, je vais diviser mes recherches en deux sous parties. La première sera lié à mes recherches "préliminaires" qui ne sont pas lié directement à la programmation réactive. Elle regroupera l'article \hyperref[ZINC]{[2]} et \hyperref[Calculi]{[3]}. La second sera dédié à l'article \hyperref[ReactiveML]{[1]} qui est lui complètement axé sur le programmation réactive. 
	 
		\subsection{$\lambda$-calcul et machines abstraites}
			
			\paragraph{Créer un langage de programmation}
			Créer un langage est un processus complexe, il faut savoir se poser les bonnes questions. Mon but est ici de vous montrer une partie du processus de reflexion pour comprendre les problèmes que soulève la création d'un langage. Je vais m'appuyer sur les travaux de Xavier Leroy sur le \textit{ZINC}.
			\medbreak
			
				\subparagraph{Pourquoi ?} 
				La création d'un langage de programmation doit venir d'un besoin de celui-ci, par exemple quand on veut des critères spécifiques. Pour le \textit{ZINC}, La portabilité du langage ML sur micro-ordinateur ainsi que l'utilisation pour la pédagogie ont été soulevés comme problèmes des implantations déjà existantes. La nécessité de la création d'un nouveau langage devient donc flagrante. D'ailleurs \textit{ZINC} veut dire ZINC Is Not Caml, il pointe le principal langage qui a tous les problèmes exposé plus haut pour bien montrer qu'il ne va pas les faire. 
				
				\subparagraph{Comment?}	
				Le plus dur reste à faire. Maintenant on doit savoir ce que l'on veut dans notre langage, comment on pourra l'utiliser, qu'elle est la meilleure implantation pour une vitesse d'exécution optimale, qu'elle sera la méthode d'exécution. 
				\medbreak
				
				On va aborder quelques points soulevés dans l'article\hyperref[ZINC]{[2]}. Je vous conseil sa lecture si le sujet vous intéresse car il est bien détailler et assez accessible pour un novice comme moi.
				\begin{itemize}
					\item[] - Veut-on que notre langage soit utilisé pour de petits problèmes ou au contraire pour des problèmes de tous types de tailles. Si c'est le cas il faut pouvoir simplifier la vie à notre utilisateur en l'aidant à structurer son programme. Par exemple en Caml on a les \textbf{structures}, en java on a les \textbf{classes}, en C on a les \textbf{headers}, etc ... Pour le \textit{ZINC}, la création de modules est possible avec un principe proche du C. De plus, le principe de module est le seul qui permet de combiner une compilation séparée de chaque module avec un typage fort statique.
					\medbreak
					
					Petit point sur le typage, le typage peut être soit statique, soit dynamique et pour chacune d'entres elles, on peut avoir un typage fort ou un typage faible. On va définir tous ça :
					\begin{itemize}
						\item[] - typage \textbf{statique} : on vérifie, avant exécution, tout le code. Exemple : Caml
						\item[] - typage \textbf{dynamique} : on vérifie au fur et à mesure le code au moment où l'on a la nécessité. Exemple : Python
						\item[] - typage \textbf{fort} : il faut que tout les types correspondent entre-eux quand on les associe. Exemple : Caml 
						\item[] - typage \textbf{faible} : il peut y avoir des associations entre deux types pas tout à fait pareil. Exemple : C, on peut faire une égalité entre un pointeur et un entier il va juste prévenir mais pas interdire. 
					\end{itemize} 
					\item[] -
					\item[] - Veut-on des fonctions n-aires ou utiliser la curryfication ? Déjà qu'est-ce que la curryfication ? La curryfication est la transformation d'une fonction à plusieurs arguments en une fonction à un argument qui retourne une fonction sur le reste des arguments.
					\smallbreak
					Exemple en Caml : La version curryfiée de $let~f = fun(x,y) \rightarrow x+y~in~f(5,7)$ est\\ $let~f = fun~x \rightarrow fun~y \rightarrow x+y~in~f~5~7$ 
					\smallbreak
					Le \textit{ZINC} n'a pas de fonctions n-aires. Malgré la facilité et l'efficacité que l'on peut voir dans les fonctions n-aires, un problème se pose. Il est dur de prévoir le comportement avec les fonctions de hautes ordres et le polymorphisme. Pour éviter ça on va préférer la curryfication malgré son exécution plus lente. Une explication précise de comment palier à sa vitesse d'exécution est décrite dans l'article\hyperref[ZINC]{[2]} que je vous conseille une nouvelle fois vivement.
					\item[] - Quelle méthode d'exécution veut-on utiliser ?
 				\end{itemize}
				\bigbreak
				
				
				
	
			\paragraph{Les  $\lambda$-calculs}
			
				\subparagraph{Les bases :}
				Le $\lambda$-calcul est un système formel inventé par Alonzo Church dans les années 1930, qui fonde les concepts de fonction et d'application. On y manipule des expressions appelées $\lambda$-expressions, où la lettre grecque $\lambda$ est utilisée pour lier une variable. Il y a trois termes qui composent les $\lambda$-expressions :
				\begin{enumerate}
					\item les variables : \textit{x, y...} sont des $\lambda$-termes 
					\item les applications : \textit{u v} est un $\lambda$-terme si \textit{u} et \textit{v} sont des $\lambda$-termes , on peut voir l'application comme ceci : si \textit{u} est une fonction et \textit{v} un argument, alors \textit{u v} est le résultat de l'application à \textit{v} de la fonction \textit{u}; 
					\item les abstractions : $\lambda$ \textit{x.v} est un $\lambda$-terme si \textit{x} est une variable et \textit{v} un $\lambda$-terme, on peut voir l'abstraction comme ceci : $\lambda$ \textit{x.v} peut être interprétée comme la fonction qui à \textit{x}, associe \textit{v}, où \textit{v} contient en général des occurrences de \textit{x}.
				\end{enumerate}
				\bigbreak
				
				
				\subparagraph{La réduction :}Maintenant que nous connaissons les termes qui composent les $\lambda$-expressions, il faut savoir comment les faire interagir entre eux. Les $\lambda$-calculs fonctionnent par réductions des termes grâce à l'application. Il existe trois règles de \textbf{réduction générale :}
				\begin{itemize}
					\item[-] $(\lambda X_{1}.M)~\alpha~(\lambda X_{1}.M[X_{1} \leftarrow X_{2}])$
					où $X_{2}~\notin~FV(M)$ : elle sert à renommer les variables
					\item[-] $((\lambda X_{1}.M_{1})M_{2})~\beta~M_{1}[X \leftarrow M_{2}]$ : elle substitue une variable par un $\lambda$-terme
    				\item[-] $(\lambda X.(M~X))~\eta~M$ 
					où $X~\notin~FV(M)$ : elle représente le cas où $g$ est une fonction qui à $x$ associe  $f(x)$  telle que f est une fonction alors autant utiliser directement la fonction f.
				\end{itemize}
				\textit{La réduction générale \textbf{n} = $\alpha \cup \beta \cup \eta$}.
				\bigbreak
				
				
				La $\beta$-réduction est plus complexe et a ses propres règles :
				\begin{itemize}
					\item $X_{1}[X_{1} \leftarrow M]~= M$
					\item $X_{2}[X_{1} \leftarrow M]~= X_{2}$ où $X_{1}\neq X_{2}$
					\item $(\lambda X_{1}.M_{1})[X_{1} \leftarrow M_{2}]~= (\lambda X_{1}.M_{1})$
					\item $(\lambda X_{1}.M_{1})[X_{2} \leftarrow M_{2}]~= (\lambda X_{3}.M_{1}[X_{1} \leftarrow X_{3}][X_{2} \leftarrow M_{2}])$ 
					\\où $X_{1} \neq X_{2}$, $X_{3} \notin FV(M_{2})$ et $X_{3} \notin FV(M_{1})\backslash{X_{1}}$ 
					\item $(M_{1}~M_{2})[X \leftarrow M_{3}]~=(M_{1}[X \leftarrow M_{3}]~M_{2}[X \leftarrow M_{3}])$
				\end{itemize}
				\bigbreak
			
			
				\subparagraph{Simplification :}Afin d'allèger l'écriture en enlevant des parenthèses, il y a des règles de priorité qui sont les suivantes :
				\begin{itemize}
					\item Application associative à gauche : $M1~M2~M3~= ((M1~M2)M3)$
					\item Application prioritaire par rapport à l'abstraction : $\lambda X.M1~M2~= \lambda X.(M1~M2)$
					\item Les abstractions consécutives peuvent être regroupées : $\lambda XYZ.M~= (\lambda X.(\lambda Y.(\lambda Z.M)))$
				\end{itemize}
				\medbreak
				
				\begin{multicols}{2}{
					\begin{itemize}
						\item[] Version écriture lourde
						\item[] $((\lambda x.((\lambda z.z)~x))~\underline{(\lambda x.x)})$
						\item[$\rightarrow_{n}^{\alpha}$] $(\underline{(\lambda x.((\lambda z.z)~x))}~(\lambda y.y))$
						\item[$\rightarrow_{n}^{\eta}$] $\underline{((\lambda z.z)~(\lambda y.y))}$
						\item[$\rightarrow_{n}^{\beta}$] $(\lambda y.y)$
					\end{itemize}
				
					\begin{itemize}
						\item[] Version écriture allégée
						\item[] $\lambda x.(\lambda z.z)~x)~\underline{\lambda x.x}$
						\item[$\rightarrow_{n}^{\alpha}$] $\underline{\lambda x.(\lambda z.z)~x)}~\lambda y.y$
						\item[$\rightarrow_{n}^{\eta}$] $\underline{(\lambda z.z)~\lambda y.y}$
						\item[$\rightarrow_{n}^{\beta}$] $\lambda y.y$
					\end{itemize}
				}
				\end{multicols}
				\bigbreak
				
				
				\subparagraph{Forme normale}
			
				\textit{Une expression est une forme normale si on ne peut pas réduire l'expression via une $\beta$ ou $\eta$ rédution.}
				\medbreak
			
				\textbf{Théorème de la forme normale :}
				Si on peut réduire $L$ tels que $L =_{n}~M$ et $L =_{n}~N$ et que $N$ et $M$ sont en forme normale alors $M = N$ à n renommages près.
				\medbreak	
			
				\textbf{Théorème de Church-Rosser ( pour $=_{n}$ ) :}
				Si on a $M =_{n} N$, alors il existe un $L'$ tels que $M \twoheadrightarrow n_{n}~L'$ et $N \twoheadrightarrow n_{n}~L'$.
				\medbreak
			
				Certaines lambda calcul expressions n'ont pas de forme normale comme: $((\lambda x.x x)~(\lambda x.x x)$. 
				D'autres en ont une mais on peut rentrer dans une boucle infinie de réduction si on choisit la mauvaise réduction.
				\medbreak
			
				Le problème se pose lorsqu'on évalue un argument de la fonction qui n'est jamais utilisé. Pour palier à ce problème, on utilise la stratégie d'appliquer toujours les $\beta$ et $\eta$ réductions les plus à gauche. Ces règles sont les suivantes:
				\begin{itemize}
					\item[-] $M \longrightarrow_{\bar{n}}~N$ si $M~\beta~N$
					\item[-] $M \longrightarrow_{\bar{n}}~N$ si $M~\eta~N$
					\item[-] $(\lambda X.M) \longrightarrow_{\bar{n}}~(\lambda X.N)$
					\item[-] $(M~N) \longrightarrow_{\bar{n}}~(M'~N)$ si $M \longrightarrow_{\bar{n}}~M'$
					\\ et $\forall~L$, $(M~N)~\beta~L$ impossible et $(M~N)~\eta~L$ impossible
					\item[-] $(M~N) \longrightarrow_{\bar{n}}~(M~N')$ si $N \longrightarrow_{\bar{n}}~N'$
					\\ et $M$ est une forme normale
					\\ et  $\forall~L$, $(M~N)~\beta~L$ impossible et $(M~N)~\eta~L$ impossible
				\end{itemize}
				\smallbreak
				Cette solution est sûre mais reste peut utilisée car elle est assez lente. 
				\medbreak
				
				Pour évaluer un langage, on utilise ce qui s'appelle une \textbf{stratégie d'évaluation}. Cette stratégie explique quand les arguments d'une fonction est évalué. Je vous présente les 2 stratégies qui nous intéresse :
				\begin{enumerate}
					\item \textbf{l'appel par nom :} pour une fonction f donnée, on évalue chaque arguments quand on en a besoin, c'est-à-dire que l'on évalue pas les arguments avant l'appel de la fonction. Cette stratégie est pratique quand on a des arguments non utilisé  et quand on veut travailler avec des listes infinies. Mais par contre si tous les arguments sont utilisés cette stratégie est plus lente que celle présentée après car on doit réévaluer les arguments à chaque fois. 
					\\Cette stratégie fait partie du groupe des stratégie d'évaluation non stricte, c'est-à-dire qu'il n'évalue pas forcément la fonction en entier. 
					\smallbreak
					\textbf{Exemple :} Pour une fonction $fst$ tels que pour deux arguments $x$ et $y$ on retourne le 1er. Si on a : $fst(3+4,5/5)$ on va évalué $3+4$. Ce qui donne $fst(7,5/5)$ et on retourne 7 on n'évalue pas $5/5$.
					\item  \textbf{l'appel par valeurs :} pour une fonction g donné, on évalue ces arguments avant d'évalué la fonction.
					\\Cette stratégie fait partie du groupe des stratégie d'évaluation stricte, c'est-à-dire qu'il évalue forcément la fonction en entier.
					\smallbreak
					\textbf{Exemple :} Pour une fonction $fst$ tels que pour deux arguments $x$ et $y$ on retourne le 1er. Si on a : $fst(3+4,5/5)$ on va évalué $3+4$. Ce qui donne $fst(7,5/5)$, on évalue $5/5$ . On arrive à $fst(7,1)$ et on retourne 7.
				\end{enumerate}
				\medbreak
				
				La preuve de la compréhension des $\lambda$-calculs a été faite à travers son implantation en OCaml. Cependant cette implantation reste simplifiée et une version plus complète sera présentée dans la suite. 
				\smallbreak
				L'appel par valeur est plus facile à mettre en oeuvre dans un langage. On va voir cela dans le langage ISWIM qui est un langage qui utilise l'appel par valeur.
				\newpage
				
			
			
			\paragraph{ISWIM}	
			
				ISWIM est un langage impératif à noyau fonctionnel ; de fait, c'est une syntaxe lisible du $\lambda$-calcul à laquelle sont ajoutés des variables mutables et des définitions. Grâce au $\lambda$-calcul, ISWIM comporte des fonctions d'ordre supérieur et une portée lexicale des variables. Le but est de décrire des concepts en fonction d'autres concepts. Ce langage a fortement influencé les autres langages qui l'ont suivi, principalement dans la programmation fonctionnelle.
				\medbreak
			 
				ISWIM a une grammaire étendue de la grammaire des $\lambda$-calcul.
				\smallbreak
				$M,N,L,K =$
				\begin{itemize}
					\item[ ] les termes des $\lambda$-calculs :
					\item[|] $X$ 
					\item[|] $(\lambda X.M)$
					\item[|] $(M~N)$
					\item[ ] les nouveaux termes :
					\item[|] $b$ : une constante
					\item[|] $(o^{n}~M~...~N)$ avec $o^{n}$ les fonctions primitives d'arité n
				\end{itemize}
				\medbreak
				
				On définit une valeur telle que :
				\smallbreak
				$V,U,W =$
				\begin{itemize}
					\item[|] $b$
					\item[|] $X$
					\item[|] $(\lambda X.M)$
				\end{itemize}
				\bigbreak
				
				
				Les règles de $\beta$-réductions sont les mêmes que celles pour les $\lambda$-calculs avec 2 ajouts qui sont les suivants :
				\begin{itemize}
					\item $b[X \longleftarrow M] = b$
					\item $(o^{n}~M_{1}~...~M_{n})[X \longleftarrow M] = (o^{n}~M_{1}[X \longleftarrow M]~...~M_{n}[X \longleftarrow M])$
				\end{itemize}
				\bigbreak
			
			
				La $\beta$-réduction est la même qu'en $\lambda$-calcul mais à la condition que la réduction soit faite avec une valeur $V$. 
				\begin{itemize}
					\item[-] $((\lambda X.M)~V)~\beta_{v}~M[X \longleftarrow V]$
				\end{itemize} 
				\smallbreak
				Cette restriction permet une sorte d'ordre dans les calculs.
				\medbreak
				
				Cependant l'$\eta$ et l'$\alpha$ réduction ne sont plus vue comme telles. En effet l'$\eta$-réduction n'est pas utilisée car plus très utile et contraignante à programmer.L'$\alpha$-réduction sera utilisée pour rechercher une équivalence entre deux termes, on renommera d'ailleurs l'équivalence en $\alpha$-équivalence.
				\medbreak
				
				Une réduction a été rajoutée pour gérer les opérateurs : c'est la $\delta$-réduction. Ce qui nous donne une nouvelle \textbf{n}-réduction tels que \textbf{n}-réduction = $\beta_{v} \cup \delta$
				\bigbreak
				
				Un exemple d'implantation a été codé en Ocaml.
				\newpage
				
				
				
		\subsection{Machines abtraites}
		
			\paragraph{CC Machine :} CC vient des termes \textbf{Control string} et \textbf{Context} qui représente respectivement:
				\begin{itemize}
					\item la partie du $\lambda$-calcul que l'on traite
					\item la partie du $\lambda$-calcul que l'on met en attente 
				\end{itemize}
				Cette séparation permet d'appliquer l'appel par valeur simplement. En effet à chaque fois que l'on a une application on évalue le terme de gauche puis le terme de droit. Le faite de ce concentrer sur une sous-expression est possible grâce au contexte qui prends la partie générale de l'expression pour la mettre en attente. Cette machine reprend la sémantique du langage ISWIM. 
				\medbreak
				
				Pour ne pas perdre la position de la sous-expression que l'on traite dans l'expression générale, on utilise un \textbf{trou} qui est représenté par $[]$ dans notre expression.
				\bigbreak
				
				
				Basiquement la machine va évaluer l'expression comme ceci :
				\begin{itemize}
					\item[] - Quand on a une application $(M~N)$ :
					\begin{itemize}
						\item[] - la machine va évalué $M$ et garder dans le contexte $([]~N)$.
						\item[] - elle va remettre la sous-expression $M$ évalué, soit $M \twoheadrightarrow_{cc} V$, dans l'application ce qui donnera $(V~N)$
						\item[] - elle va évalué $N$ et garder dans le contexte $(V~[])$ 
						\item[] - elle va remettre la sous-expression $N$ évalué, soit $N \twoheadrightarrow_{cc} U$, dans l'application ce qui donnera $(V~U)$
						\item[] - elle va évalué $(V~U)$ 
					\end{itemize}
					\item[] - Quand on a une abstraction $((\lambda X,M)~N)$ : 
					\begin{itemize}
						\item[] - c'est une application, sachant que $V = (\lambda X,M)$ on a $(V~N)$. Si on utilise ce que l'on a dit plus haut on aura $V~U$ avec  $V = (\lambda X,M)$. C'est une $\beta$-réduction, on retombe sur un cas simple.
					\end{itemize}
					\item[] - Quand on a une opération $(o^{n}~M...N)$ : c'est le même principe que l'application
					\begin{itemize}
						\item[] - la machine va évalué $M$ et garder $(o^{n}~[]...N)$.
						\item[] - elle va remettre la sous-expression $M$ évalué, soit $M \twoheadrightarrow_{cc} V$, dans l'opération ce qui donnera $(o^{n}~V...N)$
						\item[] - etc jusqu'à avoir $(o^{n}~V...U)$ pour pouvoir évaluer l'opération
					\end{itemize}
 				\end{itemize}
				\bigbreak
				
				
				Les règles définit pour cette machine sont les suivantes :
				\begin{enumerate}
		
					\item $\langle(M~N),E\rangle \longmapsto_{cc} \langle M,E[([]~N)]\rangle~si M \notin V$
					
					\item $\langle(V_{1}~N),E\rangle \longmapsto_{cc}  \langle N,E[(V_{1}~[])]\rangle~si N \notin V$
					
					\item $\langle((\lambda X.M)~V),E\rangle \longmapsto_{cc} \langle M[X\longleftarrow V],E\rangle$
					
					\item $\langle V,E[(U~[])]\rangle \longmapsto_{cc} \langle(U~V),E\rangle$
					 
					\item $\langle V,E[([]~N)]\rangle \longmapsto_{cc} \langle(V~N),E\rangle$ 
					
					\item $\langle(o^{n}~V_{1}...V_{i}~M~N~...),E\rangle \longmapsto_{cc}  
					\langle M,E[(o^{n}~V_{1}...V_{i}~[]~N~...)]\rangle~ si M \notin V$
					
					\item $\langle(o^{n}~b_{1}...b_{n}),E\rangle \longmapsto_{cc}  \langle V,E\rangle$ avec $V = \delta(o^{n},b_{1}...b_{n})$ 
					
					\item $\langle V,E[(o^{n}~V_{1}...V_{i}~[]~N~...)]\rangle \longmapsto_{cc} \langle(o^{n}~V_{1}...V_{i}~V~N ~...),E\rangle$ 
				\end{enumerate}
				\bigbreak
				
				
				La machine peut s'arrêter dans 3 états différents:
				\begin{itemize}
					\item[]$\longrightarrow$ on a une \textbf{constante} tels que $\langle M,[]\rangle \twoheadrightarrow_{cc} \langle b,[]\rangle$;
					\item[]$\longrightarrow$ on a une \textbf{fonction} tels que $\langle M,[]\rangle \twoheadrightarrow_{cc} \langle\lambda X.N,[]\rangle$;
					\item[]$\longrightarrow$ on a un \textbf{état inconnu} soit une \textbf{erreur}.
				\end{itemize}
				\bigbreak
				
				
				\subparagraph{Exemple de fonctionnement de la machine CC :}
				Voici un exemple de la machine CC pour l'expression : 
				\smallbreak 
				$(((\lambda f.\lambda x.f$ $x)$ $\lambda y.(+$ $y$ $y))$ $\ulcorner 1\urcorner)$.
				
				\begin{multicols}{2}\raggedright{
						\begin{itemize}
							\item[] CC : $\langle(((\lambda f.\lambda x.f$ $x)$ $\lambda y.(+$ $y$ $y))$ $\ulcorner 1\urcorner),[]\rangle$
							\item[] > (1) 
							\item[] CC : $\langle((\lambda f.\lambda x.f$ $x)$ $\lambda y.(+$ $y$ $y)),[([]$ $\ulcorner 1\urcorner)]\rangle$
							\item[] > (3)
							\item[] CC : $\langle(\lambda x.f$ $x)[f \leftarrow \lambda y.(+$ $y$ $y)],[([]$ $\ulcorner 1\urcorner)]\rangle$
							\item[] CC : $\langle(\lambda x.(\lambda y.(+$ $y$ $y))$ $x),[([]$ $\ulcorner 1\urcorner)]\rangle$
							\item[] > (5)
							
						\end{itemize}
						
						\begin{itemize}
							\item[] CC : $\langle((\lambda x.(\lambda y.(+$ $y$ $y))$ $x)$ $\ulcorner 1\urcorner),[]\rangle$
							\item[] > (3) 
							\item[] CC : $\langle((\lambda y.(+$ $y$ $y))$ $x)[x \leftarrow \ulcorner 1\urcorner],[]\rangle$
							\item[] CC : $\langle((\lambda y.(+$ $y$ $y))$ $\ulcorner 1\urcorner),[]\rangle$
							\item[] > (3) 
							\item[] CC : $\langle(+$ $y$ $y)[y \leftarrow \ulcorner 1\urcorner],[]\rangle$
							\item[] CC : $\langle(+$ $\ulcorner 1\urcorner$ $\ulcorner 1\urcorner),[]\rangle$
							\item[] > (7)
							\item[] CC : $\langle\ulcorner 2\urcorner,[]\rangle$
						\end{itemize}
					}
				\end{multicols}
				
				\newpage
			
			
			
			\paragraph{SCC Machine :}
		
				La machine SCC est une simplification de la machine CC. En effet, la machine CC exploite uniquement les informations de la chaîne de contrôle (\textbf{Control string}). D'ailleurs le S de SCC est un acronyme de \textbf{Simplified}. Du coup on combine certaines règles en exploitant les informations du contexte (\textbf{Context}).
				\bigbreak
				
				
				Par exemple dans la machine CC, on peut réunir :
				
				\begin{itemize}
					\item[] (5)$_{cc}$ $\langle V,E[([]~N)]\rangle \longmapsto_{cc} \langle(V~N),E\rangle$
					\item[] (2)$_{cc}$ $\langle(V~N),E\rangle \longmapsto_{cc}  \langle N,E[(V~[])]\rangle$
					\item[] $\rightarrow$ sont combinées dans la règle (4)$_{scc}$ $ \langle V,E[[]~N)]\rangle \longmapsto_{scc} \langle N,E[(V~[])]\rangle$
					\item[]
					\item[] (4)$_{cc}$ $\langle V,E[(U~[])]\rangle \longmapsto_{cc} \langle(U~V),E\rangle$
					\item[]	(3)$_{cc}$ $\langle((\lambda X.M)~V),E\rangle \longmapsto_{cc} \langle M[X\longleftarrow V],E\rangle$
					\item[] $\rightarrow$ sont combinées dans la règle (3)$_{scc}$ $\langle V,E[((\lambda X.M)~[])]\rangle \longmapsto_{scc} \langle M[X\leftarrow V],E\rangle$
					\item[]
					\item[] (8)$_{cc}$ $\langle V,E[(o^{n}~V_{1}...V_{i}~[]~N~...)]\rangle \longmapsto_{cc} \langle(o^{n}~V_{1}...V_{i}~V~N ~...),E\rangle$ 
					\item[] (7)$_{cc}$ $\langle(o^{n}~b_{1}...b_{n}),E\rangle \longmapsto_{cc}  \langle V,E\rangle$ avec $V = \delta(o^{n},b_{1}...b_{n})$ 
					\item[] $\rightarrow$ sont combinées dans la règle (5)$_{scc}$ $\langle b,E[(o^{n},b_{1},...b_{i},[])]\rangle \longmapsto_{scc} \langle V,E\rangle~avec~\delta
					(o^{n},b_{1},...b_{i},b)=V$
				\end{itemize}
				\medbreak
				
				Le fonctionnement reste le même que la machine CC dans le principe et la façon de fonctionner. Le but de cette machine est d'utilisé toute les informations que l'on peut extraire d'un état de la machine pour rendre le fonctionnement plus rapide.
				\bigbreak
				
				
				Les règles qui définissent la machine SCC sont les suivantes :
				
				\begin{enumerate}
					\item $\langle(M~N),E\rangle \longmapsto_{scc} \langle M,E[([]~N)]\rangle$
					
					\item $\langle(o^{n}~M~N...),E\rangle \longmapsto_{scc} \langle M,E[(o^{n}~[]~N...)]\rangle$
					
					\item $\langle V,E[((\lambda X.M)$ $[])]\rangle \longmapsto_{scc} \langle M[X\leftarrow V],E\rangle$
					
					\item $\langle V,E[[]$ $N)]\rangle \longmapsto_{scc} \langle N,E[(V$ $[])]\rangle$
					
					\item $\langle b,E[(o^{n},b_{1},...b_{i},[])]\rangle \longmapsto_{scc} \langle V,E\rangle$ avec $\delta
					 (o^{n},b_{1},...b_{i},b)=V$ 
					 
					\item $\langle V,E[(o^{n},V_{1},...V_{i},[],N$ $L)]\rangle \longmapsto_{scc} \langle N,E[(o^{n},V_{1},...V_{i},V,[],L)]\rangle$
				\end{enumerate}
				\bigbreak
				
			
				De même que pour la machine CC,la machine SCC peut s'arrêter dans 3 états différents:
				\begin{itemize}
					\item[]$\longrightarrow$ on a une \textbf{constante b} telle que $\langle M,[]\rangle \twoheadrightarrow_{scc} \langle b,[]\rangle$;
					\item[]$\longrightarrow$ on a une \textbf{fonction} telle que $\langle M,[]\rangle \twoheadrightarrow_{scc} \langle\lambda X.N,[]\rangle$;
					\item[]$\longrightarrow$ on a un \textbf{état inconnu} soit une \textbf{erreur}.
				\end{itemize}
				\bigbreak
				
				
				\subparagraph{Exemple de fonctionnement de la machine SCC :}
					Voici un exemple de la machine SCC pour l'expression : 
					\smallbreak 
					$(((\lambda f.\lambda x.f$ $x)$ $\lambda y.(+$ $y$ $y))$ $\ulcorner 1\urcorner)$.
				
					\begin{multicols}{2}\raggedright{
							\begin{itemize}
								\item[] SCC : $\langle(((\lambda f.\lambda x.f$ $x)$ $\lambda y.(+$ $y$ $y))$ $\ulcorner 1\urcorner),[]\rangle$
								\item[] > (1)
								\item[] SCC : $\langle((\lambda f.\lambda x.f$ $x)$ $\lambda y.(+$ $y$ $y)),[([]$ $\ulcorner 1\urcorner)]\rangle$
								\item[] > (1)
								\item[] SCC : $\langle(\lambda f.\lambda x.f$ $x),[([]$ $\ulcorner 1\urcorner),([]$ $(\lambda y.(+$ $y$ $y)))]\rangle$
								\item[] > (4)
								\item[] SCC : $\langle(\lambda y.(+$ $y$ $y)),[([]$ $\ulcorner 1\urcorner),((\lambda f.\lambda x.f$ $x)$ $[])]\rangle$
								\item[] > (3) 
								\item[] SCC : $\langle(\lambda x.f$ $x)[f\leftarrow(\lambda y.(+$ $y$ $y))],[([]$ $\ulcorner 1\urcorner)]\rangle$
								\item[] SCC : $\langle(\lambda x.(\lambda y.(+$ $y$ $y))$ $x),[([]$ $\ulcorner 1\urcorner)]\rangle$
								\item[] > (4) 
								\item[] SCC : $\langle\ulcorner 1\urcorner,[((\lambda x.(\lambda y.(+$ $y$ $y))$ $x)$ $[])]\rangle$
								\item[] > (3) 
								\item[] SCC : $\langle((\lambda y.(+$ $y$ $y))$ $x)[x \leftarrow\ulcorner 1\urcorner],[]\rangle$
								\item[] SCC : $\langle((\lambda y.(+$ $y$ $y))$ $\ulcorner 1\urcorner,[]\rangle$
							\end{itemize}
							
							\begin{itemize}
								\item[] > (1) 
								\item[] SCC : $\langle(\lambda y.(+$ $y$ $y)),[([]$ $\ulcorner 1\urcorner)]\rangle$
								\item[] > (4)
								\item[] SCC : $\langle\ulcorner 1\urcorner,[(\lambda y.(+$ $y$ $y))$ $[])]\rangle$
								\item[] > (3) 
								\item[] SCC : $\langle(+$ $y$ $y)[y \leftarrow \ulcorner 1\urcorner],[]\rangle$	
								\item[] SCC : $\langle(+$ $\ulcorner 1\urcorner$ $\ulcorner 1\urcorner),[]\rangle$	
								\item[] > (2) 
								\item[] SCC : $\langle\ulcorner 1\urcorner,(+$ $[]$ $\ulcorner 1\urcorner)\rangle$	
								\item[] > (6) 
								\item[] SCC : $\langle\ulcorner 1\urcorner,(+$ $\ulcorner 1\urcorner$ $[])\rangle$	
								\item[] > (5)
								\item[] SCC : $\langle\ulcorner 2\urcorner,[]\rangle$	
							\end{itemize}
						}
					\end{multicols}
					\newpage
			
			
			
			\paragraph{CK Machine}
			
				Les machines CC et SCC cherche toujours a traiter l'élément le plus à gauche , c'est-à-dire que si l'on a une application on va en créer une intermédiaire dans le contexte avec un trou et traité la partie gauche de cette application etc jusqu'à arriver sur une valeur pour pouvoir "reconstruire", en reprenant l'application intermédiaire. C'est le style \textbf{ LIFO (Last In, First Out)}. Ce qui fait que les étapes de transition dépendent directement de la forme du 1er élément et non de la structure générale.
				\smallbreak
				Pour palier ce problème, la machine CK ajoute un nouvel élément le \textbf{registre de contexte d'évaluation}, nommé $\kappa$, qui permet la sauvegarde ce qu'on appelle la \textbf{continuation},c'est-à-dire la suite des instructions qu'il lui reste à exécuter.
				\smallbreak
				La machine CK va donc fonctionner avec une chaîne de contrôle \textbf{C} (\textbf{Control string}) comme les machines CC et SCC mais remplace le contexte par la continuation \textbf{K}. 
				\medbreak
				
				On a $\kappa$ = mt
				\begin{itemize}
					\item[|] $\langle fun,V,\kappa \rangle$
					\item[|] $\langle arg,N,\kappa \rangle$
					\item[|] $\langle opd,\langle V,...,V,o^{n}\rangle,\langle N,... \rangle,\kappa \rangle$
				\end{itemize}
				\smallbreak
				Cette continuation, au-delà de sauvegarder le reste de l'expression à traiter, va garder en mémoire ce que l'on a dedans. Basiquement elle va nous dire si on a une fonction, un argument ou une opération. Cette spécification permet d'enlever les \textbf{trous}.
				\medbreak
				
				Cette machine va agir en fonction de ce qui est présent dans la continuation.
				\begin{itemize}
					\item[] - Quand on a rien :
					\begin{itemize}
						\item[] - Soit on a une application $(M~N)$, On va traiter $M$ et dire que $N$ est un argument.
						\item[] - Soit on a une valeur ce qui signifie la fin du focntionnement de la machine
					\end{itemize}
					\item[] - Quand on a un argument $M$ : On aura une valeur $V$ dans la chaîne de contrôle. On va l'évalué et stocker dans la continuation $V$ qui est une fonction car si $M$ a été stocké comme un argument cela veut dire qu'initialement on avait l'application $(N~M)$; $N$ est évalué donne $V$ donc on doit appliquer $M$ à $V$ ce qui veut dire que $V$ est une fonction.
					\item[] - Quand on a une fonction $V$ : On va appliquer l'argument $U$ qui est dans la chaîne de contrôle a $V$
					\item[] - Quand on a une opération : on va traiter sucessivement chaque élément de l'opération qui sont en attente d'être traité et quand c'est fait on évalue l'opération. 
				\end{itemize}
				\bigbreak
				
				
				Les règles qui définissent la machine CK sont les suivantes :
				\begin{enumerate}
					\item $\langle(M$ $N),\kappa\rangle \longmapsto_{ck} \langle M,\langle arg,N,\kappa\rangle\rangle$
					\item $\langle V,\langle fun,(\lambda X.M),\kappa \rangle \rangle \longmapsto_{ck} \langle M[X \leftarrow V],\kappa\rangle$
					\item $\langle V,\langle arg,N,\kappa \rangle \rangle \longmapsto_{ck} \langle N,\langle fun,V,\kappa \rangle \rangle$
					\item $\langle(o^{n}$ $M$ $N...),\kappa\rangle \longmapsto_{ck} \langle M,\langle opd,\langle o^{n}\rangle,\langle N,...\rangle,\kappa\rangle\rangle$
					\item $\langle b,\langle opd,\langle b_{i},...b_{1},o^{n}\rangle,\langle\rangle,\kappa\rangle\rangle \longmapsto_{ck} \langle V,\kappa\rangle$ avec $\delta(o^{n},b_{1},...b_{i},b) = V$
					\item $\langle V,\langle opd,\langle V',...o^{n}\rangle,\langle N,L,...\rangle,\kappa\rangle\rangle \longmapsto_{ck} \langle N,\langle opd,\langle V,V',...o^{n}\rangle,\langle L,...\rangle,\kappa\rangle\rangle$
				\end{enumerate}
				\bigbreak
				
				
				la machine CK peut s'arrêter dans 3 états différents:
				\begin{itemize}
					\item[]$\longrightarrow$ on a une \textbf{constante b} telle que $\langle M,mt\rangle \twoheadrightarrow_{ck} \langle b,mt\rangle$;
					\item[]$\longrightarrow$ on a une \textbf{fonction} telle que $\langle M,mt\rangle \twoheadrightarrow_{ck} \langle\lambda X.N,mt\rangle$;
					\item[]$\longrightarrow$ on a un \textbf{état inconnu} soit une \textbf{erreur}.
				\end{itemize}
				\bigbreak
			
			
				Voici une partie de exemple de la machine CK pour l'expression : 
				$(((\lambda f.\lambda x.f$ $x)$ $\lambda y.(+$ $y$ $y))$ $\ulcorner 1\urcorner)$.
				\\ L'exemple complet peut être retrouvé dans l'\hyperref[CK]{Annexe 6.1.1}.
				
				\begin{multicols}{2}\raggedright{
						\begin{itemize}
							\item[] CK : $\langle(((\lambda f.\lambda x.f$ $x)$ $\lambda y.(+$ $y$ $y))$ $\ulcorner 1\urcorner),mt\rangle$
							\item[] ...
							\item[] On a un exmple d'application sur une abstraction
							\item[] CK : $\langle(\lambda x.(\lambda y.(+$ $y$ $y))$ $x),\langle arg,\ulcorner 1\urcorner,mt\rangle\rangle$	
							\item[] > (3) 
							\item[] CK : $\langle\ulcorner 1\urcorner,\langle fun,(\lambda x.(\lambda y.(+$ $y$ $y))$ $x),mt\rangle\rangle$
							\item[] > (2) 
							\item[] CK : $\langle((\lambda y.(+$ $y$ $y))$ $x)[x \leftarrow \ulcorner 1\urcorner ],mt\rangle$
							\item[] CK : $\langle((\lambda y.(+$ $y$ $y))$ $\ulcorner 1\urcorner),mt\rangle$
						\end{itemize}
						
						\begin{itemize}
							\item[] ...
							\item[] On voit comment l'opération est traitée
							\item[] CK : $\langle(+$ $\ulcorner 1\urcorner$ $\ulcorner 1\urcorner),mt\rangle$
							\item[] > (4)
							\item[] CK : $\langle\ulcorner 1\urcorner,\langle opd,\langle + \rangle,\langle\ulcorner 1\urcorner\rangle,mt\rangle\rangle$
							\item[] > (6) 
							\item[] CK : $\langle\ulcorner 1\urcorner,\langle opd,\langle\ulcorner 1\urcorner,+ \rangle,\langle\rangle,mt\rangle\rangle$
							\item[] > (5) 
							\item[] CK : $\langle\ulcorner 2\urcorner,mt\rangle$
						\end{itemize}
					}
				\end{multicols}
				\newpage
				
				
				
			\paragraph{CEK Machine}
		
				Pour toutes les machines vues jusqu'à présent la $\beta$-réduction est appliquée immédiatement. Cela coûte cher surtout quand l'expression devient grande. De plus, si notre substitution n'est pas une variable elle est traitée avant d'être appliquée.
				\smallbreak
				Il est plus intéressant d'appliquer les substitutions quand on en a vraiment la nécessité. Pour cela, la machine CEK ajoute les fermetures et un environnement $\varepsilon$ qui va stocker les substitutions à effectuer. Cette environnement est une fonction qui pour une variable va retourner une expression.
				\medbreak
				
				On a alors:
				\begin{itemize}
					\item[] $\varepsilon$ = une fonction $\{\langle X,c\rangle,...\}$    c = $\{\langle M,\varepsilon\rangle$ $|$ $FV(M)\subset dom(\varepsilon)\}$    v = $\{\langle V,\varepsilon\rangle$ $|$ $\langle V,\varepsilon\rangle \in c\}$
					\item[] $\varepsilon[X \leftarrow c]$ = $\{\langle X,c\rangle\}$ $\cup$ $\{\langle Y,c'\rangle$ $|$ $\langle Y,c'\rangle \in \varepsilon$ et $ Y \neq X\}$
				\end{itemize}
				\medbreak
				
				$\kappa$ est renommé $\overline{\kappa}$ et défini par :
				\smallbreak
				$\overline{\kappa}$ = mt
				\begin{itemize}
					\item[|] $\langle fun,v,\overline{\kappa} \rangle$
					\item[|] $\langle arg,c,\overline{\kappa} \rangle$
					\item[|] $\langle opd,\langle v,...,v,o^{n}\rangle,\langle c,... \rangle,\overline{\kappa} \rangle$
				\end{itemize}
				\bigbreak
				
				
				Les règles qui définissent la machine CEK sont les suivantes :
				\begin{enumerate}
					\item $\langle\langle(M$ $N),\varepsilon\rangle,\overline{\kappa}\rangle \longmapsto_{cek} \langle \langle M,\varepsilon\rangle,\langle arg,\langle N,\varepsilon\rangle,\overline{\kappa}\rangle\rangle$	
					\item $\langle\langle X,\varepsilon\rangle,\overline{\kappa}\rangle \longmapsto_{cek} \langle c,\overline{\kappa}\rangle$ avec $\varepsilon(X) = c$
					\item $\langle\langle V,\varepsilon\rangle,\langle fun,\langle (\lambda X1.M),\varepsilon'\rangle,\overline{\kappa} \rangle \rangle \longmapsto_{cek} \langle \langle M,\varepsilon'[X1 \leftarrow \langle V,\varepsilon\rangle]\rangle,\overline{\kappa}\rangle$ si $V \notin X$
					\item  $\langle \langle V,\varepsilon\rangle,\langle arg,\langle N,\varepsilon'\rangle,\kappa\rangle\rangle \longmapsto_{cek} \langle \langle N,\varepsilon'\rangle,\langle fun,\langle V,\varepsilon\rangle,\overline{\kappa}\rangle\rangle$ si $V \notin X$
					\item $\langle\langle(o^{n}$ $M$ $N...),\varepsilon\rangle,\overline{\kappa}\rangle \longmapsto_{cek} \langle \langle M,\varepsilon\rangle,\langle opd,\langle o^{n}\rangle,\langle \langle N,\varepsilon\rangle,...\rangle,\overline{\kappa}\rangle\rangle$
					\item $\langle  \langle b,\varepsilon\rangle,\langle opd,\langle \langle b_{i},\varepsilon_{i}\rangle,...\langle b_{1},\varepsilon_{1}\rangle ,o^{n}\rangle,\langle\rangle,\overline{\kappa}\rangle\rangle \longmapsto_{cek} \langle \langle V,\emptyset\rangle,\overline{\kappa}\rangle$ avec $\delta(o^{n},b_{1},...b_{i},b) = V$
					\item $\langle \langle V,\varepsilon\rangle,\langle opd,\langle v',...o^{n}\rangle,\langle  \langle N,\varepsilon'\rangle,c,...\rangle,\overline{\kappa}\rangle\rangle \longmapsto_{cek} \langle \langle N,\varepsilon'\rangle,\langle opd,\langle  \langle V,\varepsilon\rangle,v',...o^{n}\rangle,\langle c,...\rangle,\overline{\kappa}\rangle\rangle$ si $V \notin X$
				\end{enumerate}
				\bigbreak
				
				
				la machine CEK peut s'arrêter dans 3 états différents:
				\begin{itemize}
					\item[]$\longrightarrow$ on a une \textbf{constante b} telle que $\langle \langle M,\emptyset\rangle,mt\rangle \twoheadrightarrow_{cek} \langle\langle b,\varepsilon\rangle,mt\rangle$;
					\item[]$\longrightarrow$ on a une \textbf{fonction} telle que $\langle \langle M,\emptyset\rangle,mt\rangle \twoheadrightarrow_{cek} \langle\langle \lambda X.N,\varepsilon\rangle,mt\rangle$;
					\item[]$\longrightarrow$ on a un \textbf{état inconnu} soit une \textbf{erreur}.
				\end{itemize}
				\bigbreak
				
				
				On va voir une partie d'un exemple pour voir le changement avec la machine CK. On se concentre sur l'utilisation de l'environnement.
				\medbreak
				
				\begin{itemize}
					\item[] CEK machine : $\langle\langle(((\lambda f.\lambda x.f$ $x)$ $\lambda y.(+$ $y$ $y))$ $\ulcorner 1\urcorner),\emptyset\rangle,mt\rangle$
					\item[] ...
					\item[] On a deux parties qui appliquent une abstraction.
					\item[] CEK : $\langle\langle(\lambda y.(+$ $y$ $y)),\emptyset\rangle,\langle fun,\langle(\lambda f.\lambda x.f$ $x),\emptyset\rangle,\langle arg,\langle\ulcorner 1\urcorner,\emptyset\rangle,mt\rangle\rangle\rangle$
					\item[] > (3) 
					\item[] CEK : $\langle\langle(\lambda x.f$ $x),\emptyset[f \leftarrow \langle(\lambda y.(+$ $y$ $y)),\emptyset\rangle]\rangle,\langle arg,\langle\ulcorner 1\urcorner,\emptyset\rangle,mt\rangle\rangle$
					\item[] CEK : $\langle\langle(\lambda x.f$ $x),\{\langle f,\langle(\lambda y.(+$ $y$ $y)),\emptyset\rangle\rangle\}\rangle,\langle arg,\langle\ulcorner 1\urcorner,\emptyset\rangle,mt\rangle\rangle$
					\item[] > (4) 
					\item[] CEK : $\langle\langle\ulcorner 1\urcorner,\emptyset\rangle,\langle fun,\langle(\lambda x.f$ $x),\{\langle f,\langle(\lambda y.(+$ $y$ $y)),\emptyset\rangle\rangle\}\rangle,mt\rangle\rangle$
					\item[] > (3) 
					\item[] CEK : $\langle\langle(f$ $x),\{\langle f,\langle(\lambda y.(+$ $y$ $y)),\emptyset\rangle\rangle\}[x \leftarrow \langle\ulcorner 1\urcorner,\emptyset\rangle]\rangle,mt\rangle$
					\item[] CEK : $\langle\langle(f$ $x),\{\langle f,\langle(\lambda y.(+$ $y$ $y)),\emptyset\rangle\rangle,\langle x,\langle\ulcorner 1\urcorner,\emptyset\rangle\rangle\}\rangle,mt\rangle$
					\item[] > (1)
					\item[] ...
					\item[] On voit comment la subsitution s'applique sur cette partie.
					\item[] CEK : $\langle\langle f,\{\langle f,\langle(\lambda y.(+$ $y$ $y)),\emptyset\rangle\rangle,\langle x,\langle\ulcorner 1\urcorner,\emptyset\rangle\rangle\}\rangle,\langle arg,\langle x,\{\langle f,\langle(\lambda y.(+$ $y$ $y)),\emptyset\rangle\rangle,\langle x,\langle\ulcorner 1\urcorner,\emptyset\rangle\rangle\}\rangle,mt\rangle\rangle$
					\item[] > (2) 
					\item[] CEK : $\langle\langle(\lambda y.(+$ $y$ $y)),\emptyset\rangle,\langle arg,\langle x,\{\langle f,\langle(\lambda y.(+$ $y$ $y)),\emptyset\rangle\rangle,\langle x,\langle\ulcorner 1\urcorner,\emptyset\rangle\rangle\}\rangle,mt\rangle\rangle$
					\item[] ...
					\item[] CEK : $\langle\langle\ulcorner 2\urcorner,\emptyset\rangle,mt\rangle$
				\end{itemize}
				\medbreak
				
				L'exemple complet peut être retrouvé dans l'\hyperref[CEK]{Annexe 6.1.2}.
				\bigbreak
				
			
			\paragraph{SECD Machine}
			
				La différence entre la machine CEK et SECD se situe dans la façon dont le contexte est sauvegardeé pendant que les sous-expressions sont évaluées.\\
				En effet, dans la machine SECD le contexte est créé par un appel de fonction, quand tout est stocké dans $\widehat{D}$ pour laisser un espace de travail. Par contre pour la machine CEK, le contexte est créé quant on évalue une application ou un argument indépendamment de la complexité de celui-ci.
				\smallbreak 
				Dans les langages tels que Java, Pascal ou encore C la façon de faire de la machine SECD est plus naturelle. Par contre  dans les langages $\lambda$-calculs, Scheme ou encore ML c'est la façon de faire de la machine CEK qui est la plus naturelle.
				\medbreak
				
				La machine SECD est composée d'une pile pour les valeurs ($\widehat{S}$), d'un environnement ($\widehat{\varepsilon}$) pour lier les variables $X$ à une valeur $\widehat{V}$, d'une chaîne de contrôle ($\widehat{C}$) et d'un dépôt ($\widehat{D}$). Les différentes définitions de ces éléments sont les suivantes :
				\smallbreak
				\begin{itemize}
					\item[] $\widehat{S} = \epsilon$ 
					\begin{itemize}
						\item[|] $\widehat{V}~\widehat{S}$
					\end{itemize}
					\item[] $\widehat{\varepsilon} =$ une fonction $\{\langle X,\widehat{V}\rangle,...\}$
					\item[] $\widehat{C}$ = $\epsilon$ 
					\begin{itemize}
						\item[|] $b~\widehat{C}$
 						\item[|] $X~\widehat{C}$
						\item[|] $ap~\widehat{C}$
						\item[|] $prim_{o^{n}}~\widehat{C}$
						\item[|] $\langle X,\widehat{C}\rangle~\widehat{C}$
					\end{itemize}
					\item[] $\widehat{D}$ = $\epsilon$
					\begin{itemize}
						\item[|] $\langle\widehat{S},\widehat{\varepsilon},\widehat{C},\widehat{D}\rangle$
					\end{itemize}
					\item[] $\widehat{V} = b$
					\begin{itemize}
						\item[|] $\langle\langle X,\widehat{C}\rangle,\widehat{\varepsilon}\rangle$
					\end{itemize}
				\end{itemize}
				\bigbreak
			
				Une autre spécificité de la machine SECD vient de sa propre grammaire. En effet la machine SECD convertit la $\lambda$-expression par son propre langage. Le langage fonctionne avec des éléments simple comme des constantes, des variables et des fonctions et des commandes qui permettent de savoir ce que doit faire la machine. Voici les règles de conversion :
				\smallbreak
				
				\begin{itemize}
					\item[] $\textlbrackdbl b\textrbrackdbl _{secd}$ = b
					\item[] $\textlbrackdbl X\textrbrackdbl _{secd}$ = X
					\item[] $\textlbrackdbl (M_{1}$ $M_{2})\textrbrackdbl _{secd}$ = $\textlbrackdbl M_{1}\textrbrackdbl _{secd}$ $\textlbrackdbl M_{2}\textrbrackdbl _{secd}$ ap
					\item[] $\textlbrackdbl (o^{n}$ $M_{1}...M_{n})\textrbrackdbl _{secd}$ = $\textlbrackdbl M_{1}\textrbrackdbl _{secd}$ $...$ $\textlbrackdbl M_{n}\textrbrackdbl _{secd}$ $prim_{o^{n}}$
					\item[]  $\textlbrackdbl(\lambda X.M)\textrbrackdbl _{secd}$ =  $\langle X,\textlbrackdbl M\textrbrackdbl _{secd}\rangle$
				\end{itemize}
				\bigbreak
				
				
				Cette machine doit être la plus simple à comprendre dans son fonctionnement :
				\begin{itemize}
					\item[] - Si elle a une constante, elle la stocke dans la pile. On peut dire qu'elle la garde en attente de l'utiliser pour une commande. 
					\item[] - Si elle a une variable, elle prend sa substitution dans l'environement et la stocke dans la pile comme une constante
					\item[] - Si elle une abstraction, elle va créer ce qu'on appelle une fermeture. C'est-à-dire que l'on va lié l'abstraction avec l'environnement. Ce processus va permettre de mettre en attente l'évaluation de l'expression présent dans l'abstraction. elle stocke la fermeture dans la pile comme une constante.
					\item[] - Si elle a une commande $ap$, on effectue une application sur les deux éléments de tête de la pile. Cette application va mettre en attente l'expression principale pour ce concentrer sur une sous-expression. Pour cela, la machine va faire une sauvegarde d'elle-même avant et la stocker dans le dépôt.
					\item[] - Si elle a une commande $prim_{o^{n}}$, on effectue l'opération sur les n premiers éléments de la pile.
					\item[] - Si elle a rien :
					\begin{itemize}
						\item[] - elle a une sauvegarde dans le dépôt, elle va reprendre cette sauvegarde.
						\item[] - elle n'a pas de sauvegarde, elle a finit son travail.
					\end{itemize}
				\end{itemize}
				\bigbreak
				
				Les règles qui définissent la machine SECD sont les suivantes :
				\smallbreak
				\begin{enumerate}
					\item $\langle\widehat{S},\widehat{\varepsilon},b$ $\widehat{C},\widehat{D}\rangle \longmapsto_{secd} \langle b$ $\widehat{S},\widehat{\varepsilon},\widehat{C},\widehat{D}\rangle$
					\item $\langle\widehat{S},\widehat{\varepsilon},X$ $\widehat{C},\widehat{D}\rangle \longmapsto_{secd} \langle \widehat{V}$ $\widehat{S},\widehat{\varepsilon},\widehat{C},\widehat{D}\rangle$ où $\widehat{V} = \varepsilon(X)$
					\item $\langle\widehat{S},\widehat{\varepsilon},\langle X,C'\rangle$ $\widehat{C},\widehat{D}\rangle \longmapsto_{secd} \langle\langle\langle X,C'\rangle,\varepsilon\rangle$ $\widehat{S},\widehat{\varepsilon},\widehat{C},\widehat{D}\rangle$
					\item $\langle\widehat{V}$ $\langle\langle X,C'\rangle,\varepsilon'\rangle$ $\widehat{S},\widehat{\varepsilon},ap$ $\widehat{C},\widehat{D}\rangle \longmapsto_{secd} \langle\epsilon,\varepsilon'[X \leftarrow \widehat{V}],C',\langle\widehat{S},\widehat{\varepsilon},\widehat{C},\widehat{D}\rangle\rangle$
					\item $\langle\widehat{V}$ $\widehat{S},\widehat{\varepsilon},\emptyset,\langle\widehat{S'},\widehat{\varepsilon'},\widehat{C'},\widehat{D}\rangle\rangle \longmapsto_{secd} \langle \widehat{V}$ $\widehat{S'},\widehat{\varepsilon'},\widehat{C'},\widehat{D}\rangle$
					\item $\langle b_{1}$ $...$ $b_{n}\widehat{S},\widehat{\varepsilon},prim_{o^{n}}$ $\widehat{C},\widehat{D}\rangle \longmapsto_{secd} \langle \widehat{V}$ $\widehat{S},\widehat{\varepsilon},\widehat{C},\widehat{D}\rangle$ où $\widehat{V} = \delta(o^{n},b_1,...b_{n})$
				\end{enumerate}
				\bigbreak
				
				
				la machine SECD peut s'arrêter dans 3 états différents:
				\begin{itemize}
					\item[]$\longrightarrow$ on a une \textbf{constante b} telle que $\langle \epsilon,\emptyset,\textlbrackdbl M\textrbrackdbl_{secd},\epsilon\rangle \twoheadrightarrow_{secd} \langle b,\widehat{\varepsilon},\epsilon,\epsilon\rangle$;
					\item[]$\longrightarrow$ on a une \textbf{fonction} telle que $\langle \epsilon,\emptyset,\textlbrackdbl M\textrbrackdbl_{secd},\epsilon\rangle \twoheadrightarrow_{secd} \langle\langle\langle X,\widehat{C}\rangle,\widehat{\varepsilon'}\rangle,\widehat{\varepsilon},\epsilon,\epsilon\rangle$;
					\item[]$\longrightarrow$ on a un \textbf{état inconnu} soit une \textbf{erreur}.
				\end{itemize}
				\bigbreak
				
				Voyons sur un exemple les avantages de cette machine. Un exemple étant assez long, on va s'intéresser à certaines parties. L'exemple complet est disponible dans l'\hyperref[SECD]{Annexe 6.1.3}. 
				\\
				On va tester la machine sur la $\lambda$-expression suivante : $(((\lambda f.\lambda x.f$ $x)$ $\lambda y.(+$ $y$ $y))$ $\ulcorner 1\urcorner)$ .
				\bigbreak
				
				\begin{itemize}
					\item[] On passe la conversion, utile mais pas intéressante.
					\item[] Conversion : $\textlbrackdbl(((\lambda f.\lambda x.f$ $x)$ $\lambda y.(+$ $y$ $y))$ $\ulcorner 1\urcorner)\textrbrackdbl_{secd}$
					\item[] ...
					\item[] Conversion : $\langle f,\langle x,f$ $x$ $ap\rangle\rangle$ $\langle y,y$ $y$ $prim_{+}\rangle$ $ap$ $\ulcorner 1\urcorner$ $ap$
					\item[] SECD Machine : $\langle\epsilon,\emptyset,\langle f,\langle x,f$ $x$ $ap\rangle\rangle$ $\langle y,y$ $y$ $prim_{+}\rangle$ $ap$ $\ulcorner 1\urcorner$ $ap,\epsilon\rangle$ 
					\item[] ...
					\item[] On voit comment l'application est traitée
					\item[] SECD : $\langle\langle\langle y,y$ $y$ $prim_{+}\rangle,\emptyset\rangle$ $\langle\langle f,\langle x,f$ $x$ $ap\rangle\rangle,\emptyset\rangle,\emptyset,ap$ $\ulcorner 1\urcorner$ $ap,\epsilon\rangle$
					\item[] > (4)
					\item[] SECD : $\langle\epsilon,\emptyset[f \leftarrow \langle\langle y,y$ $y$ $prim_{+}\rangle,\emptyset\rangle],\langle x,f$ $x$ $ap\rangle,\langle\epsilon,\emptyset,\ulcorner 1\urcorner$ $ap,\epsilon\rangle\rangle$
					\item[] SECD : $\langle\epsilon,\{\langle f,\langle\langle y,y$ $y$ $prim_{+}\rangle,\emptyset\rangle\rangle\},\langle x,f$ $x$ $ap\rangle,\langle\epsilon,\emptyset,\ulcorner 1\urcorner$ $ap,\epsilon\rangle\rangle$
					\item[] >  (3)
					\item[] 
					\item[] On voit l'intérêt de la sauvegarde.
					\item[] SECD : $\langle\langle\langle x,f$ $x$ $ap\rangle,\{\langle f,\langle\langle y,y$ $y$ $prim_{+}\rangle,\emptyset\rangle\rangle\}\rangle,\{f,\langle\langle y,y$ $y$ $prim_{+}\rangle,\emptyset\rangle\},\emptyset,\langle\epsilon,\emptyset,\ulcorner 1\urcorner$ $ap,\epsilon\rangle\rangle$
					\item[] > (5)
					\item[] SECD : $\langle\langle\langle x,f$ $x$ $ap\rangle,\{\langle f,\langle\langle y,y$ $y$ $prim_{+}\rangle,\emptyset\rangle\rangle\}\rangle,\emptyset,\ulcorner 1\urcorner$ $ap,\epsilon\rangle$
					\item[] ...
					\item[] On voit comment est gérée l'opération
					\item[] SECD : $\langle\ulcorner 1\urcorner$ $\ulcorner 1\urcorner,\{\langle y,\ulcorner 1\urcorner\rangle\},prim_{+},\langle\epsilon,\{\langle f,\langle\langle y,y$ $y$ $prim_{+}\rangle,\emptyset\rangle\rangle,\langle x,\ulcorner 1\urcorner\rangle\} ,\emptyset,\langle\epsilon,\emptyset,\epsilon,\epsilon\rangle\rangle\rangle$
					\item[] > (6)
					\item[] SECD : $\langle\ulcorner 2\urcorner,\{\langle y,\ulcorner 1\urcorner\rangle\},\emptyset,\langle\epsilon,\{\langle f,\langle\langle y,y$ $y$ $prim_{+}\rangle,\emptyset\rangle\rangle,\langle x,\ulcorner 1\urcorner\rangle\} ,\emptyset,\langle\epsilon,\emptyset,\epsilon,\epsilon\rangle\rangle\rangle$
					\item[] > (5)
					\item[] SECD : $\langle\ulcorner 2\urcorner,\{\langle f,\langle\langle y,y$ $y$ $prim_{+}\rangle,\emptyset\rangle\rangle,\langle x,\ulcorner 1\urcorner\rangle\} ,\emptyset,\langle\epsilon,\emptyset,\epsilon,\epsilon\rangle\rangle$
					\item[] > (5)
					\item[] SECD : $\langle\ulcorner 2\urcorner,\emptyset,\epsilon,\epsilon\rangle$
				\end{itemize}
				\newpage
				


		\subsection{Programmation réactive}
		
			\paragraph{Le cas du Réactive ML}
				Modèle de programmation $\longrightarrow$ concurrence coopérative 
				\smallbreak
				L'analyse est découpé en 2 sous analyse :
				\begin{itemize}
					\item \textbf{statique} : système de type et d'effet
					\item \textbf{réactive} : détecter les erreurs de concurrence
				\end{itemize}
				\bigbreak
				
				
				Ordonnancement coopératif$\ast$ $\longrightarrow$ \textit{\small{chaque processus va r\'{e}guli\`{e}rement "laisser la main aux autres"}}
				\smallbreak
				Ordonnancement pr\'{e}emptif $\longrightarrow$ \textit{\small{le syst\`{e}me va "donner un temps de parole" \`{a} chacun}}
				\medbreak
					
				Points fort :
				\begin{itemize}
					\item \textit{\small{impl\'{e}mentation s\'{e}quentielle efficace}}
					\item \textit{\small{pas de probl\`{e}me de parall\'{e}lisme}}
				\end{itemize}
				\medbreak
					
				Points faible : 
				\begin{itemize}
					\item \textit{\small{responsabilit\'{e} de la r\'{e}activit\'{e} au dev}}
				\end{itemize}
				\medbreak
					
				Le mod\`{e}le r\'{e}actif synchrone d\'{e}finit une notion de temps logique qui est une succession d'instant.
				\smallbreak
				\textbf{Un programme est r\'{e}actif si son ex\'{e}cution fait progresser les instants logique.}
				\medbreak
					
				\textbf{Exemple}
				\medbreak
					
				\begin{enumerate}
				 	\item let process clock timer s =
				 	\item $\quad$ let time = ref(Unix.gettimeofday()) in
				 	\item $\quad$ loop
				 	\item $\quad$ $\quad$ let time' = Unix.gettimeofday() in
				 	\item $\quad$ $\quad$ if time' -. !time >= timer
				 	\item $\quad$ $\quad$ then(emit s(); time := time')
				 	\item $\quad$ end 
			 	\end{enumerate}
				\medbreak
					
				Le probl\`{e}me ici est que le contenu de la boucle peut s'effectuer instantan\'{e}ment alors qu'il faudrait attendre un instant logique pour l'éxécuter. Par conséquent, on doit ajouter une \textbf{pause entre les lignes 6 et 7}.
				\bigbreak
					
				Une \textbf{condition suffisante} pour qu'un \textbf{processus r\'{e}cursif soit r\'{e}actif} est qu'il y ait \textbf{toujours} \textbf{un instant logique entre l'instanciation du processus et l'appel r\'{e}cursif}.
				\bigbreak
					
				Le reste de l'article rentre beaucoup plus dans les détails avec l'analyse syntaxique qui prend en compte la réactivité du langage.
			
				\newpage
			
			
			
	\section{Langage fonctionnel réactif}\label{SECDConc4}
			
		Le but est de réutiliser une des machines étudiées et de la rendre réactive. Les premières machines sont trop simple pour être utilisées. Restent la machine CEK et la machine SECD. Cependant il y a une contrainte qui va réussir à les départager. En effet, il nous faut une machine qui fait un appel par valeur, c'est-à-dire que les paramètres seront évalués avant la fonction. La machine SECD remplit ce critère donc c'est celle que nous utiliserons comme base.
		\medbreak
			
		Mes encadrants m'ont donné des ajouts à faire par petites parties afin de structurer mon avancée. Je vais donc redonner les ajouts pour chaque partie ainsi que l'explication de leurs implantations.
		\bigbreak
			
			
		\subsection{Machine réactive pure}
		
			\subsubsection{Description informelle du langage}
				
				Avant tout développement sur l'implantation il faut pouvoir bien cerner le principe de la réactivité. Le but est de créer un "dialogue" entre plusieurs parties de la machine. 
				\medbreak
					
				En arrondissant les angles, on peut voir ça comme une discussion. Je m'explique, la discussion c'est notre machine, on a une personne que l'on va nommer Monsieur X qui représente notre programme principal. On peut dire qu'il initie la discussion. Monsieur X va introduire des personnes dans la discussion, ces personnes sont nos parties de programme indépendantes. Monsieur X va commencer à parler puis laissera la parole quand il aura fini de parler ou ne saura pas quoi répondre et ainsi de suite. Pendant qu'une personne parle, il peut donner une information qui sera utilisée par un autre et donc qui se remettra dans la discussion. Ces informations seront représentées par des signaux. Quand tout le monde a fini de parler, c'est la fin de la discussion ce qui représente la fin de la machine.
				\medbreak
					
				Un point qu'il faut bien comprendre est que l'absence d'une information (d'un signal) est aussi importante que sa présence. Un exemple naïf, si vous demandez à quelqu'un s'il dort une réponse donne une information aussi importante qu'une absence de réponse.
				\medbreak
					
				Un autre point délicat est la fin d'un instant logique. Pour savoir si on nous répond ou pas, on attend un instant et on en déduit que l'on ne nous répondra pas. Pour la machine c'est pareil. L'instant courant est lorsque tout le monde discute, quand plus personne ne parle c'est la fin de l'instant courant. On passe à l'instant suivant et ceux qui attendaient une information spécifique vont exhiber un autre argument et la discussion recommence jusqu'à ce que plus personne n'ait d'argument
				\medbreak
					
				Le principe étant expliqué, nous pouvons rentrer dans les détails. L'idée est d'avoir plusieurs machine SECD qui se parlent donc il faut créer une structure plus large qui peut les stocker. On part cependant d'une seule chaîne de contrôle donc il faut pouvoir créer ces "mini-machines". Ces "mini-machines" sont ce que l'ont va appeler des \textbf{threads}.
				\bigbreak
					
					
				\paragraph{Un Thread}
						
					\subparagraph{Qu'est-ce qu'un thread ?}
					Un thread est l'équivalent d'un processus, il a sa propre pile d'éxécution mais peut récupérer des informations sur une mémoire partagée. En simplifiant, si on fait un lien avec la machine SECD, on peut dire que chaque thread est une machine SECD et que toutes ces machines SECD vont communiquer entre elles.
						
					\subparagraph{Quelle forme doit avoir un thread ?} 
					Un thread est ,comme dit plus haut, une machine SECD en soi donc elle va prendre cette forme c'est-à-dire que l'on va avoir $T~=~\langle S,E,C,D\rangle$. Pour l'instant c'est tout ce qui nous est nécessaire dans le thread.
						
					\subparagraph{Comment les stocker ?}
					Pour les stocker, on va se demander si l'on veut un ordre ou pas dans notre stockage. Il faut noter un point important pour faire une machine fonctionnelle, il vaut mieux avoir une machine déterministe.
					\medbreak
						
					\textit{Machine déterministe :} Une machine est déterministe si pour une entrée donnée, on a une seule sortie possible et un unique "chemin" possible dans la machine, c'est-à-dire une unique suite de transitions possibles.
					\medbreak
						
					Pour éviter de la rendre non déterministe, on va opter pour une file d'attente $TL$ tels que $\forall~tl \in Tl~:~tl = T$.
					\bigbreak
						
				\paragraph{Un Signal} 
					
					\subparagraph{Qu'est-ce qu'un signal ?}
					Un signal est une information que l'on transmet entre chaque thread. Pour les bases, tout ce qui va nous intéresser est la présence ou l'absence d'un signal. C'est grâce à cela qu'un thread va pouvoir agir en conséquence d'un autre. 
						
					\subparagraph{Quelle forme doit avoir un thread ?} 
					Dans un premier temps un signal sera constitué de deux informations : 
					\begin{enumerate}
						\item Est-il initialisé ?
						\item Est-il émis ?
					\end{enumerate}
					La forme d'un signal dans notre machine est dévéloppée dans la partie \textbf{L'initialisation d'un signal}.
						
					\subparagraph{Comment les stocker ?}
					Comme pour les threads, on doit se poser la question de la structure que l'on veut mais aussi de si l'on veut un ordre ou non. Plusieurs possibilités ont été explorées et sont directement liées ,là aussi, on développe ce point dans la partie \textbf{L'initialisation d'un signal}. Mais dans tous les cas on va devoir créer une liste qui va stocker au moins le fait qu'il est émis, il faudra donc forcément un élément que l'on va nommer $SI$ qui sera une liste prévue pour stocker les signaux.
					\bigbreak 
				
						
				\paragraph{Le Spawn} 
					
					\subparagraph{Comment créer un thread ?}
					Pour créer ce que l'on va appeler \textbf{des threads}, on va devoir prendre dans la chaîne de contrôle une partie de celle-ci. Pour cela on va requérir à la commande $Spawn$. Elle va nous servir à délimiter la partie à prendre. Deux versions de cette commande existent, la première peut être retrouvé dans la plupart des versions de la machine et la seconde a été proposée par un de mes encadrants et elle est présente dans la dernière version.
					\smallbreak
					\begin{enumerate}
						\item $bspawn~C~espawn$ : la machine prend $Spawn~C$ et le convertit en deux délimiteurs qui servent à entourer la partie de la chaîne de contrôle que l'on veut prendre. Le gros défaut de cette version bien qu'utilisable est sa forme. On crée une structure que doit reconnaître la machine alors que la machine SECD attend soit des éléments simples soit une commande.
						\item $\langle X,C\rangle~spawn$ : ici la machine convertit le $Spawn~C$ en une abstraction et une commande $spawn$. L'abstraction permet d'encapsuler la partie de la chaîne de contrôle que l'on veut. Grâce à cela la machine n'essaie pas de l'évaluer. $spawn$ est juste une commande, donc plus logique dans le fonctionnement de la machine. Elle permet de comprendre que la fermeture présent dans la pile est ce que l'on veut pour créer notre thread. 
					\end{enumerate}
					\medbreak
						
						
						
				\paragraph{L'initialisation d'un signal}
					
					\subparagraph{Comment créer un signal ?}
					Pour créer un signal, on va devoir utiliser une commande $Signal~s~in~t$ avec un signal $s$ et une expression $t$. Cette commande a été modifiée dans les dernières versions. Voici une énumération du travail fait autour de cette commande.
					\smallbreak
					\begin{enumerate}
						\item $Signal~s~in~t$ : l'identifiant du signal est donné et va être initialisé seulement pour l'expression t. Cette version est la plus complexe car il faut stocker énormément d'informations. En effet, il faut stocker l'initialisation du signal pour le thread courant mais aussi pour une partie précise de la chaîne de contrôle du thread courant. Pour cela, deux versions ont été créées :
						\begin{enumerate}
							\item On utilise le principe de la sauvegarde. Simplement expliqué, quand la machine SECD applique une valeur sur une abstraction, elle fait une sauvegarde d'elle-même pour mettre en pause le travail sur la partie principale et se mettre à travailler sur une partie secondaire. Si on reprend le même principe, on peut stocker l'initialisation du signal dans l'environnement après l'avoir sauvegardé. L'élément $SI$ nommé plus haut sera donc de la forme $SI=\{s,...\}$ telle que $s$ représente un signal émis.
							\medbreak
								
							\textbf{Exemple :} Si on prend $\langle s,C'\rangle$ la version convertie de $Signal~s~in~t$ on a : 
							\\$\langle S,E,\langle s,C'\rangle C,D,SI\rangle \longrightarrow \langle \emptyset,\emptyset~[init \leftarrow s],C',\langle S,E,C,D\rangle,SI\rangle$  
							\medbreak
								
							Le problème de cette version est qu'il provoque un stockage double des signaux dans la machine à cause des commandes à venir. En effet, on va garder l'initialisation dans l'environnement et l'émission dans l'élément $SI$. Ce n'est pas optimal.
								
							\item On utilise la sauvegarde mais différemment. En effet on va faire une sauvegarde comme pour la première version cependant on va pas mettre l'initialisation dans l'environnement mais directement la où l'on voudra stocker plus tard via un booléen. On va créer une variante de la sauvegarde de la machine SECD ,dans le dépôt, de la forme $\langle s,\langle S,E,C,D\rangle\rangle$. Ce qui va nous permettre de savoir quand est-ce que l'on sort de l'expression pour lequelle on avait initialisé le signal. La structure $SI$ ici prend une autre forme, on a $SI=\{\langle s,init,emit\rangle\}$ telle que un signal $s$, un booléen représentant l'initialisation $init$  et un booléen représentant l'émission du signal $emit$.
							\medbreak
								
							\textbf{Exemple :} Si on prend $\langle s,C'\rangle$ la version convertie de $Signal~s~in~t$ on a : 
							\\$\langle S,E,\langle s,C'\rangle C,D,SI\rangle \longrightarrow \langle \emptyset,\emptyset,C',\langle s,\langle S,E,C,D\rangle\rangle,SI~\langle s,true,false\rangle \rangle$ 
							\medbreak
								
							Cette version est assez efficace mais reste lourde dans la machine niveau du stockage et la façon dont cette commande est convertie crée le même problème que pour la première version du $Spawn$:  on est pas censé avoir de structure à traiter dans la machine.
						\end{enumerate}
						
						\item $Init~s$ : l'identifiant du signal est donné et va être initialisé pour tous les éléments de la machine. Cette version va drastiquement simplifier le fonctionnement de la machine car on a plus besoin de le limiter l'action de l'initialisation à une partie de la chaîne de contrôle ni à un thread en particulier. Simplement, on va mettre le signal dans le stockage des signaux. Ce fait sera nécessaire et suffisant pour savoir qu'il est initialisé. La structure de $SI$ va donc être de la forme $\langle s,emit\rangle$ telle qu'un signal $s$ et un booléen représentant l'émission du signal $emit$.
						\medbreak
							
						\textbf{Exemple :} Si on prend $s~Init$ la version convertie de $Signal~s~in~t$ on a : 
						\\$\langle s~S,E,Init~C,D,SI\rangle \longrightarrow \langle S,E,C,D,SI~\langle s,false\rangle \rangle$ 
						\medbreak
							
						\item $Init$ : l'identifiant du signal sera retourné par la machine, l'utilisateur ne lui donne plus l'identifiant. On créera l'identifiant en incrémentant le dernier identifiant de signal de un. Le reste est identique au fonctionnement du $Init~s$. Cette possibilité aura la même structure pour $SI$ que la précédente à l'exception que l'on va rajouté un ordre car il faudra créer des identifiants donc on va toujours mettre en fin de la liste afin de pouvoir créer facilement un nouvelle identifiant.
						\medbreak
							
						\textbf{Exemple :} Si on prends $Init$ la version convertit de $Signal~s~in~t$ on a : 
						\\$\langle S,E,Init~C,D,\emptyset\rangle \longrightarrow \langle 0~S,E,C,D,SI~\langle 0,false\rangle \rangle$ 
						\\ou
						\\$\langle S,E,Init~C,D,SI~\langle s,emit\rangle\rangle \longrightarrow \langle (s+1)~S,E,C,D,SI~\langle s,emit\rangle~\langle (s+1),false\rangle \rangle$ 
						\medbreak
					\end{enumerate}
					\bigbreak
						
					
				\paragraph{La présence d'un signal}
					
					\subparagraph{Comment savoir si un signal est présent ?}
					\textit{Un signal est présent s'il est émis.}
					\smallbreak
					C'est ici que la notion de temps logique va nous être utile. Via l'initialisation d'un signal on sait que l'on a un booléen pour savoir si un signal est émis donc le cas émis est simple mais si il ne l'est pas ? 
					\smallbreak
					\textit{Un signal est absent si il n'est pas émis durant l'instant logique.}
					\smallbreak
					On a besoin de déterminer la fin d'un instant logique. Les différents threads vont s'éxécuter à la chaîne donc la fin d'un instant sera lorsqu'aucun thread ne s'éxécute. Cependant certains vont tomber dans ce cas ou ils devront attendre l'absence d'un signal. Cette contrainte prise en compte, on redéfinit la fin d'un instant logique comme la fin ou le blocage de tous les threads de la machine.
					\medbreak
						
					Dans notre machine on va devoir différencier les threads en attentes de leurs tour et ceux en attente de l'émission d'un signal. Deux possibilités ont été étudiées :
					\begin{enumerate}
						\item On scinde la file d'attente de threads en deux avec d'un côté les threads en attente de leurs tour et de l'autre ceux en attente de l'émission d'un signal. On aurait $TL =\langle W,ST\rangle$ telle que :
						\begin{itemize}
							\item[] - $W$ une file des threads qui attendent leurs tour telle que $\forall w \in W~:~w = T$ 
							\item[] - $ST$ une liste des threads qui attendent un signal telle que $\forall st \in ST~:~st = \langle s,T\rangle$ avec un signal $s$ 
						\end{itemize}
						\medbreak
							
						Le problème de cette possibilité est la nécéssité de stocker quelle signal attend un thread pour chaque threads de $ST$. La deuxième possibilité résout ce problème.
						\item On ne touche pas $TL$ mais on va stocker les threads bloqués par un signal directement dans les informations de ce signal. Ce qui revient à modifier $SI$ telle que $SI = \langle s , \langle emit , ST \rangle\rangle$ avec un signal $s$, le booléen représentant l'émission $emit$ et une liste de threads $ST$ qui attendent l'émission de $s$.
					\end{enumerate}
					\medbreak
						
					La différenciation des threads faite, on peut tester la présence d'un signal. La commande a eu deux versions :
					\begin{enumerate}
						\item $\langle s,C',C''\rangle$ avec un signal $s$ et deux expressions $C'$ et $C''$ . Si vous avez bien suivi jusque là, vous aurez remarqué que les premières versions ont toujours le même problème récurrent : c'est une structure que l'on veut mettre dans une machine qui traite que des éléments simples et des commandes. Cette forme est donc utilisable mais n'est pas dans la logique de la machine de base.
						\item $s~\langle\langle X,C'\rangle~\langle\langle X,C''\rangle~present$ avec un signal $s$. Cette version parait plus compliquée, je m'en vais donc vous l'expliquez. On a un signal jusque là rien de bien étonnant. Après on a deux abstractions, elles vont nous servir de protection pour nos deux possibilités de notre présence car elle empêche à la machine d'essayer de l'évaluer. On a utilisé cette même astuce pour la commande $Spawn$ plus haut. Pour finir il y a le mot $present$ qui sert de commande pour comprendre que l'on veut faire un test.
					\end{enumerate} 
					\bigbreak
						
						
					\subparagraph{Récapitulatif :} Si on reprends le tout, pour faire notre test de présence nous avons défini :
					\begin{itemize}
						\item[] - la forme de la commande : $s~\langle\langle X,C'\rangle~\langle\langle X,C''\rangle~present$ avec un signal $s$;
						\item[] - la présence d'un signal : \textit{un signal est présent si il est émis dans l'instant courant};
						\item[] - l'absence d'un signal : \textit{un signal est absent si il n'est pas émis durant tout l'instant courant};
						\item[] - la fin de l'instant courant : \textit{l'instant courant est fini quand plus aucun threads ne peut plus effectuer d'instruction};
						\item[] - une structure contenant les threads bloqués : $SI = \langle s , \langle emit , ST \rangle\rangle$ avec un signal $s$, le booléen représentant l'émission $emit$ et une liste de threads  $ST$ qui attendent $s$.
					\end{itemize}
					\bigbreak
					\bigbreak
						
						
						
						
				\paragraph{Émettre un signal}
						
					Cette commande est sûrement la plus simple à mettre en place car tout a été fait en amont via les trois commandes précédentes. La forme de la commande $emit$ n'a pas beaucoup bouger, seulement deux versions existent :
					\begin{enumerate}
						\item $emit_{s}$ Une forme inspirée de $prim_{o^{n}}$. Cependant la grosse erreur est quand mettant un signal $s$ en indice de la commande $emit$ on a l'impression qu'il y a une commande $emit$ par signal $s$ or l'émission est indépendant du signal qu'il émet.
						\item $s~emit$ avec un signal $s$. Celle-ci est privée de toute ambiguïté et s'intègre bien à la machine. 
					\end{enumerate}
					\medbreak
						
					Le faite d'émettre va impliqué deux choses dans notre machine :
					\begin{enumerate}					
						\item Notre booléen représentant l'émission présent dans les informations d'un signal sera mis à vraie
						\item Tous les threads présent dans le tuple du signal seront mis dans la file d'attente $W$ 
					\end{enumerate} 
					\bigbreak
					\bigbreak
				
				
					
					
			\subsubsection{Sémantique de la machine abstraite}
				
				Maintenant que l'on a définit les nouvelles commandes et ce qu'elles ont besoin pour fonctionner il est temps de voir à quoi ressemble notre machine avec ces ajouts. On a gardé la base de la machine SECD en changeant les noms, plus précisément en enlevant les accents circonflexes et en changant le nom de l'environnement par $E$ afin d'allèger l'écriture.
				\bigbreak
					
					
				\textbf{\textit{Soit $\langle T,TL,SI\rangle$ avec :}}
					
				\begin{itemize}
					\item[] $TL =$ \textbf{une file de threads telle que :} $\forall$ $tl \in TL$ $|$ $tl = T$ avec :
					\begin{itemize}
						\item[] $T =$ $\langle S,E,C,D\rangle$ \textbf{le thread courant avec :}
						\begin{itemize}
							\item[] $V = b$	
							\begin{itemize}
								\item[|] $\langle\langle X,C' \rangle E\rangle$
								\item[|] $signal$
							\end{itemize}
							\item[] $S =  \emptyset$ 
							\begin{itemize}
								\item[|] $V$ $S$
							\end{itemize}
							\item[] $E = \{...,\langle X,V\rangle,...\}$
							\item[] $C = \epsilon$								
							\begin{itemize}
								\item[|] $b~C$~~~~~~~~~~~~~~~~~~~~~~~~~~~(une constante)
								\item[|] $X~C$~~~~~~~~~~~~~~~~~~~~~~~~~~(une variable)
								\item[|] $signal~C$~~~~~~~~~~~~~~~~~~~~(un signal)
								\item[|] $\langle X,C'\rangle~C$~~~~~~~~~~~~~~~~~~~(une abstraction)
								\item[|] $ap~C$~~~~~~~~~~~~~~~~~~~~~~~~~(une application)
								\item[|] $prim_{o^{n}}~C$~~~~~~~~~~~~~~~~~~~(un opérateur)
								\item[|] $spawn~C$~~~~~~~~~~~~~~~~~~~~(créateur d'un nouveau thread)
								\item[|] $present~C$~~~~~~~~~~~~~~~~~~~(teste la présence d'un signal)
								\item[|] $init~C$~~~~~~~~~~~~~~~~~~~~~~~~(initialise un signal )
								\item[|] $emit~C$~~~~~~~~~~~~~~~~~~~~~~~(émet un signal)
							\end{itemize}
							\item[] D = $\emptyset$
							\begin{itemize}
								\item[|] $\langle S,E,C,D\rangle$~~~~~~~~~~~~~~~~(une sauvegarde liée à une application)
							\end{itemize}
						\end{itemize}	
					\end{itemize}
					\item[]
					\item[] \textbf{$SI =$ une liste de signaux telle que :} $\forall$ $si \in SI$ $|$ $si =$ $\langle signal,\langle emit,ST\rangle\rangle$ avec :
					\begin{itemize}
						\item[] - \textbf{un booléen représentant l'émission de ce signal :} $emit$
						\item[] - \textbf{la liste des threads bloqués par ce signal :} $ST$ avec $\forall st \in ST~:~st = T$
					\end{itemize}
				\end{itemize}
				\bigbreak
				\bigbreak
					
			
			
			
				\textbf{On va définir une règle pour simplifier les règles futurs :} 
				\begin{center}
						$\dfrac{T \rightarrow T'}{\langle T,TL,SI\rangle \rightarrow \langle T',TL,SI\rangle}$
				\end{center}
				\bigbreak
				\bigbreak
					
					
					
					
				\textbf{\textit{Une suite de fonctions ont été écrites pour simplifier la lecture des règles. Les voici :}}
				\smallbreak
				\begin{itemize}
					\item[] $\iota(SI)$ une fonction qui prend l'identifiant du dernier signal créé, l'incrémente pour en créer un nouveau et retourne l'identifiant du signal créé avec la liste mise à jour.
					\\ \textbf{Exemple :}
					\item[] Si on initialise pour la première fois alors  $\iota(\{\}) =$ $(0 ,\{...,,\langle 0,\langle false,\{\}\rangle\rangle\})$
					\item[] Sinon $\iota(\{...,\langle s,data\rangle\}) =$ $(s+1 ,\{...,\langle s,data\rangle,\langle s+1,\langle false,\{\}\rangle\rangle\})$ avec $data = \langle emit,ST\rangle$
					\item[] 
					
					\item[] $SI(s)$ une fonction qui retourne le 2nd élément du couple $\langle s,data\rangle$ avec $data = \langle emit,ST\rangle$.
					\\\textbf{Exemple :} $SI(s) = \langle emit,ST\rangle$
					\item[]  
					
					\item[] $\tau(SI)$ une fonction qui prend tous les éléments bloqués et les retourne en prenant en compte que le signal n'est pas émis, met à faux toutes les émissions et retourne le couple $\langle TL,SI \rangle$ avec une liste de threads $TL$ et $SI$ la liste des signaux modifiés. 
					\\ \textbf{Exemple :} $\tau(SI) =$ $\forall$ $si \in SI$ : 
					\begin{itemize}
						\item[] - $\langle s,\langle true,\{\}\rangle\rangle~\rightarrow~\langle s,\langle false,\{\}\rangle\rangle$
						\item[] - $\langle s,\langle true,ST\rangle\rangle~\rightarrow~\langle s,\langle false,\{\}\rangle\rangle$ et 
						\\$\forall$ $st \in ST$ : $\langle I,\langle\langle X',C''\rangle, E\rangle$ $\langle\langle X,C'\rangle, E\rangle$ $s$ $S,E,present$ $C,D\rangle$ $\rightarrow$ $ \langle I,S,E,C''$ $C,D\rangle$ et on l'ajoute dans une liste temporaire TL.
					\end{itemize}
				\end{itemize}
				\bigbreak
				\bigbreak
					
					
					
					
				\textbf{\textit{Les éléments composant la machine étant expliqués, voici les nouvelles règles :}}
				\smallbreak
				\begin{enumerate}
					\item[] \textbf{Partie de base de la machine SECD :} Nous avons rajouté des règles mais la machine doit pouvoir traiter les mêmes informations que la machine de base donc on reprend directement les règles de la machine SECD. 
					\item[]
					\begin{itemize}
						\item[] \textbf{Constante :} On a une constante, on la déplace dans la pile.
						\smallbreak
						$\langle S,E,n~C,D\rangle 
						\longrightarrow_{TTS} 
						\langle n~S,E,C,D\rangle$ avec $n$ une constante $b$ ou un signal $s$
						\item[]
							
						\item[] \textbf{Substitution :} On a une variable, on substitue la variable par sa valeur liée dans l'environnement via la fonction $E$.
						\smallbreak
						$\langle S,E,X~C,D\rangle
						\longrightarrow_{TTS} 
						\langle V~S,E,C,D\rangle$ avec $E(X) = V$
						\item[]
							
						\item[] \textbf{Opération :} On a un opérateur dans la chaîne de contrôle et le nombre de constante nécessaire dans la pile, via la fonction $\delta$ on retourne le résultat dans la pile.
						\smallbreak
						$\langle b_{n},...,b_{1}~S,E,prim_{o^{n}}~C,D\rangle
						\longrightarrow_{TTS} 
						\langle V~S,E,C,D\rangle$ avec $\delta(o^{n}~b_{1}...b_{n}) = V$
						\item[]
							
						\item[]  \textbf{Abstraction :} On a une abstraction, on crée une fermeture composée de l'abstraction et de l'environnement courant. On place la fermeture dans la pile.
						\smallbreak
						$\langle S,E,\langle X,C'\rangle$ $C,D\rangle
						\longrightarrow_{TTS} 
						\langle \langle\langle X,C'\rangle,E\rangle$ $S,E,C,D\rangle$
						\item[]
							
						\item[]  \textbf{Application :} On a une application, on sauvegarde dans le dépôt, on remplace la chaîne de contrôle et l'environnement par ceux présent dans la fermeture et on ajoute une substitution dans cet environnement.
						\smallbreak
						$\langle V~\langle\langle X,C'\rangle,E'\rangle~S,E,ap~C,D\rangle
						\longrightarrow_{TTS} 
						\langle \emptyset,E'[X \leftarrow V],C',\langle S,E,C,D\rangle\rangle$
						\item[] 
							
						\item[] \textbf{Récupération de sauvegarde :}  On a rien mais le dépôt comporte une sauvegarde donc on prend celle-ci.
						\smallbreak  
						$\langle V$ $S,E,\epsilon,\langle S',E',C,D\rangle\rangle
						\longrightarrow_{TTS} 
						\langle V$ $S',E',C,D\rangle$
					\end{itemize}
					\item[] \newpage
						
						
						
					\item[] \textbf{Partie pour la concurrence :} Voici les règles rajoutées dans le but de gérer les threads et les signaux. Ce sont les bases de la concurrence de la machine. 
					\item[]
					\begin{itemize}
						\item[]  \textbf{Création thread :} On crée un nouveau thread.
						\smallbreak 
						$\langle\langle\langle\langle X,C'\rangle, E\rangle~S,E,spawn~C,D\rangle,TL,SI\rangle 
						\longrightarrow_{TTS} 
						\langle\langle S,E,C,D\rangle,TL~\langle S,E,C',D\rangle,SI\rangle$
						\item[]
							
						\item[] \textbf{Initialisation signal :} On initialise le signal via la fonction $\iota$.
						\smallbreak 
						$\langle\langle S,E,init~C,D\rangle,TL,SI\rangle 
						\longrightarrow_{TTS}
						\langle\langle s~S,E,C,D\rangle,TL,SI'\rangle$
						avec $\iota(SI) = (s,SI')$
						\item[]	
						
						\item[] \textbf{Présence d'un signal :} On teste la présence d'un signal, via la fonction $SI$ on sait qu'il est émis donc on prends le 1er choix.
						\smallbreak
						$\langle\langle \langle\langle X',C''\rangle,E\rangle~\langle\langle X,C'\rangle,E\rangle~s~S,E,present~C,D\rangle,TL,SI\rangle 
						\longrightarrow_{TTS} 
						\langle\langle S,E,C'~C,D\rangle,TL,SI\rangle$ 
						\\avec $SI(s) = \langle vraie,ST\rangle$
						\item[]
							
							
						\item[] \textbf{ Thread bloqué remplacé :} On teste la présence d'un signal, il n'est pas émis et il y a un thread dans la file d'attente donc on met le thread courant dans la liste de threads bloqués et on prend le thread en tête de la file.
						\smallbreak
						$\langle\langle \langle\langle X',C''\rangle,E\rangle~\langle\langle X,C'\rangle,E\rangle~s~S,E,present~C,D\rangle,\langle S',E',C''',D'\rangle$ $TL,SI\rangle 
						\\\longrightarrow_{TTS} 
						\langle\langle S',E',C''',D'\rangle,TL,SI'\rangle$ 
						\\avec $SI(s) = \langle faux,ST\rangle$
						et $SI'(s) = \langle faux,ST~\langle \langle\langle X',C''\rangle,E\rangle~\langle\langle X,C'\rangle,E\rangle~s~S,E,present~C,D\rangle\rangle$
						\item[]	
							
						\item[] \textbf{Thread bloqué non remplacé :} On teste la présence d'un signal, il n'est pas émis donc on met ce thread dans la liste de threads bloqués.
						\smallbreak 
						$\langle\langle \langle\langle X',C''\rangle,E\rangle~\langle\langle X,C'\rangle,E\rangle~s~S,E,C,D\rangle,\emptyset,SI\rangle 
						\longrightarrow_{TTS} 
						\langle\langle \emptyset,\epsilon,\emptyset,\emptyset\rangle,\emptyset,SI'\rangle$
						\\avec $SI(s) = \langle faux,ST\rangle$
						et $SI'(s) = \langle faux,ST~\langle\langle\langle X',C''\rangle,E\rangle~\langle\langle X,C'\rangle,E\rangle~s~S,E,present~C,D\rangle\rangle$
						\item[]
							
						\item[] \textbf{Récupération dans la file d'attente :} On a plus rien à traiter et on a aucune sauvegarde, du coup on change le thread courant par le thread en tête de la file d'attente.
						\smallbreak
						$\langle\langle S,E,\epsilon,\emptyset\rangle,\langle S',E',C,D\rangle~TL,SI\rangle 
						\longrightarrow_{TTS} 
						\langle\langle S',E',C,D\rangle,TL,SI\rangle$
						\item[]
							
						\item[] \textbf{Fin d'instant logique :} On a plus rien à traiter, on a aucune sauvegarde et on a plus rien dans la file d'attente, c'est la fin d'un instant logique.
						\smallbreak
						$\langle\langle V~S,E,\epsilon,\emptyset \rangle ,\emptyset,SI\rangle 
						\longrightarrow_{TTS} 
						\langle\langle V~S,E,\epsilon,\emptyset\rangle,TL,SI'\rangle$
						\\avec $\tau(SI) = (TL,SI')$ 
						\item[]
							
					\end{itemize}
					\item[] \textbf{Partie commune :} Quand on rajoute des règles le plus gros risque est de créer des conflits avec les anciennes règles. Les conflits viennent de l'application et de la récupération de sauvegarde car $spawn$ et $emit$ ne retournent rien dans la pile donc il faut pouvoir continuer de faire fonctionner la machine avec ces deux cas. 
					\item[]
					\begin{itemize}
						\item[] \textbf{Application neutre :} On a une application sur rien, cela revient juste à rien faire.
						\smallbreak 
						$\langle S,E,ap~C,D\rangle
						\longrightarrow_{TTS} 
						\langle S,E,C,D\rangle$
						\item[]
						
				        \item[] \textbf{Récupération de sauvegarde avec pile vide :}  On a rien mais le dépôt comporte une sauvegarde donc on prends celle-ci.
						\smallbreak  
						$\langle \emptyset,E,\epsilon,\langle S',E',C,D\rangle\rangle
						\longrightarrow_{TTS} 
						\langle S',E',C,D\rangle$
					\end{itemize}
				\end{enumerate}
				\bigbreak
				\bigbreak
					
					
					
					
				\textbf{\textit{la machine peut s'arrêter dans 3 états différents:}}
				\smallbreak
				\begin{itemize}
					\item[] - on a une \textbf{constante} telle que 
					$\langle\langle 0,\emptyset,\emptyset,\textlbrackdbl M\textrbrackdbl_{TTL},\emptyset\rangle,\emptyset,\emptyset,1\rangle 
					\twoheadrightarrow_{TTL} 
					\langle\langle I,b~S,E,\epsilon,\emptyset\rangle,\emptyset,SI,IP\rangle$;
					\item[] 
				    
				    \item[] - on a une \textbf{fonction} telle que
					$\langle\langle 0,\emptyset,\emptyset,\textlbrackdbl M\textrbrackdbl_{TTL},\emptyset\rangle,\emptyset,\emptyset,1\rangle 
					\twoheadrightarrow_{TTL} 
					\langle\langle I,\langle\langle X,C\rangle,E\rangle~S,E,\epsilon,\emptyset\rangle,\emptyset,SI,IP\rangle$;
					\item[] 
			
					\item[] - on a une \textbf{erreur} 
				\end{itemize}
				\bigbreak
				\bigbreak
					
					
					
					
				Cette version des règles est la plus optimale car on a pris le meilleur de chaque possibilités. Cependant il faut savoir que des règles intermédiaires ont été créées, implantées et testées en OCaml. En effet je vais vous présenter 2 version mais 3 versions des règles existent et 4 machines ont été implantées. On peut retrouver ces règles en Annexe si cela vous intéresse. Cela vous permettra de voir tout le chemin parcouru durant le stage.
				\newpage
					
					
		\subsection{Le partage des valeurs dans la machine}
			
			\subsubsection{Description informelle du langage}
				Les signaux nous permettent déjà de communiquer entre les threads par présence ou absence d'un signal. On va monter d'un cran en ajoutant la possibilité de partager des valeurs avec les signaux. Cela va créer un semblant de mémoire partagée.
				\medbreak
				
				\paragraph{Les valeurs partagées}
				
					\subparagraph{Quelles sont les contraintes pour accèder à ces valeurs ?}
					On a déjà spécifier que l'on voulait que les valeurs soit lié à un signal précis. On va rajouter une contrainte supplémentaire ces que chaque thread aura ça propre liste de valeurs partagées. C'est-à-dire que pour accèder à une valeur il faudra connaître le signal et le thread. Cela pose un problème non traité précédement qui est de différencier chaque thread. Pour cela, on va ajouter un identifiant à $T$, c'est-à-dire que l'on aura $T~=~\langle I,S,E,C,D\rangle$ avec $I$ un entier qui va représenter l'identifiant d'un thread $T$. Un autre problème se pose par rapport à l'attribution de ces identifiants.
					\smallbreak
					Je m'explique, dans le cas des signaux ce n'était pas compliqué car on garde tous les signaux créer dans notre machine durant tout le processus donc on ne peut pas attribuer un identifiant qui a déjà été attribué avant. Or ici quand un thread est finit on ne le garde pas et même quand il est en cours, on peut le stocker dans deux endroits différents $TL$ et $ST$. On va utiliser un producteur d'identifiant dans notre machine. On va créer un nouvel élément $IP$ qui est un entier dans notre machine ce qui nous donne pour l'instant $\langle T,TL,SI,IP\rangle$.
					\medbreak
					
					Pour garder la machine réactive fonctionnelle, on va devoir séparer les valeurs partagées en deux parties :
					\begin{enumerate}
						\item Une liste de valeurs courante : c'est là que l'on va insérer les valeurs, on ne peut pas prendre dans cette liste, on peut le voir comme une liste tampon. Cela va permettre d'éviter les problèmes type un thread veut accèder à une valeur, il n'y en a pas, il laisse sa place et le thread d'après mets une valeur. Or ils sont dans le même instant logique donc il devrait pouvoir y accèder car hypothétiquement ils fonctionnent en même temps.
						\item Une liste de valeurs partagées : c'est là que l'on va prendre les valeurs, on ne peut pas insèrer dans cette liste.
					\end{enumerate}
					\smallbreak
					Pour faire la transition entre la liste tampon et la liste de valeurs partagées on attend la fin d'un instant logique et si le signal est émit on transfère ces valeurs.
					\medbreak
					
					Quand on prends une valeur on ne spécifie pas laquelle car on ne le sait pas. On va contraindre à prendre les valeurs dans l'ordre et une unique fois. Pour ça on va avoir un pointeur pour chaque thread. 
					
					\subparagraph{Comment stocker ces valeurs ?} 
					La liste des signaux est pour l'instant de la forme $SI~|~\forall~si \in SI~:~\langle s,\langle emit,ST \rangle\rangle$. On va se contenter d'expliqué pour cette forme car une autre forme à été faite durant le stage mais n'est pas si éloigné de celle-ci. Si vous avez envie de la voir malgré tout elle se trouve en Annexe. Comme vu plus haut il nous faut deux listes : 
					\smallbreak
					\begin{enumerate}
						\item $CS$ les valeurs courantes tels que $\forall~cs \in CS~:~cs = \langle id , CL \rangle$ avec $id$ l'identifiant du thread qui insère ces valeurs dans $CL$ la liste des valeurs;
						\item $SSI$ les valeurs partagées tels que $\forall~ssi \in SSI~:~ssi = \langle id,\langle CI,EL\rangle\rangle$ avec $id$ l'identifiant du thread qui a inséré ces valeurs à l'instant précédent. On a le couple $\langle CI,EL\rangle$ qui va nous servir à itérer. $EL$ est une liste d'identifiant qui représente la fin de l'itération dans cette liste. $CI$ est la liste des valeurs tels que $\forall~ci \in CI~:~ci = \langle b,IL\rangle$ avec $b$ une valeur et $IL$ une liste d'identifiant qui représente une position possible de l'itérateur.
					\end{enumerate}
					\medbreak
					
					$SI~|~\forall~si \in SI~:~\langle s,\langle emit,ST \rangle\rangle$ devient $SI~|~\forall~si \in SI~:~\langle s,\langle emit,CS,SSI,ST \rangle\rangle$
					\bigbreak
					
					
				\paragraph{Accèder à une valeur}
					
					On veut ajouter une commande $get$ qui va nous servir à accèder à une valeur. Pour pouvoir y accèder on a besoin d'un signal et d'un identifiant. On aura donc $s~b~get$ avec $s$ un signal et $b$ un identifiant. Cependant une question se pose, comment faire si on a pris toutes les valeurs ? 
					\smallbreak
					\begin{itemize}
						\item[] - On pourrai lever une erreur : cela est possible si on ajoute une gestion des erreurs mais sur cette version ce n'est pas le cas. Si cela vous intéresse une version existe en Annexe avec ce principe.
						\item[] - On demande un paramètre supplémentaire que l'on nommera $n$ qui nous servira de neutre, c'est-à-dire quand on ne pourra pas récupèrer on retournera le neutre.
					\end{itemize} 
					\smallbreak
					On a donc une commande $get$ de la forme $s~i~n~get$ avec $s$ un signal , $i$ l'identifiant du thread dont l'on veut un élément de ces valeurs partagées et $n$ le neutre. 
					\bigbreak
					
					
				\paragraph{Insérer une valeur}
				
					On a vu comment accèder à des valeurs mais encore faut-il pouvoir les insérer. Pour ça une commande $put$ va être nécessaire. Pour insérer, on a besoin de deux informations : le signal et l'identifiant du thread traitant le $put$. On aura juste besoin de spécifier le signal, l'autre on l'aura directement. Ce qui nous donne $s~put$ avec $s$ un signal. 
					\smallbreak
					Petit point à spécifier, quand on insère un élément c'est que l'on veut le partager. Sachant ça et qu'il faut émettre un signal pour pouvoir partager les valeurs. Donc on peut dire que l'on émet lorsque l'on insère une valeur. On va donc fusionner ces deux commandes. 
					\bigbreak
					\bigbreak
						
				
			
			
			\subsubsection{Sémantique de la machine abstraite}
				
				Ces deux commandes ajoutées engrangent énormément de changement. On va redéfinir nos règles pour voir les changements que ces commandes provoque. 
				\bigbreak
		
				\textbf{\textit{Une suite de fonctions ont été écrite pour simplifier la lecture des règles. Les voici :}}
				\smallbreak
				\begin{itemize}
					\item[] $\iota(SI)$ une fonction qui prends l'identifiant du dernier signal créer l'incrémente pour en créer un nouveau et retourner l'identifiant du signal créée avec la liste mise à jour.
					\\ \textbf{Exemple :} $\iota(\{...,\langle s,\langle emit,CS,SSI\rangle\rangle\}) =$ $(s' ,\{...,\langle s,\langle emit,CS,SSI\rangle\rangle,\langle s',\langle false,\{\},\{\}\rangle\rangle\})$ avec $s' = s+1$
					\item[] 
					\item[] $SI(s)$ une fonction qui retourne le 2nd élément du couple correspondant à s.
					\\\textbf{Exemple :} $SI(s) =$ $\langle emit,CS,SSI,TL\rangle$
					\item[]  
					\item[] $\tau(SI)$ une fonction qui prends tous les éléments bloqués et les retourne en prenant en compte que le signal n'est pas émit, mets les liste de valeurs courantes en liste partagés si il est émit 
					\\ \textbf{Exemple :} $\tau(TL,SI) =$ $\forall$ $si \in SI$ : 
					\begin{itemize}
						\item[] - $\langle true,CS,SSI,\{\}\rangle$ $\rightarrow$ $\langle false,\{\},CS,\{\}\rangle$
						\item[] - $\langle false,CS,SSI,ST\rangle$ $\rightarrow$ $\langle false,\{\},\{\},\{\}\rangle$ et 
						\\$\forall$ $st \in ST$ : $\langle I,\langle\langle X',C''\rangle, E\rangle$ $\langle\langle X,C'\rangle, E\rangle$ $s$ $S,E,present$ $C,D\rangle$ $\rightarrow$ $ \langle I,S,E,C''$ $C,D\rangle$ et on l'ajoute à TL
					\end{itemize}
					\item[]
					\item[] $SI[(s,i) \leftarrow b]$ est une fonction qui mets dans la liste de valeurs ,de s pour le thread i, b et mets à vrai le booléen $emit$.
					\item[] 
					\item[] $SSI(i)$ une fonction qui retourne le couple lié à un signal et un thread dans les signaux partagés.
					\\ \textbf{Exemple :} $SSI(i) = \langle CI,IL\rangle$
					\item[] 
					\item[] $\gamma(\langle CI,IL\rangle)$ une fonction qui retourne la constante et décale l'itérateur 
				\end{itemize}
				\newpage
				
				\textbf{\textit{Soit $\langle T,TL,SI,IP\rangle$ avec :}}
				
				\begin{itemize}
					\item[] $TL =$ \textbf{une file de thread tels que :} $\forall$ $tl \in TL$ $|$ $tl = T$ avec :
					\begin{itemize}
					  \item[] $T =$ $\langle I,S,E,C,D\rangle$ \textbf{le thread courant avec :}
					  \begin{itemize}
					  	\item[] $V = b$	
					  	\begin{itemize}
					  		\item[|] $\langle\langle X,C' \rangle E\rangle$
					  		\item[|] $signal$
					  	\end{itemize}
					  	\item[] $I =$ un entier représentant l'identifiant du thread
					  	\item[] $S =  \emptyset$ 
					  	\begin{itemize}
					  		\item[|] $V$ $S$
					  	\end{itemize}
					  	\item[] $E = \{...,\langle X,V\rangle,...\}$
					  	\item[] $C = \epsilon$
					  	\begin{itemize}
					  		\item[|] $b$ $C$~~~~~~~~~~~~~~~~~~~~~~~~~~    (une constante)
					  		\item[|] $X$ $C$~~~~~~~~~~~~~~~~~~~~~~~~~~(une variable)
					  		\item[|] $signal$ $C$~~~~~~~~~~~~~~~~~~~~(un signal)
					  		\item[|] $\langle X,C'\rangle$ $C$~~~~~~~~~~~~~~~~~~~(une abstraction)
					  		\item[|] $ap$ $C$~~~~~~~~~~~~~~~~~~~~~~~~~(une application)
					  		\item[|] $prim_{o^{n}}$ $C$~~~~~~~~~~~~~~~~~~~(un opérateur)
					  		\item[|] $spawn$ $C$~~~~~~~~~~~~~~~~~~~(créateur d'un nouveau thread)
					  		\item[|] $present$ $C$~~~~~~~~~~~~~~~~~~(le test de présence d'un signal)
					  		\item[|] $init$ $C$~~~~~~~~~~~~~~~~~~~~~~~(initialise un signal)
					  		\item[|] $put$ $C$~~~~~~~~~~~~~~~~~~~~~~~~(insère une valeur dans un signal)
					  		\item[|] $get$ $C$~~~~~~~~~~~~~~~~~~~~~~~~(prends une valeurs dans un signal)
					  	\end{itemize}
					  	\item[] D = $\emptyset$
					  	\begin{itemize}
					  		\item[|] $\langle S,E,C,D\rangle$~~~~~~~~~~~~~~~~(une sauvegarde liée à une abstraction)
					  	\end{itemize}
					  \end{itemize}	
					\end{itemize}
					
					\item[]
					\item[] \textbf{$SI =$ une liste de signaux tels que :} $\forall$ $si \in SI$ $:$ $si =$ $\langle signal,\langle emit,CS,SSI,TL\rangle\rangle$ avec :
					\begin{itemize}
						\item[] - \textbf{un booléen représentant l'émission du signal :} $emit$
						\item[] - \textbf{un identifiant de thread :} $I$
						\item[] - \textbf{une liste des signaux courant tels que :} $\forall$ $cs \in CS$ $:$ $cs = \langle I,CL\rangle$ avec 
						\begin{itemize}
							\item[] - \textbf{une liste de constante tels que :} $\forall$ $cl \in CL$ $:$ $cl = b$
						\end{itemize}
					
						\item[] - \textbf{la liste des signaux partagés tels que :} $\forall$ $ssi \in SSI$ $:$ $ssi = \langle I,\langle CI,EL\rangle\rangle$ avec 
						\begin{itemize}
							\item[] - \textbf{une liste d'identifiant de threads :} $\forall$ $il \in EL$ $:$ $il = I$
							\item[] - \textbf{une liste de constante avec itérateur tels que :} $\forall$ $ci \in CI$ $:$ $ci = \langle b, EL\rangle$
						\end{itemize}
					\end{itemize}
					\item[]
					\item[] IP = un entier servant à attribuer l'identifiant à un nouveau thread 
				\end{itemize}
				\bigbreak
				
				\textbf{On va définir une règle pour simplifier les règles futurs :} 
				\begin{itemize}
					\item[] Dans tous les cas :
					\item[] \begin{center}
								$\dfrac{\langle S,E,C,D\rangle \rightarrow \langle S',E',C',D'\rangle}{\langle\langle I,S,E,C,D\rangle,TL,SI,IP\rangle \rightarrow \langle\langle I,S',E',C',D'\rangle,TL,SI,IP\rangle}$
							\end{center}
					\item[]
					\item[]
					\item[] Si la règle utilisée n'est ni \textbf{Thread bloqué non remplacé} ni \textbf{Création thread} :
					\smallbreak 
					\item[] \begin{center}
								$\dfrac{\langle\langle S,E,C,D\rangle,TL,SI\rangle \rightarrow \langle\langle S',E',C',D'\rangle,TL',SI'\rangle}{\langle\langle I,S,E,C,D\rangle,TL,SI,IP\rangle \rightarrow \langle\langle I,S',E',C',D'\rangle,TL',SI',IP\rangle}$ 
							\end{center}
				\end{itemize}
				\newpage
				
				\textbf{\textit{Les éléments étant expliqués, voici les nouvelles règles de la machine :}}
				\smallbreak
				\begin{enumerate}
					\item[] \textbf{Partie de base de la machine SECD :} On veut garder le fonctionnement de la machine SECD de base donc il faut garder ces règles 
					\item[]
					\begin{itemize}
						\item[] \textbf{Constante :} On a une constante, on la déplace dans la pile.
						\smallbreak
						$\langle S,E,n$ $C,D\rangle 
						\longrightarrow_{secdv5} 
						\langle n$ $S,E,C,D\rangle$ avec $n = b$ ou $signal$
						\item[]
						
						\item[] \textbf{Substitution :} On a une abstraction, on créer une fermeture avec celle-ci et l'environnement courant et on la place dans la pile.
						\smallbreak
						$\langle S,E,X$ $C,D\rangle
						\longrightarrow_{secdv5} 
						\langle V$ $S,E,C,D\rangle$ avec E(X) = V
						\item[]
						
						\item[] \textbf{Opération :} On a un opérateur et le nombre de constante nécessaire dans la pile, \\via la fonction $\delta$ on retourne le résultat dans la pile.
						\smallbreak
						$\langle b_{n},...,b_{1}$ $S,E,prim_{o^{n}}$ $C,D\rangle
						\longrightarrow_{secdv5} 
						\langle V$ $S,E,C,D\rangle$ avec $\delta(o^{n}$ $b_{1}...b_{n}) = V$
						\item[]
						
						\item[]  \textbf{Abstraction :} On a une abstraction, on créer une fermeture comportant l'abstraction et l'environnement courant et on mets la fermeture dans la pile.
						\smallbreak
						$\langle S,E,\langle X,C'\rangle$ $C,D\rangle
						\longrightarrow_{secdv5} 
						\langle \langle\langle X,C'\rangle,E\rangle$ $S,E,C,D\rangle$
						\item[]
						
						\item[]  \textbf{Application :} On a une application, donc on sauvegarde dans le dépôt, on ajoute une substitution et on remplace la chaîne de contrôle et l'environnement par ceux présent dans la fermeture.
						\smallbreak
						$\langle V$ $\langle\langle X,C'\rangle,E'\rangle$ $S,E,ap$ $C,D\rangle
						\longrightarrow_{secdv5} 
						\langle \emptyset,E'[X \leftarrow V],C',\langle S,E,C,D\rangle\rangle$
						\item[] 
						
						\item[] \textbf{Récupération de sauvegarde :}  On a rien mais le dépôt comporte une sauvegarde donc on prends celle-ci.
						\smallbreak  
						$\langle V$ $S,E,\epsilon,\langle S',E',C,D\rangle\rangle
						\longrightarrow_{secdv5} 
						\langle V$ $S',E',C,D\rangle$
					\end{itemize}
					\item[]
					
					
					
					\item[] \textbf{Partie pour la concurrence :} Cette partie rajoute la réactivité dans notre machine. 
					\item[]
					\begin{itemize}
						\item[]  \textbf{Création thread :} On veut créer un nouveau thread.
						\smallbreak 
						$\langle\langle I,\langle\langle X,C'\rangle, E\rangle$ $S,E,spawn$ $C,D\rangle,TL,SI,IP\rangle 
						\longrightarrow_{secdv5} 
						\langle\langle I,S,E,C,D\rangle,TL$ $\langle IP,S,E,C',D\rangle,SI,IP+1\rangle$
						\item[]
						
						\item[] \textbf{Ajouter dans un signal :} On ajoute une constante dans une liste de valeurs d'un signal et mets à vraie le booléen $emit$
						\smallbreak
						$\langle\langle I,s$ $b$ $S,E,put$ $C,D\rangle,TL,SI\rangle
						\longrightarrow_{secdv5} 
						\langle\langle I,S,E,C,D\rangle,TL,SI$ $[(s,I) \leftarrow b]\rangle$ 
						\item[]
						
						\item[] à vérifier \textbf{Prendre une valeur partagée (possible) :} On prends dans la liste de valeurs d'un signal partagé lié à un thread et on décale l'itérateur.
						\smallbreak
						$\langle\langle I,s$ $b$ $n$ $\langle\langle X,C'\rangle,E'\rangle$ $S,E,get$ $C,D\rangle,TL,SI\rangle 
						\longrightarrow_{secdv5} 
						\langle\langle I,\emptyset,E'[X \leftarrow V],C',\langle S,E,C,D\rangle\rangle,TL,SI\rangle$
						\\ si pour $SI(s) = \langle emit,CS,SSI\rangle$ on a $SSI(b) = \langle CI,IL\rangle$ avec $I \notin IL$ alors $\gamma(SSI(b)) = V$
						\item[]
						
						\item[] à vérifier \textbf{Prendre une valeur partagée (impossible) :} On prends dans la liste de valeurs d'un signal partagé lié à un identifant une constante mais si on a déjà tout pris on retourne la valeur par défaut
						\smallbreak 
						$\langle\langle I,s$ $b$ $n$ $\langle\langle X,C'\rangle,E'\rangle$ $S,E,get$ $C,D\rangle TL,SI,IP\rangle 
						\longrightarrow_{secdv5} 
						\langle\langle I,\emptyset,E'[X \leftarrow n],C',\langle S,E,C,D\rangle\rangle,TL,SI\rangle$
						\\ si pour $SI(s) = \langle emit,CS,SSI\rangle$ on a $SSI(b) = \langle CI,IL\rangle$ avec $I \in IL$ alors on prends n la valeur par défaut
						\item[]
						
						\item[] \textbf{Initialisation signal :} On initialise le signal via la fonction $\iota$.
						\smallbreak 
						$\langle\langle I,S,E,init$ $C,D\rangle,TL,SI\rangle 
						\longrightarrow_{secdv4}
						\langle\langle I,signal$ $S,E,C,D\rangle,TL,SI'\rangle$
						avec $\iota(SI) = (signal,SI')$
						\item[]	
						
						\item[] \textbf{Présence du signal :} On teste la présence d'un signal, via la fonction $\beta$ on sait qu'il est émit donc on prends le 1er choix.
						\smallbreak
						$\langle\langle I,\langle\langle X',C''\rangle,E\rangle$ $\langle\langle X,C'\rangle,E\rangle$ $s$ $S,E,present$ $C,D\rangle,TL,SI\rangle 
						\longrightarrow_{secdv5} 
						\langle\langle I,S,E,C'$ $C,D\rangle,TL,SI\rangle$ 
						\\avec $SI(s) = \langle vraie,CS,SSI,TL\rangle$
						\item[]
						
						
						\item[] à vérifier\textbf{ Thread bloqué remplacé :} On teste la présence d'un signal, il n'est pas émit et il y a un thread dans la file d'attente
						donc on mets ce thread dans la liste de threads bloqués et on prends le thread en tête de la file.
						\smallbreak
						$\langle\langle I,\langle\langle X',C''\rangle,E\rangle$ $\langle\langle X,C'\rangle,E\rangle$ $s$ $S,E,present$ $C,D\rangle,\langle I',S',E',C''',D'\rangle$ $TL,SI\rangle 
						\\\longrightarrow_{secdv5} 
						\langle\langle I',S',E',C''',D'\rangle,TL,SI'\rangle$ 
						\\avec $SI(s) = \langle faux,CS,SSI,TL'\rangle$
						\\et $SI'(s) = \langle faux,CS,SSI,TL'$ $\langle I,\langle\langle X',C''\rangle,E\rangle$ $\langle\langle X,C'\rangle,E\rangle$ $s$ $S,E,present$ $C,D\rangle\rangle$
						\item[]	
						
						\item[] à vérifier \textbf{Thread bloqué non remplacé :} On teste la présence d'un signal, il n'est pas émit donc on mets ce thread dans la liste de threads bloqués.
						\smallbreak 
						$\langle\langle I,\langle\langle X',C''\rangle,E\rangle$ $\langle\langle X,C'\rangle,E\rangle$ $s$ $S,E,C,D\rangle,\emptyset,SI,IP\rangle 
						\longrightarrow_{secdv5} 
						\langle\langle IP,\emptyset,\epsilon,\emptyset,\emptyset\rangle,\emptyset,SI',IP+1\rangle$
						\\avec $SI(s) = \langle faux,CS,SSI,TL'\rangle$
						\\et $SI'(s) = \langle faux,CS,SSI,TL'$ $\langle I,\langle\langle X',C''\rangle,E\rangle$ $\langle\langle X,C'\rangle,E\rangle$ $s$ $S,E,present$ $C,D\rangle\rangle$
						\item[]
						
						\item[] \textbf{Récupération dans la file d'attente :} On a plus rien à traité et on a aucune sauvegarde, du coup 
						\\on change le thread courant par le thread en tête de la file d'attente.
						\smallbreak
						$\langle\langle I,V$ $S,E,\epsilon,\emptyset\rangle,\langle I',S',E',C,D\rangle$ $TL,SI\rangle 
						\longrightarrow_{secdv5} 
						\langle\langle I',V$ $S',E',C,D\rangle,TL,SI\rangle$
						\item[]
						
						\item[] \textbf{Fin d'instant logique :} On a plus rien à traiter, on a aucune sauvegarde et on a plus rien dans la file d'attente, c'est la fin d'un instant logique.
						\smallbreak
						$\langle\langle I,V$ $S,E,\epsilon,\emptyset \rangle ,\emptyset,SI\rangle 
						\longrightarrow_{secdv5} 
						\langle\langle I,V$ $S,E,\epsilon,\emptyset\rangle,TL,SI'\rangle$
						\\si $\forall~si \in SI : si = \langle emit,CS,SSI,\{\}\rangle$ alors $\tau(SI)$ = ($SI',TL$) 
						\item[]
						
					\end{itemize}
					\item[] \textbf{Partie commune :} Quand on ajoute des règles dans une machine déjà existante, le plus délicat est de ne pas avoir de conflit dans les règles. Pour ça on définit des règles exprès pour faire la liason entre ce qui existait et ce que l'on ajoute. 
					\item[]
					\begin{itemize}
						\item[] \textbf{Application neutre :} On a une application sur rien, cela revient juste à rien faire.
						\smallbreak 
						$\langle S,E,ap$ $C,D\rangle
						\longrightarrow_{secdv5} 
						\langle S,E,C,D\rangle$
						\item[]
						\item[] \textbf{Récupération de sauvegarde avec pile vide :}  On a rien mais le dépôt comporte une sauvegarde donc on prends celle-ci.
						\smallbreak  
						$\langle \emptyset,E,\epsilon,\langle S',E',C,D\rangle\rangle
						\longrightarrow_{secdv5} 
						\langle S',E',C,D\rangle$
					\end{itemize}
					
					\item[]
				\end{enumerate}
				\bigbreak
				\bigbreak
				
				
				\textbf{\textit{la machine SECD version 4 peut s'arrêter dans 3 états différents:}}
				\smallbreak
				\begin{itemize}
					\item[] on a une \textbf{constante b} tels que 
					$\langle\langle 0,\emptyset,\emptyset,\textlbrackdbl M\textrbrackdbl_{secdv5},\emptyset\rangle,\emptyset,\emptyset,1\rangle 
					\twoheadrightarrow_{secdv5} 
					\langle\langle I,b$ $S,E,\epsilon,\emptyset\rangle,\emptyset,SI,IP\rangle$;
					\item[] 
					\item[] on a une \textbf{abstraction function} tels que
					$\langle\langle 0,\emptyset,\emptyset,\textlbrackdbl M\textrbrackdbl_{secdv5},\emptyset\rangle,\emptyset,\emptyset,1\rangle 
					\twoheadrightarrow_{secdv5} 
					\langle\langle I,\langle\langle X,C\rangle,E\rangle$ $S,E,\epsilon,\emptyset\rangle,\emptyset,SI,IP\rangle$;
					\item[] 
					\item[] on a une \textbf{erreur} 
				\end{itemize}
				\newpage
	
	
	
			\subsection{La gestion des erreurs}
	
	\section{Conclusion}
		
		\newpage
		
		
		
	\section{Annexes}
		
		\subsection{Les Exemples des machines étudiées}
		
			\subsubsection{Exemple de fonctionnement de la machine CK}\label{CK}
			
				Voici un exemple de fonctionnement de la machine CK :
		
				\begin{itemize}
					\item[] CK machine : $\langle(((\lambda f.\lambda x.f$ $x)$ $\lambda y.(+$ $y$ $y))$ $\ulcorner 1\urcorner),mt\rangle$
					\item[] > (1) $\langle(M$ $N),\kappa\rangle \longmapsto_{ck} \langle M,\langle arg,N,\kappa\rangle\rangle$
					\item[] CK machine : $\langle((\lambda f.\lambda x.f$ $x)$ $\lambda y.(+$ $y$ $y)),\langle arg,\ulcorner 1\urcorner,mt\rangle\rangle$
					\item[] > (1) $\langle(M$ $N),\kappa\rangle \longmapsto_{ck} \langle M,\langle arg,N,\kappa\rangle\rangle$
					\item[] CK machine : $\langle(\lambda f.\lambda x.f$ $x),\langle arg,(\lambda y.(+$ $y$ $y)),\langle arg,\ulcorner 1\urcorner,mt\rangle\rangle\rangle$	
					\item[] > (3) $\langle V,\langle arg,N,\kappa \rangle \rangle \longmapsto_{ck} \langle N,\langle fun,V,\kappa \rangle \rangle$
					\item[] CK machine : $\langle(\lambda y.(+$ $y$ $y)),\langle fun,(\lambda f.\lambda x.f$ $x),\langle arg,\ulcorner 1\urcorner,mt\rangle\rangle\rangle$	
					\item[] > (2) $\langle V,\langle fun,(\lambda X.M),\kappa \rangle \rangle \longmapsto_{ck} \langle M[X \leftarrow V],\kappa\rangle$
					\item[] CK machine : $\langle(\lambda x.f$ $x)[f\leftarrow(\lambda y.(+$ $y$ $y))],\langle arg,\ulcorner 1\urcorner,mt\rangle\rangle$	
					\item[] CK machine : $\langle(\lambda x.(\lambda y.(+$ $y$ $y))$ $x),\langle arg,\ulcorner 1\urcorner,mt\rangle\rangle$	
					\item[] > (3) $\langle V,\langle arg,N,\kappa \rangle \rangle \longmapsto_{ck} \langle N,\langle fun,V,\kappa \rangle \rangle$
					\item[] CK machine : $\langle\ulcorner 1\urcorner,\langle fun,(\lambda x.(\lambda y.(+$ $y$ $y))$ $x),mt\rangle\rangle$
					\item[] > (2) $\langle V,\langle fun,(\lambda X.M),\kappa \rangle \rangle \longmapsto_{ck} \langle M[X \leftarrow V],\kappa\rangle$		
					\item[] CK machine : $\langle((\lambda y.(+$ $y$ $y))$ $x)[x \leftarrow \ulcorner 1\urcorner ],mt\rangle$
					\item[] CK machine : $\langle((\lambda y.(+$ $y$ $y))$ $\ulcorner 1\urcorner),mt\rangle$
					\item[] > (1) $\langle(M$ $N),\kappa\rangle \longmapsto_{ck} \langle M,\langle arg,N,\kappa\rangle\rangle$
					\item[] CK machine : $\langle(\lambda y.(+$ $y$ $y)),\langle arg,\ulcorner 1\urcorner,mt\rangle\rangle$	
					\item[] > (3) $\langle V,\langle arg,N,\kappa \rangle \rangle \longmapsto_{ck} \langle N,\langle fun,V,\kappa \rangle \rangle$
					\item[] CK machine : $\langle\ulcorner 1\urcorner,\langle fun,(\lambda y.(+$ $y$ $y)),mt\rangle\rangle$	
					\item[] > (2) $\langle V,\langle fun,(\lambda X.M),\kappa \rangle \rangle \longmapsto_{ck} \langle M[X \leftarrow V],\kappa\rangle$	
					\item[] CK machine : $\langle(+$ $y$ $y)[y \leftarrow\ulcorner 1\urcorner],mt\rangle$
					\item[] CK machine : $\langle(+$ $\ulcorner 1\urcorner$ $\ulcorner 1\urcorner),mt\rangle$
					\item[] > (4) $\langle(o^{n}$ $M$ $N...),\kappa\rangle \longmapsto_{ck} \langle M,\langle opd,\langle o^{n}\rangle,\langle N,...\rangle,\kappa\rangle\rangle$
					\item[] CK machine : $\langle\ulcorner 1\urcorner,\langle opd,\langle + \rangle,\langle\ulcorner 1\urcorner\rangle,mt\rangle\rangle$
					\item[] > (6) $\langle V,\langle opd,\langle V',...o^{n}\rangle,\langle N,L,...\rangle,\kappa\rangle\rangle \longmapsto_{ck} \langle N,\langle opd,\langle V,V',...o^{n}\rangle,\langle L,...\rangle,\kappa\rangle\rangle$
					\item[] CK machine : $\langle\ulcorner 1\urcorner,\langle opd,\langle\ulcorner 1\urcorner,+ \rangle,\langle\rangle,mt\rangle\rangle$
					\item[] > (5) $\langle b,\langle opd,\langle b_{i},...b_{1},o^{n}\rangle,\langle\rangle,\kappa\rangle\rangle \longmapsto_{ck} \langle V,\kappa\rangle$ avec $\delta(o^{n},b_{1},...b_{i},b) = V$
					\item[] CK machine : $\langle\ulcorner 2\urcorner,mt\rangle$
				\end{itemize}
				\newpage
				
				
				
			\subsubsection{Exemple de fonctionnement de la machine CEK}\label{CEK}
					
				Voici un exemple de fonctionnement de la machine CEK :
					
				\begin{itemize}
					\item[] CEK machine : $\langle\langle(((\lambda f.\lambda x.f$ $x)$ $\lambda y.(+$ $y$ $y))$ $\ulcorner 1\urcorner)\emptyset\rangle,mt\rangle$
					\item[] > (1) $\langle\langle(M$ $N),\varepsilon\rangle,\overline{\kappa}\rangle \longmapsto_{cek} \langle \langle M,\varepsilon\rangle,\langle arg,\langle N,\varepsilon\rangle,\overline{\kappa}\rangle\rangle$
					\item[] CEK machine : $\langle\langle((\lambda f.\lambda x.f$ $x)$ $\lambda y.(+$ $y$ $y))\emptyset\rangle,\langle arg,\langle\ulcorner 1\urcorner,\emptyset\rangle,mt\rangle\rangle$
					\item[] > (1) $\langle\langle(M$ $N),\varepsilon\rangle,\overline{\kappa}\rangle \longmapsto_{cek} \langle \langle M,\varepsilon\rangle,\langle arg,\langle N,\varepsilon\rangle,\overline{\kappa}\rangle\rangle$
					\item[] CEK machine : $\langle\langle(\lambda f.\lambda x.f$ $x),\emptyset\rangle,\langle arg,\langle(\lambda y.(+$ $y$ $y)),\emptyset\rangle,\langle arg,\langle\ulcorner 1\urcorner,\emptyset\rangle,mt\rangle\rangle\rangle$
					\item[] > (4) $\langle \langle V,\varepsilon\rangle,\langle arg,\langle N,\varepsilon'\rangle,\kappa\rangle\rangle \longmapsto_{cek} \langle \langle N,\varepsilon'\rangle,\langle fun,\langle V,\varepsilon\rangle,\overline{\kappa}\rangle\rangle$ si $V \notin X$
					\item[] CEK machine : $\langle\langle(\lambda y.(+$ $y$ $y)),\emptyset\rangle,\langle fun,\langle(\lambda f.\lambda x.f$ $x),\emptyset\rangle,\langle arg,\langle\ulcorner 1\urcorner,\emptyset\rangle,mt\rangle\rangle\rangle$
					\item[] > (3) $\langle\langle V,\varepsilon\rangle,\langle fun,\langle (\lambda X1.M),\varepsilon'\rangle,\overline{\kappa} \rangle \rangle \longmapsto_{cek} \langle \langle M,\varepsilon'[X1 \leftarrow \langle V,\varepsilon\rangle]\rangle,\overline{\kappa}\rangle$ si $V \notin X$
					\item[] CEK machine : $\langle\langle(\lambda x.f$ $x),\emptyset[f \leftarrow \langle(\lambda y.(+$ $y$ $y)),\emptyset\rangle]\rangle,\langle arg,\langle\ulcorner 1\urcorner,\emptyset\rangle,mt\rangle\rangle$
					\item[] CEK machine : $\langle\langle(\lambda x.f$ $x),\{\langle f,\langle(\lambda y.(+$ $y$ $y)),\emptyset\rangle\rangle\}\rangle,\langle arg,\langle\ulcorner 1\urcorner,\emptyset\rangle,mt\rangle\rangle$
					\item[] > (4) $\langle \langle V,\varepsilon\rangle,\langle arg,\langle N,\varepsilon'\rangle,\kappa\rangle\rangle \longmapsto_{cek} \langle \langle N,\varepsilon'\rangle,\langle fun,\langle V,\varepsilon\rangle,\overline{\kappa}\rangle\rangle$ si $V \notin X$
					\item[] CEK machine : $\langle\langle\ulcorner 1\urcorner,\emptyset\rangle,\langle fun,\langle(\lambda x.f$ $x),\{\langle f,\langle(\lambda y.(+$ $y$ $y)),\emptyset\rangle\rangle\}\rangle,mt\rangle\rangle$
					\item[] > (3) $\langle\langle V,\varepsilon\rangle,\langle fun,\langle (\lambda X1.M),\varepsilon'\rangle,\overline{\kappa} \rangle \rangle \longmapsto_{cek} \langle \langle M,\varepsilon'[X1 \leftarrow \langle V,\varepsilon\rangle]\rangle,\overline{\kappa}\rangle$ si $V \notin X$
					\item[] CEK machine : $\langle\langle(f$ $x),\{\langle f,\langle(\lambda y.(+$ $y$ $y)),\emptyset\rangle\rangle\}[x \leftarrow \langle\ulcorner 1\urcorner,\emptyset\rangle]\rangle,mt\rangle$
					\item[] CEK machine : $\langle\langle(f$ $x),\{\langle f,\langle(\lambda y.(+$ $y$ $y)),\emptyset\rangle\rangle,\langle x,\langle\ulcorner 1\urcorner,\emptyset\rangle\rangle\}\rangle,mt\rangle$
					\item[] > (1) $\langle\langle(M$ $N),\varepsilon\rangle,\overline{\kappa}\rangle \longmapsto_{cek} \langle \langle M,\varepsilon\rangle,\langle arg,\langle N,\varepsilon\rangle,\overline{\kappa}\rangle\rangle$
					\item[] CEK machine : $\langle\langle f,\{\langle f,\langle(\lambda y.(+$ $y$ $y)),\emptyset\rangle\rangle,\langle x,\langle\ulcorner 1\urcorner,\emptyset\rangle\rangle\}\rangle,\langle arg,\langle x,\{\langle f,\langle(\lambda y.(+$ $y$ $y)),\emptyset\rangle\rangle,\langle x,\langle\ulcorner 1\urcorner,\emptyset\rangle\rangle\}\rangle,mt\rangle\rangle$
					\item[] > (2) $\langle\langle X,\varepsilon\rangle,\overline{\kappa}\rangle \longmapsto_{cek} \langle c,\overline{\kappa}\rangle$ avec $\varepsilon(X) = c$
					\item[] CEK machine : $\langle\langle(\lambda y.(+$ $y$ $y)),\emptyset\rangle,\langle arg,\langle x,\{\langle f,\langle(\lambda y.(+$ $y$ $y)),\emptyset\rangle\rangle,\langle x,\langle\ulcorner 1\urcorner,\emptyset\rangle\rangle\}\rangle,mt\rangle\rangle$
					\item[] > (4) $\langle \langle V,\varepsilon\rangle,\langle arg,\langle N,\varepsilon'\rangle,\kappa\rangle\rangle \longmapsto_{cek} \langle \langle N,\varepsilon'\rangle,\langle fun,\langle V,\varepsilon\rangle,\overline{\kappa}\rangle\rangle$ si $V \notin X$
					\item[] CEK machine : $\langle\langle x,\{\langle f,\langle(\lambda y.(+$ $y$ $y)),\emptyset\rangle\rangle,\langle x,\langle\ulcorner 1\urcorner,\emptyset\rangle\rangle\}\rangle,\langle fun,\langle(\lambda y.(+$ $y$ $y)),\emptyset\rangle,mt\rangle\rangle$	
					\item[] > (2) $\langle\langle X,\varepsilon\rangle,\overline{\kappa}\rangle \longmapsto_{cek} \langle c,\overline{\kappa}\rangle$ avec $\varepsilon(X) = c$
					\item[] CEK machine : $\langle \langle\ulcorner 1\urcorner,\emptyset\rangle,\langle fun,\langle(\lambda y.(+$ $y$ $y)),\emptyset\rangle,mt\rangle\rangle$	
					\item[] > (3) $\langle\langle V,\varepsilon\rangle,\langle fun,\langle (\lambda X1.M),\varepsilon'\rangle,\overline{\kappa} \rangle \rangle \longmapsto_{cek} \langle \langle M,\varepsilon'[X1 \leftarrow \langle V,\varepsilon\rangle]\rangle,\overline{\kappa}\rangle$ si $V \notin X$
					\item[] CEK machine : $\langle\langle(+$ $y$ $y),\emptyset[y \leftarrow\langle\ulcorner 1\urcorner,\emptyset\rangle]\rangle ,mt\rangle$
					\item[] CEK machine : $\langle\langle(+$ $y$ $y),\{\langle y,\langle\ulcorner 1\urcorner,\emptyset\rangle\rangle\}\rangle ,mt\rangle$
					\item[] > (5) $\langle\langle(o^{n}$ $M$ $N...),\varepsilon\rangle,\overline{\kappa}\rangle \longmapsto_{cek} \langle \langle M,\varepsilon\rangle,\langle opd,\langle o^{n}\rangle,\langle \langle N,\varepsilon\rangle,...\rangle,\overline{\kappa}\rangle\rangle$
					\item[] CEK machine : $\langle\langle y,\{\langle y,\langle\ulcorner 1\urcorner,\emptyset\rangle\rangle\}\rangle ,\langle opd,\langle+\rangle,\langle\langle y,\{\langle y,\langle\ulcorner 1\urcorner,\emptyset\rangle\rangle\}\rangle\rangle,mt\rangle\rangle$
					\item[] > (2) $\langle\langle X,\varepsilon\rangle,\overline{\kappa}\rangle \longmapsto_{cek} \langle c,\overline{\kappa}\rangle$ avec $\varepsilon(X) = c$
					\item[] CEK machine : $\langle\langle\ulcorner 1\urcorner,\emptyset\rangle,\langle opd,\langle+\rangle,\langle\langle y,\{\langle y,\langle\ulcorner 1\urcorner,\emptyset\rangle\rangle\}\rangle\rangle,mt\rangle\rangle$
					\item[] > (7) $\langle \langle V,\varepsilon\rangle,\langle opd,\langle v',...o^{n}\rangle,\langle  \langle N,\varepsilon'\rangle,c,...\rangle,\overline{\kappa}\rangle\rangle \longmapsto_{cek} \langle \langle N,\varepsilon'\rangle,\langle opd,\langle  \langle V,\varepsilon\rangle,v',...o^{n}\rangle,\langle c,...\rangle,\overline{\kappa}\rangle\rangle$ si $V \notin X$
					\item[] CEK machine : $\langle\langle y,\{\langle y,\langle\ulcorner 1\urcorner,\emptyset\rangle\rangle\}\rangle,\langle opd,\langle\ulcorner 1\urcorner$ $+\rangle,\langle\rangle,mt\rangle\rangle$
					\item[] > (2) $\langle\langle X,\varepsilon\rangle,\overline{\kappa}\rangle \longmapsto_{cek} \langle c,\overline{\kappa}\rangle$ avec $\varepsilon(X) = c$
					\item[] CEK machine : $\langle\langle\ulcorner 1\urcorner,\emptyset\rangle,\langle opd,\langle\ulcorner 1\urcorner$ $+\rangle,\langle\rangle,mt\rangle\rangle$
					\item[] > (6) $\langle  \langle b,\varepsilon\rangle,\langle opd,\langle \langle b_{i},\varepsilon_{i}\rangle,...\langle b_{1},\varepsilon_{1}\rangle ,o^{n}\rangle,\langle\rangle,\overline{\kappa}\rangle\rangle \longmapsto_{cek} \langle \langle V,\emptyset\rangle,\overline{\kappa}\rangle$ avec $\delta(o^{n},b_{1},...b_{i},b) = V$
					\item[] CEK machine : $\langle\langle\ulcorner 2\urcorner,\emptyset\rangle,mt\rangle$
				\end{itemize}
				\newpage
			
			
				
			\subsubsection{Exemple de fonctionnement de la machine SECD}\label{SECD}
				
				Voici un exemple de fonctionnement de la machine SECD :	
					
				\begin{itemize}
					\item[] Conversion : $\textlbrackdbl(((\lambda f.\lambda x.f$ $x)$ $\lambda y.(+$ $y$ $y))$ $\ulcorner 1\urcorner)\textrbrackdbl_{secd}$
					\item[] Conversion : $\textlbrackdbl((\lambda f.\lambda x.f$ $x)$ $\lambda y.(+$ $y$ $y))\textrbrackdbl_{secd}$ $\textlbrackdbl\ulcorner 1\urcorner\textrbrackdbl_{secd}$ $ap$
					\item[] Conversion : $\textlbrackdbl(\lambda f.\lambda x.f$ $x)\textrbrackdbl_{secd}$ $\textlbrackdbl\lambda y.(+$ $y$ $y)\textrbrackdbl_{secd}$ $ap$ $\ulcorner 1\urcorner$ $ap$
					\item[] Conversion : $\langle f,\textlbrackdbl\lambda x.(f$ $x)\textrbrackdbl_{secd}\rangle$ $\langle y,y$ $y$ $prim_{+}\rangle$ $ap$ $\ulcorner 1\urcorner$ $ap$
					\item[] Conversion : $\langle f,\langle x,\textlbrackdbl f$ $x\textrbrackdbl_{secd}\rangle\rangle$ $\langle y,y$ $y$ $prim_{+}\rangle$ $ap$ $\ulcorner 1\urcorner$ $ap$
					\item[] Conversion : $\langle f,\langle x,f$ $x$ $ap\rangle\rangle$ $\langle y,y$ $y$ $prim_{+}\rangle$ $ap$ $\ulcorner 1\urcorner$ $ap$
					\item[] SECD Machine : $\langle\epsilon,\emptyset,\langle f,\langle x,f$ $x$ $ap\rangle\rangle$ $\langle y,y$ $y$ $prim_{+}\rangle$ $ap$ $\ulcorner 1\urcorner$ $ap,\epsilon\rangle$ 
					\item[] > (3) $\langle\widehat{S},\widehat{\varepsilon},\langle X,C'\rangle$ $\widehat{C},\widehat{D}\rangle \longmapsto_{secd} \langle\langle\langle X,C'\rangle,\varepsilon\rangle$ $\widehat{S},\widehat{\varepsilon},\widehat{C},\widehat{D}\rangle$
					\item[] SECD Machine : $\langle\langle\langle f,\langle x,f$ $x$ $ap\rangle\rangle,\emptyset\rangle,\emptyset,\langle y,y$ $y$ $prim_{+}\rangle$ $ap$ $\ulcorner 1\urcorner$ $ap,\epsilon\rangle$ 
					\item[] > (3) $\langle\widehat{S},\widehat{\varepsilon},\langle X,C'\rangle$ $\widehat{C},\widehat{D}\rangle \longmapsto_{secd} \langle\langle\langle X,C'\rangle,\varepsilon\rangle$ $\widehat{S},\widehat{\varepsilon},\widehat{C}\widehat{,D}\rangle$
					\item[] SECD Machine : $\langle\langle\langle y,y$ $y$ $prim_{+}\rangle,\emptyset\rangle$ $\langle\langle f,\langle x,f$ $x$ $ap\rangle\rangle,\emptyset\rangle,\emptyset,ap$ $\ulcorner 1\urcorner$ $ap,\epsilon\rangle$
					\item[] > (4) $\langle\widehat{V}$ $\langle\langle X,C'\rangle,\varepsilon'\rangle$ $\widehat{S},\widehat{\varepsilon},ap$ $\widehat{C},\widehat{D}\rangle \longmapsto_{secd} \langle\epsilon,\varepsilon'[X \leftarrow \widehat{V}],C',\langle\widehat{S},\widehat{\varepsilon},\widehat{C},\widehat{D}\rangle\rangle$
					\item[] SECD Machine : $\langle\epsilon,\emptyset[f \leftarrow \langle\langle y,y$ $y$ $prim_{+}\rangle,\emptyset\rangle],\langle x,f$ $x$ $ap\rangle,\langle\epsilon,\emptyset,\ulcorner 1\urcorner$ $ap,\epsilon\rangle\rangle$
					\item[] SECD Machine : $\langle\epsilon,\{\langle f,\langle\langle y,y$ $y$ $prim_{+}\rangle,\emptyset\rangle\rangle\},\langle x,f$ $x$ $ap\rangle,\langle\epsilon,\emptyset,\ulcorner 1\urcorner$ $ap,\epsilon\rangle\rangle$
					\item[] >  (3) $\langle\widehat{S},\widehat{\varepsilon},\langle X,C'\rangle$ $\widehat{C},\widehat{D}\rangle \longmapsto_{secd} \langle\langle\langle X,C'\rangle,\varepsilon\rangle$ $\widehat{S},\widehat{\varepsilon},\widehat{C},\widehat{D}\rangle$
					\item[] SECD Machine : $\langle\langle\langle x,f$ $x$ $ap\rangle,\{\langle f,\langle\langle y,y$ $y$ $prim_{+}\rangle,\emptyset\rangle\rangle\}\rangle,\{f,\langle\langle y,y$ $y$ $prim_{+}\rangle,\emptyset\rangle\},\emptyset,\langle\epsilon,\emptyset,\ulcorner 1\urcorner$ $ap,\epsilon\rangle\rangle$
					\item[] > (5) $\langle\widehat{V}$ $\widehat{S},\widehat{\varepsilon},\emptyset,\langle\widehat{S'},\widehat{\varepsilon'},\widehat{C'},\widehat{D}\rangle\rangle \longmapsto_{secd} \langle \widehat{V}$ $\widehat{S'},\widehat{\varepsilon'},\widehat{C'},\widehat{D}\rangle$
					\item[] SECD Machine : $\langle\langle\langle x,f$ $x$ $ap\rangle,\{\langle f,\langle\langle y,y$ $y$ $prim_{+}\rangle,\emptyset\rangle\rangle\}\rangle,\emptyset,\ulcorner 1\urcorner$ $ap,\epsilon\rangle$
					\item[] >  (1) $\langle\widehat{S},\widehat{\varepsilon},b$ $\widehat{C},\widehat{D}\rangle \longmapsto_{secd} \langle b$ $\widehat{S},\widehat{\varepsilon},\widehat{C},\widehat{D}\rangle$
					\item[] SECD Machine :  $\langle\ulcorner 1\urcorner$ $\langle\langle x,f$ $x$ $ap\rangle,\{\langle f,\langle\langle y,y$ $y$ $prim_{+}\rangle,\emptyset\rangle\rangle\}\rangle,\emptyset,ap,\epsilon\rangle$
					\item[] >  (4) $\langle\widehat{V}$ $\langle\langle X,C'\rangle,\varepsilon'\rangle$ $\widehat{S},\widehat{\varepsilon},ap$ $\widehat{C},\widehat{D}\rangle \longmapsto_{secd} \langle\epsilon,\varepsilon'[X \leftarrow \widehat{V}],C',\langle\widehat{S},\widehat{\varepsilon},\widehat{C},\widehat{D}\rangle\rangle$
					\item[] SECD Machine : $\langle\epsilon,\{\langle f,\langle\langle y,y$ $y$ $prim_{+}\rangle,\emptyset\rangle\rangle\}[x \leftarrow \ulcorner 1\urcorner],f$ $x$ $ap,\langle\epsilon,\emptyset,\epsilon,\epsilon\rangle\rangle$
					\item[] SECD Machine : $\langle\epsilon,\{\langle f,\langle\langle y,y$ $y$ $prim_{+}\rangle,\emptyset\rangle\rangle,\langle x,\ulcorner 1\urcorner\rangle\},f$ $x$ $ap,\langle\epsilon,\emptyset,\epsilon,\epsilon\rangle\rangle$
					\item[] > (2) $\langle\widehat{S},\widehat{\varepsilon},X$ $\widehat{C},\widehat{D}\rangle \longmapsto_{secd} \langle \widehat{V}$ $\widehat{S},\widehat{\varepsilon},\widehat{C},\widehat{D}\rangle$ où $\widehat{V} = \varepsilon(X)$
					\item[] SECD Machine : $\langle\langle\langle y,y$ $y$ $prim_{+}\rangle,\emptyset\rangle,\{\langle f,\langle\langle y,y$ $y$ $prim_{+}\rangle,\emptyset\rangle\rangle,\langle x,\ulcorner 1\urcorner\rangle\},x$ $ap,\langle\epsilon,\emptyset,\epsilon,\epsilon\rangle\rangle$
					\item[] > (2) $\langle\widehat{S},\widehat{\varepsilon},X$ $\widehat{C},\widehat{D}\rangle \longmapsto_{secd} \langle \widehat{V}$ $\widehat{S},\widehat{\varepsilon},v~
					\widehat{C},\widehat{D}\rangle$ où $\widehat{V} = \varepsilon(X)$
					\item[] SECD Machine : $\langle\ulcorner 1\urcorner$ $\langle\langle y,y$ $y$ $prim_{+}\rangle,\emptyset\rangle,\{\langle f,\langle\langle y,y$ $y$ $prim_{+}\rangle,\emptyset\rangle\rangle,\langle x,\ulcorner 1\urcorner\rangle\},ap,\langle\epsilon,\emptyset,\epsilon,\epsilon\rangle\rangle$
					\item[] > (4) $\langle\widehat{V}$ $\langle\langle X,C'\rangle,\varepsilon'\rangle$ $\widehat{S},\widehat{\varepsilon},ap$ $\widehat{C},\widehat{D}\rangle \longmapsto_{secd} \langle\epsilon,\varepsilon'[X \leftarrow \widehat{V}],C',\langle\widehat{S},\widehat{\varepsilon},\widehat{C},\widehat{D}\rangle\rangle$
					\item[] SECD Machine :	$\langle\epsilon,\emptyset[y \leftarrow \ulcorner 1\urcorner],y$ $y$ $prim_{+},\langle\epsilon,\{\langle f,\langle\langle y,y$ $y$ $prim_{+}\rangle,\emptyset\rangle\rangle,\langle x,\ulcorner 1\urcorner\rangle\} ,\emptyset,\langle\epsilon,\emptyset,\epsilon,\epsilon\rangle\rangle\rangle$
					\item[] SECD Machine : $\langle\epsilon,\{\langle y,\ulcorner 1\urcorner\rangle\},y$ $y$ $prim_{+},\langle\epsilon,\{\langle f,\langle\langle y,y$ $y$ $prim_{+}\rangle,\emptyset\rangle\rangle,\langle x,\ulcorner 1\urcorner\rangle\} ,\emptyset,\langle\epsilon,\emptyset,\epsilon,\epsilon\rangle\rangle\rangle$
					\item[] > (2) $\langle\widehat{S},\widehat{\varepsilon},X$ $\widehat{C},\widehat{D}\rangle \longmapsto_{secd} \langle \widehat{V}$ $\widehat{S},\widehat{\varepsilon},\widehat{C},\widehat{D}\rangle$ où $\widehat{V} = \varepsilon(X)$
					\item[] SECD Machine : $\langle\ulcorner 1\urcorner,\{\langle y,\ulcorner 1\urcorner\rangle\},y$ $prim_{+},\langle\epsilon,\{\langle f,\langle\langle y,y$ $y$ $prim_{+}\rangle,\emptyset\rangle\rangle,\langle x,\ulcorner 1\urcorner\rangle\} ,\emptyset,\langle\epsilon,\emptyset,\epsilon,\epsilon\rangle\rangle\rangle$
					\item[] > (2) $\langle\widehat{S},\widehat{\varepsilon},X$ $\widehat{C},\widehat{D}\rangle \longmapsto_{secd} \langle \widehat{V}$ $\widehat{S},\widehat{\varepsilon},\widehat{C},\widehat{D}\rangle$ où $\widehat{V} = \varepsilon(X)$
					\item[] SECD Machine : $\langle\ulcorner 1\urcorner$ $\ulcorner 1\urcorner,\{\langle y,\ulcorner 1\urcorner\rangle\},prim_{+},\langle\epsilon,\{\langle f,\langle\langle y,y$ $y$ $prim_{+}\rangle,\emptyset\rangle\rangle,\langle x,\ulcorner 1\urcorner\rangle\} ,\emptyset,\langle\epsilon,\emptyset,\epsilon,\epsilon\rangle\rangle\rangle$
					\item[] > (6) $\langle b_{1}$ $...$ $b_{n}\widehat{S},\widehat{\varepsilon},prim_{o^{n}}$ $\widehat{C},\widehat{D}\rangle \longmapsto_{secd} \langle \widehat{V}$ $\widehat{S},\widehat{\varepsilon},\widehat{C},\widehat{D}\rangle$ où $\widehat{V} = \delta(o^{n},b_1,...b_{n})$
					\item[] SECD Machine : $\langle\ulcorner 2\urcorner,\{\langle y,\ulcorner 1\urcorner\rangle\},\emptyset,\langle\epsilon,\{\langle f,\langle\langle y,y$ $y$ $prim_{+}\rangle,\emptyset\rangle\rangle,\langle x,\ulcorner 1\urcorner\rangle\} ,\emptyset,\langle\epsilon,\emptyset,\epsilon,\epsilon\rangle\rangle\rangle$
					\item[] > (5) $\langle\widehat{V}$ $\widehat{S},\widehat{\varepsilon},\emptyset,\langle\widehat{S'},\widehat{\varepsilon'},\widehat{C'},\widehat{D}\rangle\rangle \longmapsto_{secd} \langle \widehat{V}$ $\widehat{S'},\widehat{\varepsilon'},\widehat{C'},\widehat{D}\rangle$
					\item[] SECD Machine : $\langle\ulcorner 2\urcorner,\{\langle f,\langle\langle y,y$ $y$ $prim_{+}\rangle,\emptyset\rangle\rangle,\langle x,\ulcorner 1\urcorner\rangle\} ,\emptyset,\langle\epsilon,\emptyset,\epsilon,\epsilon\rangle\rangle$
					\item[] > (5) $\langle\widehat{V}$ $\widehat{S},\widehat{\varepsilon},\emptyset,\langle\widehat{S'},\widehat{\varepsilon'},\widehat{C'},\widehat{D}\rangle\rangle \longmapsto_{secd} \langle \widehat{V}$ $\widehat{S'},\widehat{\varepsilon'},\widehat{C'},\widehat{D}\rangle$
					\item[] SECD Machine : $\langle\ulcorner 2\urcorner,\emptyset,\epsilon,\epsilon\rangle$
				\end{itemize}
				\newpage
		
		
			
		\subsection{Les différentes versions faite pour rendre la machine SECD concurrente}
		
			Cette partie énumére les différentes versions créées depuis le début du stage jusqu'à ce jour. Elle paraissent compliqué à comprendre à cause de leurs format qui est bien trop lourd mais elle garde le même principe que celle exprimé plus haut dans le rapport. Il ne faut donc pas avoir peur de chercher à comprendre.
		
			\subsubsection{1ère-2ème version des règles de la machine SECD Concurrente}\label{SECDConc1-2}
				\smallbreak
				Cette version ajoute les prémisse de la concurrence dans la machine SECD avec la possibilité de créér des threads d'initialiser des signaux,les émettre où encore de tester la présence d'un signal. Cette version est un condensé de 2 versions.
				\bigbreak
					
				\textbf{\textit{Soit}} $\langle S,E,C,D,W,ST,SI\rangle$ \textbf{\textit{avec :}}
					
					
				\begin{itemize}
					\item[] $V~=~b$
					\begin{itemize}
						\item[|] $\langle\langle X,C\rangle,E\rangle$
					\end{itemize}
					\item[] $S~=~\epsilon$ 
					\begin{itemize}
						\item[|] $V~S$ 
						\item[|] $Remp~S$
					\end{itemize}
					\item[] $E$ = une fonction $\{\langle X,V\rangle,...\}$
					\item[] $C~=~\epsilon$ 
					\begin{itemize}
						\item[|] $b~C$
						\item[|] $X~C$
						\item[|] $ap~C$
						\item[|] $prim_{o^{n}}~C$  
						\item[|] $\langle X,C\rangle~C$
						\item[|] $bspawn~C$ 
						\item[|] $espawn~C$
						\item[|] $\langle s,C',C''\rangle~C$
						\item[|] $\langle s,C'\rangle~C$ 
						\item[|] $emit_{s}~C$ 
					\end{itemize}
					\item[] $D = \epsilon$
					\begin{itemize}
						\item[|] $\langle S,E,C,D\rangle$ 
					\end{itemize}
					\item[] $W = \{D,...\}$
					\item[] $ST = \{...,\langle s,D\rangle,...\}$
					\item[] $SI = \{ s,...\}$
				\end{itemize}
				\bigbreak
				\bigbreak
					
					
				\textbf{\textit{Les nouvelles règles sont les suivantes :}}
				\smallbreak
				\begin{itemize}
					\item[] \textbf{Partie de base de la machine SECD}
					\begin{itemize}
						\item[] \textbf{Constante :} On a une constante, on la déplace dans la pile. 
						\smallbreak
						$\langle S,E,b~C,D,W,ST,SI\rangle 
						\longmapsto_{secdv1c} 
						\langle b~S,E,C,D,W,ST,SI\rangle$
						\item[]
						
						\item[] \textbf{Substitution :} On a une variable, on prends la substitution dans l'environnement et on la mets dans la pile.  
						\smallbreak 
						$\langle S,E,X~C,D,W,ST,SI\rangle 
						\longmapsto_{secdv1-2} 
						\langle V~S,E,C,D,W,ST,SI\rangle$ 
						où $V = E(X)$
						\item[]
						
						\item[] \textbf{Opération :} On a un opérateur et le nombre de constante nécessaire dans la pile, via la fonction $\delta$ et in retourne le résultat dans la pile. 
						\smallbreak
						$\langle b_{1}~...~b_{n}~S,E,prim_{o^{n}}~C,D,W,ST,SI\rangle 
						\longmapsto_{secdv1-2} 
						\langle V~S,E,C,D,W,ST,SI\rangle$ 
						où $V = \delta(o^{n},b_1,...b_{n})$
						\item[]
						
						\item[] \textbf{Abstraction :} On a une abstraction, on crée une fermeture comportant l'abstraction et l'environnement courant et on mets la fermeture dans la pile
						\smallbreak
						$\langle S,E,\langle X,C'\rangle~C,D,W,ST,SI\rangle 
						\longmapsto_{secdv1-2} 
						\langle\langle\langle X,C'\rangle,E\rangle~S,E,C,D,W,ST,SI\rangle$
						\item[]
						
						\item[] \textbf{Application :} On a une application, donc on dauvegarde dans le dépôt, on ajoute une substitution et on remplace la chaîne de contrôle et l'environnement par ceux présent dans la fermeture.
						\smallbreak
						$\langle V~\langle\langle X,C'\rangle,E'\rangle~S,E,ap~C,D,W,ST,SI\rangle 
						\longmapsto_{secdv1-2} 
						\langle\epsilon,E'[X \leftarrow V],C',\langle S,E,C,D\rangle,W,ST,SI\rangle$
						\item[]
						
						\item[] \textbf{Récupération de sauvegarde :} On a rien mais le dépôt comporte une sauvegarde donc on prends celle-ci.
						\smallbreak
						$\langle V~S,E,\epsilon,\langle S,E,C,D\rangle,W,ST,SI\rangle 
						\longmapsto_{secdv1-2} 
						\langle V~S',E,C',D,W,ST,SI\rangle$
						\item[]
						
					\end{itemize}
					\item[] \textbf{Partie pour la concurrence}
					\begin{itemize}
						\item[] \textbf{Création thread :} On veut créer un nouveau thread
						\smallbreak
						$\langle S,E,bspawn~C'~espawn~C,D,W,ST,SI\rangle 
						\longmapsto_{secdv1-2} 
						\langle Remp~S,E,C,D,W~\langle S,E,C',D\rangle,ST,SI\rangle$
						\item[]
						
						
						\item[] \textbf{Initialisation signal :} On initialise le signal 
						\smallbreak 
						$\langle S,E,\langle s, C'\rangle~C,D,W,ST,SI\rangle 
						\longmapsto_{secdv1-2} 
						\langle\epsilon,E~[init \leftarrow s],C',\langle S,E,C,D\rangle,W,ST,SI\rangle$
						\item[] 
						
						\item[] \textbf{Présence d'un signal :} On teste la présence d'un signal et il l'est donc on prends la 1ère option. 
						\smallbreak
						$\langle S,E,\langle s, C',C''\rangle~C,D,W,ST,SI\rangle 
						\longmapsto_{secdv1-2} 
						\langle S,E,C'~C,D,W,ST,SI\rangle$ 
						\\si $s \in SI$ et $s \in E$ 
						\item[]
						
						\item[] \textbf{Thread bloqué remplacé :} On teste la présence d'un signal et il ne l'est pas donc on le remplace par le thread en tête de la file d'attente.
						\smallbreak 
						$\langle S,E,\langle s, C',C''\rangle~C,D,\langle S',E',C''',D'\rangle W,ST,SI\rangle 
						\longmapsto_{secdv1-2} 
						\langle S',E',C''',D',W,ST~\langle S,E,\langle s, C',C''\rangle~C,D\rangle,SI\rangle$ 
						\\si $s \notin SI$ et $S \in E$ 
						\item[]
						
						\item[] \textbf{Thread bloqué non remplacé :} On teste la présence d'un signal et il ne l'est pas et la file est vide mest juste le thread courant dans la liste de threads bloqués.
						\smallbreak
						$\langle S,E,\langle s, C',C''\rangle~C,D,\emptyset,ST,SI\rangle 
						\longmapsto_{secdv1-2} 
						\langle\emptyset,\emptyset,\epsilon,\emptyset,\emptyset,ST~\langle S,E,\langle s, C',C''\rangle~C,D\rangle,SI\rangle$ 
						\\si $s \notin SI$ et $s \in E$ 
						\item[]
						
						\item[] \textbf{\'{E}mettre :} on émet un signal 
						\smallbreak
						$\langle S,E,emit_{s}~C,D,W,ST,SI\rangle 
						\longmapsto_{secdv1-2} 
						\langle S,E,C,D,W',ST',SI\rangle$ 
						\\avec $W' = W~\cup$ tout les éléments de $ST$ qui attendent l'émission de s et
						\\avec $ST' = ST~\setminus$ tout les éléments de $ST$ qui attendent l'émission de s
						\item[]
						
						\item[] \textbf{Récupération dans la file d'attente :} On a plus rien à traiter et on a aucune sauvegarde, du coup on change de thread courant par le thread en tête de la file d'attente.
						\smallbreak $\langle S,E,\epsilon,\emptyset,\langle S',E',C,D\rangle$ $W,ST,SI\rangle 
						\longmapsto_{secdv1-2} 
						\langle S',E',C,D,W,ST,SI\rangle$
						\item[]
						
						\item[] \textbf{Fin d'instant logique :} On a plus rien à traiter et on a plus rien dans la file d'attente. C'est la fin de l'instant logique
						\smallbreak  $\langle S,E,\epsilon,\emptyset,\emptyset,ST,SI\rangle 
						\longmapsto_{secdv1-2} \langle S,E,\emptyset,\emptyset,W,\emptyset,\emptyset,\emptyset\rangle$ 
						\\avec $W$ = tout les éléments de $ST$ qui prennent leurs 2nd choix 
						\item[]
					\end{itemize}
					\item[] \textbf{Partie commune}
					\begin{itemize}
						\item[] \textbf{Application neutre droite :} on a une application avec un neutre dans la pile donc on l'enlève
						\smallbreak
						$\langle V~Remp~S,E,ap~C,D,W,ST,SI\rangle 
						\longmapsto_{secdv1-2} 
						\langle V~S,E,C,D,W,ST,SI\rangle$
						\item[]
						\item[] \textbf{Application neutre gauche :} on a une application avec un neutre dans la pile donc on l'enlève
						\smallbreak
						$\langle Remp~V~S,E,ap~C,D,W,ST,SI\rangle 
						\longmapsto_{secdv1-2} 
						\langle V~S,E,C,D,W,ST,SI\rangle$
						\item[]
					\end{itemize}
				\end{itemize}
				\bigbreak
				
				
				\textbf{\textit{la machine SECD version 1 peut s'arrêter dans 4 états différents:}}
				\smallbreak
				\begin{itemize}
					\item[]$\longrightarrow$ on a une \textbf{constante b} tels que $\langle \epsilon,\emptyset,\textlbrackdbl M\textrbrackdbl_{secdv1-2},\emptyset,\emptyset,\emptyset,\epsilon\rangle \twoheadrightarrow_{secdv1-2} \langle b,E,\epsilon,\emptyset,\emptyset,SI,\epsilon\rangle$;
					\item[]$\longrightarrow$ on a une \textbf{abstraction function} tels que $\langle \epsilon,\emptyset,\textlbrackdbl M\textrbrackdbl_{secdv1-2},\emptyset,\emptyset,\emptyset,\epsilon\rangle \twoheadrightarrow_{secdv1-2} \langle\langle\langle X,C\rangle,E'\rangle,E,\epsilon,\emptyset,\emptyset,SI,\epsilon\rangle$;
					\item[]$\longrightarrow$ on a un \textbf{remplacement} tels que $\langle \epsilon,\emptyset,\textlbrackdbl M\textrbrackdbl_{secdv1-2},\emptyset,\emptyset,\emptyset,\epsilon\rangle \twoheadrightarrow_{secdv1-2} \langle Remp,E,\epsilon,\emptyset,\emptyset,SI,\epsilon\rangle$;
					\item[]$\longrightarrow$ on a un \textbf{état inconnu} soit une \textbf{erreur}.
				\end{itemize}
				\newpage
				
				
			\subsubsection{3ème version des règles de la machine SECD Concurrente}\label{SECDConc3}
				\smallbreak
				Cette version ajoute le contrôle des erreurs sans propagation via l'ajout d'un gestionnaire d'erreur dans la machine. Il commence a y avior beaucoup d'élément dans notre machine donc on va en rassembler. On va définir $TL$ un couple qui regroupe $W$ et $ST$, c'est-à-dire $TL = \langle W,ST\rangle$.
				\bigbreak
					
				\textbf{\textit{Soit}} $\langle S,E,C,D,TL,SI,H\rangle$ \textbf{\textit{avec :}}
			
				\begin{itemize}
					\item[] $V~=~b$
					\begin{itemize}
						\item[|] $\langle\langle X,C\rangle,E\rangle$
						\item[|] $erreur_{e}$
					\end{itemize}
					\item[] $S$ = $\epsilon$ 
					\begin{itemize}
						\item[|] $V~S$ 
						\item[|] $Remp~S$
					\end{itemize}
					\item[] $E$ = une fonction $\{\langle X,V\rangle,...\}$
					\item[] $C~=~\epsilon$ 
					\begin{itemize}
						\item[|] $b~C$
						\item[|] $X~C$
						\item[|] $ap~C$
						\item[|] $prim_{o^{n}}~C$  
						\item[|] $\langle X,C\rangle~C$
						\item[|] $bspawn~C$ 
						\item[|] $espawn~C$
						\item[|] $\langle s,C',C''\rangle~C$
						\item[|] $\langle s,C'\rangle~C$ 
						\item[|] $emit_{s}~C$ 
						\item[|] $throw_{e}~C$
						\item[|] $\langle e,\langle C',\langle X,C''\rangle\rangle\rangle~C$ 
					\end{itemize}
					\item[] $D = \epsilon$
					\begin{itemize}
						\item[|] $\langle S,E,C,D\rangle$ 
					\end{itemize}
					\item[] $TL = \langle W,ST\rangle$ avec 
					\begin{itemize}
						\item[] - $W = \{D,...\}$
						\item[] - $ST = \{...,\langle s,D\rangle,...\}$
					\end{itemize}
					\item[] $SI = \{ s,...\}$
					\item[] $H$ = $\epsilon$ 
					\begin{itemize}
						\item[|] $\langle e,\langle S,E,C,D,TL,SI,H\rangle\rangle$ 
					\end{itemize}
				\end{itemize}
				\bigbreak
				\bigbreak
				
				\textbf{\textit{Les nouvelles règles sont les suivantes :}}
				\smallbreak
				\begin{itemize}
					\item[] \textbf{Partie de base de la machine SECD}
					\begin{itemize}
						\item[] \textbf{Constante :} On a une constante, on la déplace dans la pile.
						\smallbreak
						$\langle S,E,b~C,D,TL,SI,H\rangle \longmapsto_{secdv3} \langle b~S,E,C,TL,SI,H\rangle$
						\item[]
						
						\item[] \textbf{Substitution :} On a une abstraction, on créer une fermeture avec celle-ci et l'environnement courant et on la place dans la pile.
						\smallbreak
						$\langle S,E,X~C,D,TL,SI,H\rangle \longmapsto_{secdv3} \langle V~S,E,C,D,TL,SI,H\rangle$
						\\où $V = E(X)$
						\item[]
						
						\item[] \textbf{Opération :} On a un opérateur et le nombre de constante nécessaire dans la pile, \\via la fonction $\delta$ on retourne le résultat dans la pile.
						\smallbreak
						$\langle b_{1}~...~b_{n}~S,E,prim_{o^{n}}~C,D,TL,SI,H\rangle \longmapsto_{secdv3} \langle V~S,E,C,D,TL,SI,H\rangle$ 
						\\où $V = \delta(o^{n},b_1,...b_{n})$
						\item[]
						
						\item[]  \textbf{Abstraction :} On a une abstraction, on créer une fermeture comportant l'abstraction et l'environnement courant et on mets la fermeture dans la pile.
						\smallbreak 
						$\langle S,E,\langle X,C'\rangle~C,D,TL,SI,H\rangle \longmapsto_{secdv3} \langle\langle\langle X,C'\rangle,E\rangle~S,E,C,D,TL,SI,H\rangle$
						\item[]
						
						\item[]  \textbf{Application :} On a une application, donc on sauvegarde dans le dépôt, on ajoute une substitution et on remplace la chaîne de contrôle et l'environnement par ceux présent dans la fermeture.
						\smallbreak
						$\langle V~\langle\langle X,C'\rangle,E'\rangle~S,E,ap~C,D,TL,SI,H\rangle \longmapsto_{secdv3} \langle\epsilon,E'[X \leftarrow V],C',\langle S,E,C,D\rangle,TL,SI,H\rangle$
						\item[]
						
						\item[] \textbf{Récupération de sauvegarde :}  On a rien mais le dépôt comporte une sauvegarde donc on prends celle-ci.
						\smallbreak 
						$\langle V~S,E,\epsilon,\langle S',E',C,D\rangle,TL,SI,H\rangle \longmapsto_{secdv3} \langle V~S',E',C,D,TL,SI,H\rangle$
						\item[]
					\end{itemize}
					\item[] \textbf{Partie pour les erreurs}
					\begin{itemize}
						\item[] \textbf{Erreur :} On a une erreur, on la déplace en tête de la pile.
						\smallbreak
						$\langle S,E,throw_{e}~C,D,TL,SI,H\rangle \longmapsto_{secdv3} \langle erreur_{e}~S,E,C,D,TL,SI,H\rangle$	
						\item[]
						
						\item[] \textbf{Traitée erreur via gestionnaire d'erreur :} On a plus rien mais on a une erreur levé dans la pile du coup on regarde si le gestionnaire d'erreur gère celle-ci ; oui du coup prend la sauvegarde.
						\smallbreak 
						$\langle S,E,throw_{e}~C,D,TL,SI,\langle e,\langle S',E',\langle X,C''\rangle~C',D',TL',SI',H\rangle\rangle\rangle 
						\\\longmapsto_{secdv3} \langle S',E',\langle X,C''\rangle~throw_{e}~C',D',TL',SI',H\rangle$
						\item[]
						
						\item[]  \textbf{Traitement erreur récursif :} On a plus rien mais on a une erreur levé dans la pile du coup on regarde 
						\\si le gestionnaire d'erreur gère celle-ci mais non du coup on regarde pour le gestionnaire sauvegardé.
						\smallbreak 
						$\langle S,E,throw_{e}~C,D,TL,SI,\langle e',\langle S',E',\langle X,C''\rangle~C',D',TL',SI',H\rangle\rangle\rangle 
						\\\longmapsto_{secdv3} \langle S,E,throw_{e}~C,D,TL,SI,H \rangle$
						\item[]
						
						\item[]  \textbf{Erreur non traitée :} On a plus rien mais on a une erreur levé dans la pile du coup on arrête la machine en vidant tout sauf la pile.
						\smallbreak 
						$\langle S,E,throw_{e}~C,D,TL,SI,\emptyset\rangle \longmapsto_{secdv3} \langle S,E,throw_{e},\emptyset,\emptyset,\emptyset,\emptyset,\emptyset\rangle$  
						\item[]
						
						\item[]  \textbf{Création d'un gestionnaire d'erreur :} On a un try...catch donc on test avec la chaîne de contrôle du try et on sauvegarde catch dans le gestionnaire d'erreur.
						\smallbreak 
						$\langle S,E,\langle e,\langle C',\langle X,C''\rangle\rangle\rangle~C,D,TL,SI,H\rangle \longmapsto_{secdv3} \langle S,E,C'~C,D,TL,SI,\langle e,\langle S,E,\langle X,C''\rangle~C,D,TL,SI,H\rangle\rangle\rangle$
						\item[]
					\end{itemize}
					\item[] \textbf{Partie pour la concurrence}
					\begin{itemize}
						\item[]  \textbf{Création thread :} On veut créer un nouveau thread.
						\smallbreak
						$\langle S,E,bspawn~C'~espawn~C,D,\langle W,ST\rangle,SI,H\rangle \longmapsto_{secdv3} \langle Remp~S,E,C,D,\langle W~\langle S,E,C',D\rangle,ST\rangle,SI,H\rangle$
						\item[]
						
						\item[] \textbf{Initialisation signal :} On initialise le signal.
						\smallbreak
						$\langle S,E,\langle s, C'\rangle~C,D,TL,SI,H\rangle \longmapsto_{secdv3} \langle\epsilon,E~[init \leftarrow s],C',\langle S,E,C,D\rangle,TL,SI,H\rangle$
						\item[]
						
						\item[] \textbf{Présence signal :} On teste la présence d'un signal, on sait qu'il est émit donc on prends le 1er choix.
						\smallbreak
						$\langle S,E,\langle s, C',C''\rangle~C,D,TL,SI,H\rangle \longmapsto_{secdv3} \langle S,E,C'~C,D,TL,SI,H\rangle$ 
						\\si $s \in SI$ et $s \in E$ 
						\item[]
						
						\item[] \textbf{ Thread bloqué remplacé :} On teste la présence d'un signal, on sait qu'il n'est pas émit et il y a un thread dans la file d'attente
						donc on mets ce thread dans la liste de threads bloqués et on prends le thread en tête de la file.
						\smallbreak
						$\langle S,E,\langle s, C',C''\rangle~C,D,\langle\langle S',E',C''',D'\rangle~W,ST\rangle,SI,H\rangle 
						\\\longmapsto_{secdv3} \langle S',E',C''',D',\langle W,ST~\langle s,\langle S,E,\langle s, C',C''\rangle~C,D\rangle\rangle\rangle,SI,H\rangle$ si $s \notin SI$ et $s \in E$ 
						\item[]\newpage
						
						
						
						\item[] \textbf{Thread bloqué non remplacé :} On teste la présence d'un signal, on sait qu'il n'est pas émit donc on mets ce thread dans la liste de threads bloqués.
						\smallbreak 
						$\langle S,E,\langle s, C',C''\rangle~C,D,\langle\emptyset,ST\rangle,SI,H\rangle \longmapsto_{secdv3} \langle\epsilon,\emptyset,\epsilon,\emptyset,\langle\emptyset,ST~\langle s,\langle S,E,\langle s, C',C''\rangle~C,D\rangle\rangle\rangle,SI,H\rangle$
						\\si $s \notin SI$ et $s \in E$ 
						\item[]
						
						\item[] \textbf{Émission :} On émet un signal donc on mets dans la file d'attente tous les threads attendant le signal.
						\smallbreak
						$\langle S,E,emit_{s}~C,D,\langle W,ST\rangle,SI,H\rangle \longmapsto_{secdv3} \langle S,E,C,D,\langle W',ST'\rangle,SI,H\rangle$
						\\ avec $W' = W~\cup$ tout les éléments de $ST$ qui attendent l'émission de s et
						\\ avec $ST' = ST~\setminus$ tout les éléments de $ST$ qui attendent l'émission de s
						\item[]
						
						\item[] \textbf{Récupération dans la file d'attente :} On a plus rien à traité et on a aucune sauvegarde, du coup 
						\\on change le thread courant par le thread en tête de la file d'attente.
						\smallbreak
						$\langle S,E,\epsilon,\emptyset,\langle\langle S',E',C',D'\rangle~W,ST\rangle,SI,H\rangle \longmapsto_{secdv3} \langle S',E',C',D',\langle W,ST\rangle,SI,H\rangle$
						\item[]
						
						\item[] \textbf{Fin d'instant logique :} On a plus rien à traiter, on a aucune sauvegarde et on a plus rien dans la file d'attente, c'est la fin d'un instant logique.
						\smallbreak
						$\langle S,E,\epsilon,\emptyset,\langle\emptyset,ST\rangle,SI,H\rangle \longmapsto_{secdv3} \langle S,E,\epsilon,\emptyset,\langle W,\emptyset\rangle,\emptyset,H\rangle$\\ avec $W$ = tout les éléments de $ST$ qui prennent leurs 2nd choix 
						\item[]
					\end{itemize}	
					\item[] \textbf{Partie commune}
					\begin{itemize}
						\item[] \textbf{Application neutre droite :} On a une application avec un $Remp$ à droite donc on enlève juste le $Remp$.
						\smallbreak
						$\langle V~Remp~S,E,ap~C,D,TL,SI,H\rangle \longmapsto_{secdv3} \langle V~S,E,C,D,TL,SI,H\rangle$
						\item[]
						
						\item[] \textbf{Application neutre gauche :} On a une application avec un $Remp$ à gauche donc on enlève juste le $Remp$.
						\smallbreak
						$\langle Remp~V~S,E,ap~C,D,TL,SI,H\rangle \longmapsto_{secdv3} \langle V~S,E,C,D,TL,SI,H\rangle$
						\item[]
					\end{itemize}
				\end{itemize}
				\bigbreak
				\bigbreak
				
				\textbf{\textit{la machine SECD version 3 peut s'arrêter dans 4 états différents:}}
				\smallbreak
				\begin{itemize}
					\item[]$\longrightarrow$ on a une \textbf{constante b} tels que $\langle \emptyset,\emptyset,\textlbrackdbl M\textrbrackdbl_{secdv3},\emptyset,\langle\emptyset,\emptyset\rangle,\emptyset,\emptyset\rangle \twoheadrightarrow_{secdv3} \langle b,E,\epsilon,\emptyset,\langle\emptyset,\emptyset\rangle,SI,H\rangle$;
					\item[]
					\item[]$\longrightarrow$ on a une \textbf{abstraction function} tels que $\langle \epsilon,\emptyset,\textlbrackdbl M\textrbrackdbl_{secdv3},\emptyset,\langle\emptyset,\emptyset\rangle,\emptyset,\emptyset\rangle \twoheadrightarrow_{secdv3} \langle\langle\langle X,C\rangle,E'\rangle,E,\epsilon,\emptyset,\langle\emptyset,\emptyset\rangle,SI,H\rangle$;
					\item[]
					\item[]$\longrightarrow$ on a un \textbf{remplacement} tels que $\langle \epsilon,\emptyset,\textlbrackdbl M\textrbrackdbl_{secdv3},\emptyset,\langle\emptyset,\emptyset\rangle,\emptyset,\emptyset\rangle \twoheadrightarrow_{secdv3} \langle Remp,E,\epsilon,\emptyset,\langle\emptyset,\emptyset\rangle,SI,H\rangle$;
					\item[]
					\item[]$\longrightarrow$ on a une \textbf{erreur e} tels que $\langle \epsilon,\emptyset,\textlbrackdbl M\textrbrackdbl_{secdv3},\emptyset,\langle\emptyset,\emptyset\rangle,\emptyset,\emptyset\rangle \twoheadrightarrow_{secdv3} \langle erreur_{e},E,\epsilon,\emptyset,\langle\emptyset,\emptyset\rangle,SI,H\rangle$.
				\end{itemize}
				\newpage
				
				
				
			\subsubsection{4ème version des règles de la machine SECD Concurrente}
				La machine ayant beaucoup évoluée depuis le début du travail, je vais redéfinir chaque élément de la machine pour pouvoir mieux comprendre les nouvelles règles.
				\bigbreak
				
				
				\textbf{\textit{Une suite de fonctions ont été écrite pour simplifier la lecture des règles. Les voici :}}
				\smallbreak
				\begin{itemize}
					\item[] $\rho(l,v,s,i) =$ la fonction qui pour une liste des signaux l, une valeur v, un signal s et un identifiant du thread courant donnés, renvoie la liste l' avec v ajouté à la liste des valeurs du signal s pour le thread i.
					\\\textbf{Exemple :} $\rho(\{...,\langle s,\{...,\langle id,valeur\rangle,...\},emit\rangle,...\},v,s,id) = \{...,\langle s,\{...,\langle id,valeur$ $v\rangle,...\},emit\rangle,...\}$
					\item[] 
					\item[] $\gamma(l,s,i,i') =$ la fonction qui pour une liste de valeurs partagées classés par signals et par thread l, un signal s, l'identifiant du thread courant et l'identifiant du thread auquels on veut accédé, renvoie soit un couple la liste avec l'itérateur déplacé et la valeur ou une exception si on ne peut plus donner de nouvelles valeurs 
					\\\textbf{Exemple :}
					\\$\gamma(\{...,\langle s,\{...,\langle id,\{...,\langle b,\{...,id',...\}\rangle,\langle n,\{...\}\rangle,...\},\{...\}\rangle,...\}\rangle,...\},s,id,id') = 
					\\\langle b , \{...,\langle s,\{...,\langle id,\{...,\langle b,\{...\}\rangle,\langle n,\{...,id'\}\rangle,...\},\{...\}\rangle,...\}\rangle,...\} \rangle$
					\medbreak
						
					$\gamma(\{...,\langle s,\{...,\langle id,\{...,\langle b,\{...,id',...\}\rangle\},\{...\}\rangle,...\}\rangle,...\},s,id,id') = 
					\\\langle b , \{...,\langle s,\{...,\langle id,\{...,\langle b,\{...\}\rangle\},\{...,id'\}\rangle,...\}\rangle,...\} \rangle$
					\medbreak
						
					$\gamma(\{...,\langle s,\{...,\langle id,valeurs,\{...,id',...\}\rangle,...\}\rangle,...\},s,id,id') = throw$ $erreur_{e}$
					\item[]
					\item[] $\iota(l,s,i) =$ la fonction qui pour une liste de signaux courant l, un signal s, renvoie une liste des signaux courant avec le signal s initialisé.
					\\\textbf{Exemple :} $\iota(\{...\},s) = \{...,\langle s,\{\},false\rangle\}$
					\item[]
					\item[] $\beta(l,s) =$ la fonction qui pour une liste de signal courant l et un signal s donnés, renvoie le booléen émit.
					\\\textbf{Exemple :}
					\\ $\beta(\{...,\langle s,\{...\},vraie\rangle,...\},s) = vraie$\\
					$\beta(\{...,\langle s,\{...\},faux\rangle,...\},s) = faux$
					\item[] 
					\item[] $\varepsilon(l,s) =$ la fonction qui pour une liste de signaux courant l et un signal s donnés, renvoie la liste avec le booléen représentant l'émission du signal à vraie.
					\\\textbf{Exemple :}
					\\ $\varepsilon(\{...,\langle s,\{...\},faux\rangle,...\},s) = \{...,\langle s,\{...\},vraie\rangle,...\}$
					\item[] 
					\item[] $\alpha(\langle CS,SSI\rangle) =$ la fonction qui pour la liste des signaux courant et la liste des signaux partagées données, renvoie la liste des signaux courant vidées de ses listes de valeurs et le booléen représentant l'émission mis à nulle ainsi que la liste des signaux partagées remplacer par les listes de valeurs de la liste des signaux courants qui sont émit.
					\\\textbf{Exemple :}
					\\ $\alpha(\langle CS,SSI\rangle) =$
					\\ $SSI$ vidé
					\\ $\forall$ $x$ $\in CS$ tels que $\langle s,\{...,\langle id,\{...,b,...\}\rangle,...\},true\rangle$, on ajoute $x$ dans $SSI$
					\\ $\forall$ $x$ $\in CS$ tels que $\langle s,\{...,\langle id,\{...,b,...\}\rangle,...\},emit\rangle$ on le remplace par $\langle s,\{...,\langle id,\{\}\rangle,...\},faux\rangle$  
				\end{itemize}
				\newpage
		
		
					
				\textbf{\textit{Soit $\langle I,S,E,C,D,TL,SI,H,IP\rangle$ avec :}}
					
				\begin{itemize}
					\item[] $V = b$	
					\begin{itemize}
						\item[|] $\langle\langle X,C' \rangle E\rangle$
						\item[|] $erreur_{e}$
					\end{itemize}
					\item[] $I =$ un entier représentant l'identifiant du thread
					\item[] $S =  \emptyset$ 
					\begin{itemize}
						\item[|] $V S$
						\item[|] $signal$ $S$
						\item[|] $throw$ $S$
					\end{itemize}
					\item[] $E = \{...,\langle X,V\rangle,...\}$
					\item[] $C = \epsilon$
					\begin{itemize}
						\item[|] $b$ $C$~~~~~~~~~~~~~~~~~~~~~~~~~~    (une constante)
						\item[|] $X$ $C$~~~~~~~~~~~~~~~~~~~~~~~~~~(une variable)
						\item[|] $signal$ $C$~~~~~~~~~~~~~~~~~~~~(un signal)
						\item[|] $\langle X,C'\rangle$ $C$~~~~~~~~~~~~~~~~~~~(une abstraction)
						\item[|] $ap$ $C$~~~~~~~~~~~~~~~~~~~~~~~~~(une application)
						\item[|] $prim_{o^{n}}$ $C$~~~~~~~~~~~~~~~~~~~(un opérateur)
						\item[|] $bspawn$ $C$~~~~~~~~~~~~~~~~~~~(début d'un nouveau thread)
						\item[|] $espawn$ $C$~~~~~~~~~~~~~~~~~~(fin d'un nouveau thread)
						\item[|] $\langle C',C''\rangle$ $C$~~~~~~~~~~~~~~~~~~(le test de présence d'un signal)
						\item[|] $emit$ $C$~~~~~~~~~~~~~~~~~~~~~~(émet un signal)
						\item[|] $init$ $C$~~~~~~~~~~~~~~~~~~~~~~~(initialise un signal pour une chaîne de contrôle donné)
						\item[|] $put$ $C$~~~~~~~~~~~~~~~~~~~~~~~~(insère une valeur dans la liste de valeurs d'un signal)
						\item[|] $get$ $C$~~~~~~~~~~~~~~~~~~~~~~~~(prends une valeurs dans la liste de valeurs d'un signal)
						\item[|] $erreur_{e}$ $C$~~~~~~~~~~~~~~~~~~(une erreur)
						\item[|] $throw$ $C$~~~~~~~~~~~~~~~~~~~~(lève une erreur)
						\item[|] $\langle C',\langle X,C''\rangle\rangle$ $C$~~~~~~~~~~~(un gestionnaire d'erreur)
					\end{itemize}
					\item[] TL = $\langle W,ST\rangle$
					\begin{itemize}
						\item[] W = $\{...,\langle I,S,E,C,D\rangle,...\}$~~~~~~~~(liste des threads en attente)
						\item[] ST = $\{...,\langle s,\langle I,S,E,C,D\rangle\rangle,...\}$~~(liste des threads en attente d'un signal)
					\end{itemize}
					\item[] SI = $\langle CS,SSI\rangle$
					\begin{itemize}
						\item[] $CS = \{...,\langle s,\{...,\langle id,\{...,b,...\}\rangle,...\},emit\rangle,...\}$~~~~~~~~~~~~~~~~~~~~~~~~~~(liste des signaux courants)
						\begin{itemize}
							\item [] on va découper cette élément pour mieux en comprendre le sens :
							\item[] - $\{...,*,...\}$ Une liste. 
							\item[] - $\langle s,\{...,**,...\},emit\rangle$ \\
							Une liste composée de trinôme comportant le identifiant du signal, une sous-liste et un booléen exprimant l'émission de ce signal.
							\item[] - $\langle id,\{...,b,...\}\rangle$ \\
							Une sous-liste composée d'un trinôme comportant l'identifiant du thread et une liste de valeur.
						\end{itemize}
						\item[]
						\item[] $SSI =  \{...,\langle s,\{...,\langle id,\{...,\langle b,\{...,id',...\}\rangle,...\},\{...,id'',...\}\rangle,...\}\rangle,...\}$~~~~~(liste des signaux partagés)
						\begin{itemize}
							\item[] comme pour CS on va découper cette élément pour pouvoir le comprendre :
							\item[] - $\{...,*,...\}$ Une liste. 
							\item[] - $\langle s,\{...,**,...\}\rangle$\\
							Une liste composée d'un couple comportant un identifiant de signal et d'une sous-liste
							\item[] - $\langle id,\{...,***,...\},\{...,id'',...\}\rangle$\\
							Une sous-liste composée d'un trinôme comportant un identifiant d'un thread, d'un liste et d'une sous-sous-liste d'identifiant de thread représentant la liste des threads ayant fini leurs parcours de la sous-sous-liste.
							\item[] - $\langle b,\{...,id',...\}\rangle$\\
							Une sous-sous-liste composée d'un couple comportant une valeur et une liste d'identifiant de threads qui représente un pointeur
						\end{itemize}
					\end{itemize}
					\item[] D = $\emptyset$
					\begin{itemize}
						\item[|] $\langle S,E,C,D\rangle$~~~~~~~~~(une sauvegarde liée à une abstraction)
					\end{itemize}
					\item[] H = $\emptyset$ 
					\begin{itemize}
						\item[|] $\langle e\langle I,S,E,\langle X,C' \rangle C,D,TL,SI,H,IP\rangle\rangle$
					\end{itemize} 
					\item[] IP = un entier servant à attribuer l'identifiant à un nouveau thread 
				\end{itemize}
					
				\newpage
		
		
					
				\textbf{\textit{Les éléments étant expliqués, voici les nouvelles règles de la machine :}}
				\smallbreak
				\begin{enumerate}
					\item[] \textbf{Partie de base de la machine SECD} 
					\item[]
					\begin{itemize}
						\item[] \textbf{Constante :} On a une constante, on la déplace dans la pile.
						\smallbreak
						$\langle I,S,E,b$ $C,D,TL,SI,H,IP\rangle 
						\longrightarrow_{secdv4} \langle I,b$ $S,E,C,D,TL,SI,H,IP\rangle$
						\item[]
							
						\item[] \textbf{Substitution :} On a une abstraction, on créer une fermeture avec celle-ci et l'environnement courant et on la place dans la pile.
						\smallbreak
						$\langle I,S,E,X$ $C,D,TL,SI,H,IP\rangle
						\longrightarrow_{secdv4} \langle I,V$ $S,E,C,D,TL,SI,H,IP\rangle$\\ avec E(X) = V
						\item[]
							
						\item[] \textbf{Opération :} On a un opérateur et le nombre de constante nécessaire dans la pile, \\via la fonction $\delta$ on retourne le résultat dans la pile.
						\smallbreak
						$\langle I,b_{n},...,b_{1}$ $S,E,prim_{o^{n}}$ $C,D,TL,SI,H,IP\rangle
						\longrightarrow_{secdv4} \langle I,V$ $S,E,C,D,TL,SI,H,IP\rangle$
						\\avec $\delta(o^{n}$ $b_{1}...b_{n}) = V$
						\item[]
							
						\item[]  \textbf{Abstraction :} On a une abstraction, on créer une fermeture comportant l'abstraction et l'environnement courant et on mets la fermeture dans la pile.
						\smallbreak
						$\langle I,S,E,\langle X,C'\rangle$ $C,D,TL,SI,H,IP\rangle
						\longrightarrow_{secdv4} \langle I,\langle\langle X,C'\rangle,E\rangle$ $S,E,C,D,TL,SI,H,IP\rangle$
						\item[]
							
						\item[]  \textbf{Application :} On a une application, donc on sauvegarde dans le dépôt, on ajoute une substitution et on remplace la chaîne de contrôle et l'environnement par ceux présent dans la fermeture.
						\smallbreak
						$\langle I,V$ $\langle\langle X,C'\rangle,E'\rangle$ $S,E,ap$ $C,D,TL,SI,H,IP\rangle
						\longrightarrow_{secdv4} \langle I,\epsilon,E'[X \leftarrow V],C',\langle S,E,C,D\rangle,TL,SI,H,IP\rangle$
						\item[] 
							
						\item[] \textbf{Récupération de sauvegarde :}  On a rien mais le dépôt comporte une sauvegarde donc on prends celle-ci.
						\smallbreak  
						$\langle I,V$ $S,E,\epsilon,\langle S',E',C,D\rangle,TL,SI,H,IP\rangle
						\longrightarrow_{secdv4} \langle I,V$ $S',E',C,D,TL,SI,H,IP\rangle$
					\end{itemize}
					\item[]
					\item[] \textbf{Partie pour les erreurs} 
					\item[]
					\begin{itemize}
						\item[] \textbf{Erreur :} On a une erreur, on la déplace en tête de la pile.
						\smallbreak
						$\langle I,S,E,erreur_{e}$ $C,D,TL,SI,H,IP\rangle
						\longrightarrow_{secdv4} \langle I,erreur_{e}$ $S,E,C,D,TL,SI,H,IP\rangle$
						\item[]
							
						\item[] \textbf{Lever erreur :} On a un throw, on le déplace en tête de la pile.
						\smallbreak
						$\langle I,S,E,throw$ $C,D,TL,SI,H,IP\rangle
						\longrightarrow_{secdv4} \langle I,throw$ $S,E,C,D,TL,SI,H,IP\rangle$
						\item[]
							
						\item[] \textbf{Opération sur erreur :} On a l'opérateur qui traite cette erreur donc on mets le résultat de 
						\\la fonction $\delta$ dans la pile.
						\smallbreak
						$\langle I,throw$ $erreur_{e}$ $S,E,prim_{o^{1_{e}}}$ $C,D,TL,SI,H,IP\rangle
						\longrightarrow_{secdv4} \langle I,V$ $S,E,C,D,TL,SI,H,IP\rangle$
						\\ avec $\delta(o^{1_{e}}$ $erreur_{e}) = V$
						\item[]
							
						\item[] \textbf{Propagation :} On a un un élément excepté l'opérateur qui traite cette erreur donc on propage l'erreur.
						\smallbreak
						$\langle I,throw$ $erreur_{e}$ $S,E,M$ $C,D,TL,SI,H,IP\rangle
						\longrightarrow_{secdv4} \langle I,throw$ $erreur_{e}$ $S,E,C,D,TL,SI,H,IP\rangle$ 
						\\avec $M = $ un élément de $C$ $\backslash$ $prim_{o^{1_{e}}}$
						\item[]
							
						\item[] \textbf{Traitée erreur via gestionnaire d'erreur :} On a plus rien mais on a une erreur levé dans la pile du coup on regarde si le gestionnaire d'erreur gère celle-ci ; oui du coup prend la sauvegarde.
						\smallbreak 
						$\langle I,throw$ $erreur_{e}$ $S,E,\epsilon,D,TL,SI,\langle e,\langle I',S',E',\langle X,C'' \rangle C',D',TL',SI',H,IP'\rangle\rangle,IP\rangle \\\longrightarrow_{secdv4} \langle I',\emptyset,E'[X \leftarrow erreur_{e}],C'',\langle S',E',C',D'\rangle,TL',SI',H,IP'\rangle$
						\item[]
						
						\item[]  \textbf{Erreur non traitée :} On a plus rien mais on a une erreur levé dans la pile du coup on arrête la machine en vidant tout suaf l'erreur
						\smallbreak 
						$\langle I,S,E,throw_{e}~C,D,TL,SI,\emptyset,IP\rangle \longmapsto_{secdv4} \langle I,S,E,throw_{e},\emptyset,\emptyset,\emptyset,\emptyset,\emptyset,IP\rangle$  
						\item[]
						
						\item[]  \textbf{Traitement erreur récursif :} On a plus rien mais on a une erreur levé dans la pile du coup on regarde 
						\\si le gestionnaire d'erreur gère celle-ci mais non du coup on regarde pour le gestionnaire sauvegardé.
						\smallbreak 
						$\langle I,throw$ $erreur_{e}$ $S,E,\epsilon,D,TL,SI,\langle e',\langle I',S',E',\langle X,C'' \rangle C',D',TL',SI',H,IP'\rangle\rangle,IP\rangle \\\longrightarrow_{secdv4}\langle I,throw$ $erreur_{e}$ $S,E,\epsilon,D,TL,SI,H,IP\rangle$
						\item[]  \newpage
						
						
						
						\item[]  \textbf{Création d'un gestionnaire d'erreur :} On a un try...catch donc on test avec la chaîne de contrôle du try et on sauvegarde catch dans le gestionnaire d'erreur.
						\smallbreak 
						$\langle I,erreur_{e}$ $S,E,\langle C',\langle X,C''\rangle\rangle$ $C,D,TL,SI,H,IP\rangle 
						\\\longrightarrow_{secdv4} \langle I,S,E,C'$ $C,D,TL,SI,\langle e,\langle I,erreur_{e}$ $S,E,\langle X,C'' \rangle$ $C,D,TL,SI,H,IP\rangle\rangle,IP\rangle$
					\end{itemize}
					\item[]
					\item[] \textbf{Partie pour la concurrence} 
					\item[]
					\begin{itemize}
						\item[]  \textbf{Création thread :} On veut créer un nouveau thread.
						\smallbreak 
						$\langle I,S,E,bspawn$ $C'$ $espawn$ $C,D,\langle W,ST\rangle,SI,H,IP\rangle 
						\\\longrightarrow_{secdv4} \langle I,S,E,C,D,\langle W$ $\langle IP,S,E,C',D\rangle,ST\rangle,SI,H,IP+1\rangle$
						\item[]
							
	   					\item[]  \textbf{Signal :} On a un signal, on le déplace dans la pile.
						\smallbreak 
						$\langle I,S,E,signal$ $C,D,TL,SI,H,IP\rangle
						\longrightarrow_{secdv4} \langle I,signal$ $S,E,C,D,TL,SI,H,IP\rangle$
						\item[]
							
						\item[] \textbf{Ajouter dans un signal :} On ajoute une constante dans une liste de valeurs d'un signal via la fonction $\rho$
						\smallbreak
						$\langle I,s$ $b$ $S,E,put$ $C,D,TL,\langle CS,SSI\rangle,H,IP\rangle \longrightarrow_{secdv4} \langle I,S,E,C,D,TL,\langle CS',SSI\rangle,H,IP\rangle$ \\
						avec $CS' = \rho(CS,b,s,I)$ et $s$ initialisé
						\item[]
							
						\item[] \textbf{Prendre une valeur partagée (possible) :} On prends dans la liste de valeurs d'un signal partagé lié \\
						à un identifant une constante via la fonction $\gamma$ .
						\smallbreak
						$\langle I,s$ $b$ $\langle\langle X,C'\rangle,E'\rangle$ $S,E,get$ $C,D,TL,\langle CS,SSI\rangle,H,IP\rangle 
						\\\longrightarrow_{secdv4} \langle I,\emptyset,E'[X \leftarrow V],C',\langle S,E,C,D\rangle,TL,\langle CS,SSI'\rangle,H,IP\rangle$\\
						avec $ \gamma(SSI,s,I,b) = \langle V,SSI'\rangle$ si il reste une valeur à prendre et $s$ partagé
						\item[]
							
						\item[] \textbf{Prendre une valeur partagée (impossible) :} On prends dans la liste de valeurs d'un signal partagé lié à un identifant une constante via la fonction $\gamma$ mais on a déjà tout pris donc on lève une erreur.
						\smallbreak 
						$\langle I,s$ $b$ $\langle\langle X,C'\rangle,E'\rangle$ $S,E,get$ $C,D,TL,\langle CS,SSI\rangle,H,IP\rangle 
						\\\longrightarrow_{secdv4} \langle I,throw$ $erreur_{e}$ $S,E,C,D,TL,\langle CS,SSI'\rangle,H,IP\rangle$\\
						avec $ \gamma(SSI,s,I,b) = throw$ $erreur_{e}$ si il reste aucune valeur à prendre et $s$ partagé
						\item[]
							
						\item[] \textbf{Initialisation signal :} On initialise le signal via la fonction $\iota$.
						\smallbreak 
						$\langle I,s$ $S,E,init$ $C,D,TL,\langle CS,SSI\rangle,H,IP\rangle 
						\longrightarrow_{secdv4} \langle I,S,E,C,D,TL,\langle CS',SSI\rangle,H,IP\rangle$\\
						avec $\iota(CS,s) = CS'$
						\item[]	
							
						\item[] \textbf{Présence signal :} On teste la présence d'un signal, via la fonction $\beta$ on sait qu'il est émit donc on prends le 1er choix.
						\smallbreak
						$\langle I,s$ $S,E,\langle C',C''\rangle$ $C,D,TL,\langle CS,SSI\rangle,H,IP\rangle 
						\longrightarrow_{secdv4} \langle I,S,E,C'$ $C,D,TL,\langle CS,SSI\rangle,H,IP\rangle$ \\
						avec $\beta(CS,s) = vraie$
						\item[]
							
							
						\item[] \textbf{ Thread bloqué remplacé :} On teste la présence d'un signal, via la fonction $\beta$ on sait qu'il n'est pas émit et il y a un thread dans la file d'attente
						donc on mets ce thread dans la liste de threads bloqués et on prends le thread en tête de la file.
						\smallbreak
						$\langle I,s$ $S,E,\langle C',C''\rangle$ $C,D,\langle\langle I',S',E',C''',D'\rangle W,ST\rangle,\langle CS,SSI\rangle,H,IP\rangle 
						\\\longrightarrow_{secdv4} \langle I',S',E',C''',D',\langle W,ST\langle s,\langle I,s$ $S,E,\langle C',C''\rangle$ $C,D\rangle\rangle\rangle,\langle CS,SSI\rangle,H,IP\rangle$ \\
						avec $\beta(CS,s) = faux$
						\item[]	
							
						\item[] \textbf{Thread bloqué non remplacé :} On teste la présence d'un signal, via la fonction $\beta$ on sait qu'il n'est pas émit donc on mets ce thread dans la liste de threads bloqués.
						\smallbreak 
						$\langle I,s$ $S,E,\langle C',C''\rangle$ $C,D,\langle \emptyset,ST\rangle,\langle CS,SSI\rangle,H,IP\rangle 
						\\\longrightarrow_{secdv4} \langle IP,\emptyset,\emptyset,\epsilon,\emptyset,\langle W,ST\langle s,\langle I,s$ $S,E,\langle C',C''\rangle$ $C,D\rangle\rangle\rangle,\langle CS,SSI\rangle,H,IP+1\rangle$ \\
						avec $\beta(CS,s) = faux$
						\item[]	
						\newpage
						
						
						
						\item[] \textbf{Émission :} On émet un signal donc on mets dans la file d'attente tous les threads attendant le signal.
						\smallbreak
						$\langle I,s$ $S,E,emit$ $C,D,TL,\langle CS,SSI\rangle,H,IP\rangle 
						\longrightarrow_{secdv4} \langle I,Unit$ $S,E,C,D,TL',\langle CS',SSI\rangle,H,IP\rangle$\\
						avec $\varepsilon(CS,s) = CS'$ et TL' = $\langle W',ST'\rangle$ et TL = $\langle W,ST\rangle$ :
						\begin{itemize}
							\item[] W' = W $\cup$ les éléments de ST qui attendent le signal s 
							\item[] ST' = ST $\setminus$ les éléments de ST qui attendent le signal s 
						\end{itemize}
						\item[]
						
						\item[] \textbf{Récupération dans la file d'attente :} On a plus rien à traité et on a aucune sauvegarde, du coup 
						\\on change le thread courant par le thread en tête de la file d'attente.
						\smallbreak
						$\langle I,V$ $S,E,\epsilon,\emptyset,\langle\langle I',S',E',C,D\rangle W,ST\rangle,SI,H,IP\rangle 
						\longrightarrow_{secdv4} \langle I',V$ $S',E',C,D,\langle W,ST\rangle,SI,H,IP\rangle$
						\item[]
						
						\item[] \textbf{Fin d'instant logique :} On a plus rien à traiter, on a aucune sauvegarde et on a plus rien dans la file d'attente, c'est la fin d'un instant logique.
						\smallbreak
						$\langle I,V$ $S,E,\epsilon,\emptyset,\langle\emptyset,ST\rangle,SI,H,IP\rangle 
						\longrightarrow_{secdv4} \langle I,V$ $S,E,\epsilon,\emptyset,\langle W,\emptyset\rangle,SI',H,IP\rangle$\\
						avec W = ST avec tous ces éléments qui prennent en compte l'absence de l'émission du signal attendu
						\\et  $\alpha(SI)$ = $SI'$ 
					\end{itemize}
					\item[]
					\item[] \textbf{Partie commune} 
					\item[]
					\begin{itemize}
						\item[] \textbf{Application neutre :} On a une application sur rien, cela revient juste à rien faire.
						\smallbreak 
						$\langle I,S,E,ap$ $C,D,TL,SI,H,IP\rangle
						\longrightarrow_{secdv4} \langle I,S,E,C,D,TL,SI,H,IP\rangle$
					\end{itemize}
				\end{enumerate}
				\bigbreak
				\bigbreak
					
			
			
					
				\textbf{\textit{la machine SECD version 4 peut s'arrêter dans 3 états différents:}}
				\smallbreak
				\begin{itemize}
					\item[] on a une \textbf{constante b} tels que $\langle 0,\emptyset,\emptyset,\emptyset,\textlbrackdbl M\textrbrackdbl_{secdv4},\langle\emptyset,\emptyset\rangle,\langle\emptyset,\emptyset\rangle,\emptyset,\emptyset,1\rangle \\
					\twoheadrightarrow_{secdv4} \langle I,b$ $S,E,\epsilon,\emptyset,\langle\emptyset,\emptyset\rangle,SI,H,IP\rangle$;
					\item[] 
					\item[] on a une \textbf{abstraction function} tels que
					$\langle 0,\emptyset,\emptyset,\textlbrackdbl M\textrbrackdbl_{secdv4},\emptyset,\langle\emptyset,\emptyset\rangle,\langle\emptyset,\emptyset\rangle,\emptyset,\emptyset,1\rangle \\
					\twoheadrightarrow_{secdv4} \langle I,\langle\langle X,C\rangle,E'\rangle$ $S,E,\epsilon,\emptyset,\langle\emptyset,\emptyset\rangle,SI,H,IP\rangle$;
					\item[] 
					\item[] on a une \textbf{erreur e} tels que 
					$\langle 0,\emptyset,\emptyset,\textlbrackdbl M\textrbrackdbl_{secdv4},\emptyset,\langle\emptyset,\emptyset\rangle,\langle\emptyset,\emptyset\rangle,\emptyset,\emptyset,1\rangle \\
					\twoheadrightarrow_{secdv4} \langle I,erreur_{e}$ $S,E,\epsilon,\emptyset,\langle\emptyset,\emptyset\rangle,SI,H,IP\rangle$;
				\end{itemize}
				\newpage
			
			
					
	\section{Bibliographie}
		\begin{itemize}
			\item[] [1] \textit{Réactivité des systèmes coopératifs : le cas Réactive ML} de Louis Mandrel et Cédric Pasteur\label{ReactiveML}
			\item[] [2] \textit{The ZINC experiment: an economical implementation of the ML language} de Xavier Leroy\label{ZINC}
			\item[] [3] \textit{Programming Languages And Lambda Calculi} de Mathias Felleisen et Matthew Flatt\label{Calculi}
			\item[] [4] \textit{https://www.irif.fr/~carton/Enseignement/Complexite/MasterInfo/Cours/turing.html}\label{Turing}
			\item[] [5] \textit{https://fr.wikipedia.org/wiki/Automate$\_$fini$\_$déterministe}\label{AFD}
			\item[] [6] \textit{https://fr.wikipedia.org/wiki/Algorithme$\_$déterministe}\label{MFD}
		\end{itemize}
		
		
\end{document}