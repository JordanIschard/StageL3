\documentclass[10pt,a4paper]{report}
\usepackage[utf8]{inputenc}
\usepackage[a4paper,margin=1.5cm]{geometry}
\usepackage[T1]{fontenc}
\usepackage[french]{babel}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{enumitem}
\usepackage{pifont}
\usepackage{hyperref}
\usepackage{textcomp}
\usepackage{ulem}
\usepackage{multicol}
\usepackage{theorem}
\usepackage{xargs}                      % Use more than one optional parameter in a new commands
\usepackage[pdftex,dvipsnames]{xcolor}  % Coloured text etc.

\usepackage[colorinlistoftodos,prependcaption,textsize=tiny]{todonotes}
\newcommandx{\unsure}[2][1=]{\todo[linecolor=red,backgroundcolor=red!25,bordercolor=red,#1]{#2}}
\newcommandx{\change}[2][1=]{\todo[linecolor=blue,backgroundcolor=blue!25,bordercolor=blue,#1]{#2}}
\newcommandx{\info}[2][1=]{\todo[linecolor=OliveGreen,backgroundcolor=OliveGreen!25,bordercolor=OliveGreen,#1]{#2}}
\newcommandx{\improvement}[2][1=]{\todo[linecolor=Plum,backgroundcolor=Plum!25,bordercolor=Plum,#1]{#2}}
\newcommandx{\thiswillnotshow}[2][1=]{\todo[disable,#1]{#2}}
\newtheorem{ex}{Exemple}




\begin{document}
	
	\title{\textbf{Rapport de stage \\ Développement d'un noyau de programmation synchrone}}
	\date{25 Mars 2019}
	\author{Jordan Ischard\\3ème année de licence Informatque \\ Université d'Orléans}
	\maketitle
	
	\tableofcontents
	\newpage
	
	\section*{Présentation du laboratoire d'accueil}
	Le Laboratoire d'Informatique Fondamentale d'Orléans (LIFO) est un laboratoire de l'Université d'Orléans et de l'INSA Centre-Val de Loire. 
	Les recherches menées au LIFO concernent la science informatique et les STIC. Elles vont de l'algorithmique au traitement des langues
	naturelles, de l'apprentissage au parallélisme massif, de la vérification et la certification à la sécurité des systèmes, du Big Data aux
	systèmes embarqués. Le laboratoire est structuré en cinq équipes :
	\begin{enumerate}
		\item[-] Contraintes et Apprentissage (CA)
		\item[-] Graphes, Algorithmes et Modèles de Calcul (GAMoC)
		\item[-] Langages, Modèles et Vérification (LMV)
		\item[-] Pamda
		\item[-] Sécurité des Données et des Systèmes (SDS)
	\end{enumerate}
	\medbreak
	
	Afin d'offrir une autre approche du laboratoire et de promouvoir la coopération entre équipes, les thématiques transversales suivantes ont été définies :
	\begin{enumerate}
		\item[-] Masse de données et calcul haute performance
		\item[-] Modélisation et algorithmique
		\item[-] Sécurité et sûreté
	\end{enumerate}
	\medbreak
	
	J'ai eu l'occasion de travailler avec une partie de l'équipe LMV, dans l'optique d'un stage de 3 mois.
	L'objectif de l'équipe LMV est de contribuer à l'amélioration de la compréhension des problèmes de sûreté et de sécurité des systèmes  informatiques. Des logiques «ordres partiels» aux langages de programmation usuels, les membres de l'équipe travaillent sur ces questions à différents niveaux d'abstraction et selon différents points de vue tout en cherchant à comprendre les relations fondamentales entre ces différentes approches. L'équipe est structurée autour de deux axes : la correction de programmes et la vérification de systèmes.
	\begin{enumerate}
		\item[-] Le premier axe s'intéresse au développement de techniques liées aussi bien à la vérification de propriétés spécifiques qu'à la satisfaction de propriétés fonctionnelles quelconques. Dans les deux cas les propriétés peuvent être assurées par construction ou a posteriori (vérification déductive).
		\item[-] Le second axe repose d'une part sur l'étude de techniques à base de systèmes de réécriture comme par exemple les problèmes d'accessibilité dans les systèmes de réécriture et d'autre part sur l'étude des logiques dites «ordres partiels» et leur utilisation dans le cadre du développement d'outils de vérification efficaces.
	\end{enumerate}
	
	\vfill
	
	\section*{Remerciement}
	Avant tout développement sur mon sujet de stage, j'aimerais remercier mes deux enseignants qui m'ont encadré, pour m'avoir permis de faire ce stage de recherche et de m'avoir aidé tout le long de celui-ci. J'ai beaucoup appris grâce à eux. Je remercie donc Madame Bousdira et Monsieur Dabrowski pour tout.
	
	
	\chapter{Introduction}
	
(À retravailler)
Le stage a pour intitulé \textit{Programmation réactive synchrone, implantation d’une machine virtuelle}. Il se place dans la thématique
\textit{Sémantique des systèmes concurrents}. L’objectif de ce stage est de réaliser l’implantation d’une machine virtuelle (type JVM) destinée
à exécuter un langage réactif synchrone purement fonctionnel encadré par deux maîtres de conférence : Mme Bousdira et Mr Dabrowski.
\smallbreak
Le processus de création d'un langage de programmation passe par le questionnement sur la nécessité de sa création, sur l'utilisation que
l'on va pouvoir en faire, sur l'implantation optimale. Je vais développer ce dernier point, cependant il reste vaste. On va donc se concentrer
sur la méthode d'exécution du langage. Toute la partie sur le langage aura été décidée en amont par mes deux encadrants.
\smallbreak
Le but est, comme dit plus haut, de créer une machine abstraite. Avant même de s'atteler à cette tâche, on va devoir faire une recherche sur ce
qui est déjà existant niveau machines abstraites : leurs fonctionnements, leurs avantages, leurs inconvénients, etc. La totalité des machines étudiées
dans cet article utilisent le $\lambda$-calcul. Étant totalement ignorant sur ce langage, il m'a fallu me mettre à niveau, cela m'a donné la
possibilité de retracer ma compréhension du $\lambda$-calcul afin qu'à la fin de la lecture de la première partie le lecteur puisse comprendre autant
que moi ce langage. La première partie regroupe aussi toutes les recherches préliminaires effectuées dans le but de pouvoir cerner complètement le sujet
du stage et de pouvoir effectuer un travail optimal.
\smallbreak
La deuxième partie traite du travail réalisé pour créer la machine abstraite demandée à partir d'une machine abstraite existante. J'y explique les contraintes créées par l'ajout de la concurrence dans une machine abstraite. Pour chaque commande ajoutée, une explication détaillée des changements apportés dans la machine est écrite. Deux sémantiques de la machine abstraite y sont décrites.
\smallbreak
Pour finir, je résumerai tous ce qui a été fait durant le stage jusqu'au rendu de ce rapport ainsi que les points qui sont à changer, à développer ou encore ce qu'il reste à faire. Un petit mot sera glissé par rapport aux sémantiques intermédiaires créées et leurs implantations en OCaml. Toutes ces implantations sont retrouvables sur mon git : https://github.com/JordanIschard/StageL3.git.
\smallbreak
Je vous souhaite une bonne lecture et n'hésitez pas à lire les articles cités dans la bibliographie si le sujet vous intéresse.
\newpage

	
	
	
	\chapter{Préliminaires}
La réalisation de ce stage a nécessité une montée en compétence sur le traitement formel des langages de programmation. En particulier, l'étude des articles
suivants a été nécessaire au bon déroulement du stage.
\begin{enumerate}
	\item[-] \hyperref[ReactiveML]{[1]} expliquant le fonctionnement du ReactiveML un langage de programmation réactif
	\item[-] \hyperref[ZINC]{[2]} développant toute la réflexion que l'on doit avoir pour créer un langage de programmation
	\item[-] \hyperref[Calculi]{[3]} expliquant le fonctionnement des machines abstraites permettant de réduire les termes du $\lambda $-calcul.
\end{enumerate}
Pour mieux structurer ma démarche, je vais diviser mes recherches en deux sous-parties. La première sera liée à mes recherches "préliminaires" qui ne sont pas liées directement à la programmation réactive. Elle regroupera l'article \hyperref[ZINC]{[2]} et \hyperref[Calculi]{[3]}. La seconde partie sera dédiée à l'article \hyperref[ReactiveML]{[1]} qui est, lui, complètement axée sur la programmation réactive. 
\newpage



	\section{Conception de langages}
	
Créer un langage est un processus complexe, il faut savoir se poser les bonnes questions. Mon but est ici de vous
montrer une partie du processus de réflexion pour comprendre les problèmes que soulève la création d'un langage.
Je vais m'appuyer sur les travaux de Xavier Leroy sur \textit{ZINC}.
\medbreak

\subparagraph{Pourquoi ?} 
La création d'un langage de programmation doit venir d'un besoin de celui-ci, par exemple quand on veut des critères spécifiques.
Pour \textit{ZINC}, la portabilité du langage ML sur micro-ordinateur ainsi que l'utilisation pour la pédagogie ont été soulevés
comme problèmes des implantations déjà existantes. La nécessité de la création d'un nouveau langage devient donc flagrante.
D'ailleurs \textit{ZINC} veut dire ZINC Is Not Caml, il pointe le principal langage qui a tous les problèmes exposés plus haut
pour bien montrer qu'il ne va pas les faire. 

\subparagraph{Comment?}	
Le plus dur reste à faire. Maintenant on doit savoir ce que l'on veut dans notre langage, comment on pourra l'utiliser, quelle
est la meilleure implantation pour une vitesse d'exécution optimale, quelle sera la méthode d'exécution. 
\medbreak

On va aborder quelques points soulevés dans l'article\hyperref[ZINC]{[2]}. Je vous conseille sa lecture si le sujet vous intéresse
car il est bien détaillé et assez accessible pour un novice comme moi.
\begin{itemize}
	\item[] - Veut-on que notre langage soit utilisé pour de petits problèmes ou au contraire pour des problèmes de tous types de tailles.
	Si c'est le cas il faut pouvoir simplifier la vie à notre utilisateur en l'aidant à structurer son programme. Par exemple en Caml
	on a les \textbf{structures}, en java on a les \textbf{classes}, en C on a les \textbf{headers}, etc. Pour \textit{ZINC},
	la création de modules est possible avec un principe proche du C. De plus, le principe de module est le seul qui permet de combiner
	une compilation séparée de chaque module avec un typage fort statique.
	\medbreak
	
	Petit point sur le typage, il peut être soit statique, soit dynamique et dans les deux cas, on peut avoir un typage
	fort ou un typage faible. On va définir tout ça :
	\begin{itemize}
		\item[] - typage \textbf{statique} : on vérifie, avant exécution, tout le code. Exemple : Caml
		\item[] - typage \textbf{dynamique} : on vérifie au fur et à mesure le code au moment où c'est nécessaire. Exemple : Python
		\item[] - typage \textbf{fort} : il faut que tous les types correspondent entre-eux quand on les associe. Exemple : Caml 
		\item[] - typage \textbf{faible} : il peut y avoir des associations entre deux types pas tout à fait pareils. Exemple : C, on peut
		faire une égalité entre un pointeur et un entier il va juste prévenir mais pas interdire. 
	\end{itemize} 
	\item[]
	\item[] - Veut-on des fonctions n-aires ou utiliser la curryfication ? Déjà qu'est-ce que la curryfication ? Son principe est la
	transformation d'une fonction à plusieurs arguments en une fonction à un argument qui retourne une fonction sur le reste des arguments.
	\smallbreak
	\begin{ex}
		Exemple en Caml : La version curryfiée de $let~f = fun(x,y) \rightarrow x+y~in~f(5,7)$
		\smallbreak
		~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~est $let~f = fun~x \rightarrow fun~y \rightarrow x+y~in~f~5~7$ 
	\end{ex}
	\medbreak
	\textit{ZINC} n'a pas de fonctions n-aires. Malgré la facilité et l'efficacité que l'on peut voir dans les fonctions n-aires, un problème
	se pose. Il est dur de prévoir le comportement avec les fonctions de hautes ordres et le polymorphisme. Pour éviter ça on va préférer la
	curryfication malgré son exécution plus lente. Une explication précise de comment palier sa vitesse d'exécution est décrite dans
	l'article\hyperref[ZINC]{[2]} que je vous conseille une nouvelle fois vivement.
	\item[]
	\item[] - Quelle méthode d'exécution veut-on utiliser ? Il y a différentes méthodes d'exécutions :
	\begin{itemize}
		\item[] - \textbf{Code natif :} Cette méthode optimise la vitesse d'exécution mais c'est une approche \textit{"blood, sweat and tears"} car
		c'est pas du tout trivial et spécifique à un processeur;
		\item[] - \textbf{Machine Abstraite :} Cette méthode a une bonne portabilité mais génère un code avec des redondances et n'utilise pas de
		façon optimale la machine même si on peut écrire un optimiseur pour chaque machine;
		\item[] - \textbf{Traduire dans un langage plus haut niveau :} Cette méthode a une bonne portabilité et est accessible simplement cependant
		on est dépendant d'un autre langage et on cache notre langage cible à l'utilisateur
		\item[] - \textbf{Interpréteur de code de la machine abstraite :} Cette méthode est un simulateur ce qui donne une bonne portabilité mais un
		temps d'interprétation non-négligeable
	\end{itemize}
\end{itemize}
	\newpage
	
	
	
	\section{$\lambda$-calcul : sémantique et machines abstraites}
	
	Le $\lambda$-calcul est un système formel inventé par Alonzo Church dans les années 1930, qui fonde les concepts de fonction et
	d'application. Le $\lambda$-calcul est le modèle le plus communément accepté du calcul séquentiel. On y manipule des expressions appelées $\lambda$-expressions, où la lettre grecque $\lambda$ est utilisée pour lier une variable. On va lier une variable à une $\lambda$-expression, le composant créé est nommé \textit{abstraction}. On peut voir une \textit{abstraction} comme une fonction qui a un paramètre. On va revoir ce point dans l'introduction de la syntaxe et de la sémantique.
	\subsection{Le $\lambda$-calculs : syntaxe et sémantique}
	
	\paragraph{Les termes du $\lambda$-calcul :}
	Il y a trois termes qui composent les $\lambda$-expressions :
	\begin{enumerate}
		\item les variables : $\{x, y...\}$ sont des $\lambda$-termes. Ce sont des variables comme on peut trouver partout dans les langages de programmations; 
		\item les abstractions : $\lambda x.(v)$ est un $\lambda$-terme si $x$ est une variable et $v$ un $\lambda$-terme. On peut voir une abstraction comme une fonction comme dit plus haut.
		\begin{ex}
			On prend la fonction toute simple $f$ qui à $y$ associe $y+1$. Si on revient au $\lambda$-calcul : $y$ sera notre variable lié à $\lambda$ (c'est $x$ dans l'abstraction $\lambda x.(v)$) et $y+1$ sera la $\lambda$-expression (c'est $v$ dans l'abstraction $\lambda x.(v)$). Quand on utilise la fonction $f$ on va donner une valeur à $y$ et on remplacera $y$ par cette valeur dans $y+1$. Les $\lambda$-expressions fonctionnent de façon semblable.
		\end{ex}
		\item les applications : $(u~v)$ est un $\lambda$-terme si $u$ et $v$ sont des $\lambda$-termes. L'application a un nom assez explicite, il va appliquer l'élément de droite à celui de gauche, c'est-à-dire qu'il va appliquer $v$ à $u$. Cette application ce fait avec $u$ une abstraction et $v$ une $\lambda$-expression. 
		\begin{ex}
			Si on prend un exemple dans Ocaml, on a la fonction $string\_of\_int$ pour pouvoir l'utiliser on va faire $string\_of\_int~3$. C'est exactement de la forme $(u~v)$.  
		\end{ex}
	\end{enumerate}
	\bigbreak
	
	\subparagraph{Les règles de réduction :}
	Maintenant que nous connaissons les termes qui composent les $\lambda$-expressions, il faut savoir
	comment les faire interagir entre eux. Les $\lambda$-calculs vont seulement transformer les termes, son évaluation est liée à l'application. En effet, on travaille avec des abstractions, des variables et des applications qui représentent respectivement les fonctions , les variables et les utilisations de fonctions. Quand on va donner une variable à une fonction on va l'appliquer ce qui va avoir pour impact de réduire l'expression. On évalue donc les $\lambda$-calculs par une succession de réductions des termes grâce à
	l'application. Il existe trois règles de \textbf{réduction générale :}
	\begin{itemize}
		\item[-] $(\lambda X_{1}.M)~~~~~~~~~~~~~~~~~~~\alpha~~~~~~~(\lambda X_{2}.M[X_{1} \leftarrow X_{2}])$
		où $X_{2}~\notin~FV(M)$ 
		\\
		elle sert à renommer les variables. On peut comparer cela à une réecriture d'une expression pour rendre plus lisible la lecture et moins ambigüe.
		\smallbreak
		\item[-] $((\lambda X.M_{1})M_{2})~~~~~~~~~~~~\beta~~~~~~~~M_{1}[X \leftarrow M_{2}]$ 
		\\
		elle substitue une variable par un $\lambda$-terme. C'est la réduction principale, elle fait ce que j'ai expliqué plus haut avec l'\textit{abstraction} : elle va remplacer la variable en paramètre par une $\lambda$-expression.
		\smallbreak
		\item[-] $(\lambda X.(M~X))~~~~~~~~~~~~~~\eta~~~~~~~~M$ 
		où $X~\notin~FV(M)$ 
		\\ Cette règle traite le cas particulier d'une fonction inutile. En effet, si on a $g$ une fonction qui à $x$ associe $f(x)$. On aura donc $g(x) = f(x)$. La fonction $g$ devient obsolète. Ici c'est pareil, on a $(\lambda X.(M~X))$ quand on va appliquer une $\lambda$-expression $N$ on va avoir $((\lambda X.(M~X))~N)$. Si on suit la $\beta$-réduction on va substituer $X$ par $N$. On aura donc $(M~N)$. Cela revient au même dans le cas ou on utilise l'$\eta$-réduction cependant on n'aura pas eu à faire la substitution, on gagne en rapidité. 
	\end{itemize}
	\medbreak
	
	\textbf{\textit{La réduction générale \textbf{n} = $\alpha \cup \beta \cup \eta$}.}
	\bigbreak
	
	
	On peut remarquer que dans les règles on a une forme particulière : $N [X \leftarrow M]$ avec deux $\lambda$-termes $M$ ,
	$N$ et une variable $X$. Cette forme signifie que l'on va remplacer toutes les occurrences de $X$ par $M$ dans la $\lambda$-expression $N$.
	Cependant cette substitution est régie par une suite de règles qui sont les suivantes: 
	\begin{enumerate}
		\item $X_{1}[X_{1} \leftarrow M]~= M$ : Si on a $X_{1}$ et que l'on doit remplacer $X_{1}$ par $M$, on substitue $X_{1}$ par $M$.
		\item $X_{2}[X_{1} \leftarrow M]~= X_{2}$ où $X_{1}\neq X_{2}$ : Si on a $X_{2}$ et que l'on doit remplacer $X_{1}$ par $M$, ce n'est pas la variable recherchée donc on ne fait rien. 
		\item $(\lambda X_{1}.M_{1})[X_{1} \leftarrow M_{2}]~= (\lambda X_{1}.M_{1})$
		\item $(\lambda X_{1}.M_{1})[X_{2} \leftarrow M_{2}]~= (\lambda X_{3}.M_{1}[X_{1} \leftarrow X_{3}][X_{2} \leftarrow M_{2}])$ 
		\\où $X_{1} \neq X_{2}$, $X_{3} \notin FV(M_{2})$ et $X_{3} \notin FV(M_{1})\backslash{X_{1}}$ 
		\item $(M_{1}~M_{2})[X \leftarrow M_{3}]~=(M_{1}[X \leftarrow M_{3}]~M_{2}[X \leftarrow M_{3}])$
	\end{enumerate}
	\medbreak
	
	Les deux premières règles ont été expliquées et pas les autres car on a besoin de le représenter par un exemple pour vraiment saisir le problème.
	\begin{ex}
		Prenons un exemple de de programme Ocaml :
		\begin{itemize}
			\item[] $let~g~x = let~x = x + 1~in~x + 3;;$
		\end{itemize}
		On a $x$ comme seule variable cependant il n'a pas la même valeur dans l'entièreté du programme. Si on fait $g ~4$, on aura les variables $x$ soulignées suivantes : $let~g~\underline{x} = let~x = \underline{x} + 1~in~x + 3;;$ égales à $4$ et seulement elle. Les autres sont définies par le deuxième $let$ est sont donc "protégées" par celui-ci. 
		\medbreak
		
		Dans les $\lambda$-calcul c'est la même chose. On prend l'expression $((\lambda x.((\lambda x.x)~x))~y)$.
		Si on fait une $\beta$ réduction sur  $\underline{((\lambda x.((\lambda x.x)~x))~y)}$ on va avoir  $((\lambda z.z)~y)$. Pour éviter la confusion ce que l'on va faire c'est renommer avant pour éviter les conflits. C'est ce que l'on fait dans la règle 4.
	\end{ex}
	\bigbreak
	
	\begin{ex} 
		L'$\alpha$-réduction : $(\lambda x.(x~y)) $, On va renommer $x$ par $a$. $(\lambda x.(x~y)) \rightarrow_{\alpha} (\lambda a.(x~y)[x \leftarrow a]) \Longleftrightarrow (\lambda a.(a~y))$ 	
	\end{ex}
	
	\begin{ex}
		La $\beta$-réduction : $((\lambda x.(x~y))~f)$, On va substituer $x$ par $f$. $((\lambda x.(x~y))~f) \rightarrow_{\beta} ((x~y)[x \leftarrow f]) \Longleftrightarrow (f~y)$ 
	\end{ex}
	
	\begin{ex}
		L'$eta$-réduction : $(\lambda x.((\lambda z.(z~z))~x)$, On va garder $(\lambda z.(z~z))$ . $(\lambda x.((\lambda z.(z~z))~x) \rightarrow_{\eta} \lambda z.(z~z)$ 
	\end{ex}
	
	\begin{ex}
		La \textbf{n}-réduction : On va prendre la $\lambda$-expression suivante : $((\lambda f.\lambda g.\lambda x.(f~x~(g~x))~(\lambda x.\lambda y.x))~(\lambda x.\lambda y.x))$. Cette exemple est assez lourd visuellement mais il faut d'abord comprendre avec avant d'allèger la syntaxe. Pour aider on va indicer les parenthèses pour s'y retrouver. 
		\smallbreak
		
		\begin{itemize}
			\item[] $(^{1}(^{2}\lambda f.\lambda g.\lambda x.(^{3}(^{4}f~x)^{4}~(^{5}g~x)^{5})^{3}~(^{6}\lambda x.\lambda y.x)^{6})^{2}~\underline{(^{7}\lambda x.\lambda y.x)^{7}})^{1}$
			\item[] Dans un premier temps, on a renommé $x$ et $y$ grâce à $\alpha$-réduction pour ne pas se mélanger
			\item[$\rightarrow^{\alpha}_{\textbf{n}}$] $(^{1}(^{2}\lambda f.\lambda g.\lambda x.(^{3}(^{4}f~x)^{4}~(^{5}g~x)^{5})^{3}~\underline{(^{6}\lambda x.\lambda y.x)^{6}})^{2}~(^{7}\lambda a.\lambda b.a)^{7})^{1}$
			
			\item[] On a fait de même avec le second terme
			\item[$\rightarrow^{\alpha}_{\textbf{n}}$] $(^{1}\underline{(^{2}\lambda f.\lambda g.\lambda x.(^{3}(^{4}f~x)^{4}~(^{5}g~x)^{5})^{3}~(^{6}\lambda c.\lambda d.c)^{6})^{2}}~(^{7}\lambda a.\lambda b.a)^{7})^{1}$
			
			\item[] On a subsitué $f$ par $(\lambda c.\lambda d.c)$
			\item[$\rightarrow^{\beta}_{\textbf{n}}$] $\underline{(^{1}(^{2}\lambda g.\lambda x.(^{3}(^{4}(^{6}\lambda c.\lambda d.c)^{6}~x)^{4}~(^{5}g~x)^{5})^{3})^{2}~(^{7}\lambda a.\lambda b.a)^{7})^{1}}$
			
			\item[] On a subsitué $g$ par $(\lambda a.\lambda b.a)$
			\item[$\rightarrow^{\beta}_{\textbf{n}}$] $\lambda x.(^{3}(^{4}(^{6}\lambda c.\lambda d.c)^{6}~x)^{4}~\underline{(^{5}(^{7}\lambda a.\lambda b.a)^{7}~x)^{5}})^{3}$
			
			\item[] On a subsitué $a$ par $x$
			\item[$\rightarrow^{\beta}_{\textbf{n}}$] $\lambda x.(^{3}\underline{(^{4}(^{6}\lambda c.\lambda d.c)^{6}~x)^{4}}~x)^{3}$
			
			\item[] On a subsitué $c$ par $x$
			\item[$\rightarrow^{\beta}_{\textbf{n}}$] $\lambda x.(^{3}x~x)^{3}$
		\end{itemize}
		\bigbreak
		
		Le résultat est $\lambda x.(x~x)$. On peut voir que l'on se perd facilement avec les parenthèse dans tous les sens. Pour éviter cela, des simplifications d'écritures existent.
	\end{ex}
	
	
	\subparagraph{Simplification :} Afin d'allèger l'écriture en enlevant des parenthèses, on a une succession de règles de priorité :
	\begin{itemize}
		\item Application associative à gauche : $M1~M2~M3~= ((M1~M2)M3)$
		\item Application prioritaire par rapport à l'abstraction : $\lambda X.M1~M2~= \lambda X.(M1~M2)$
		\item Les abstractions consécutives peuvent être regroupées : $\lambda XYZ.M~= (\lambda X.(\lambda Y.(\lambda Z.M)))$
	\end{itemize}
	\medbreak
	
	\begin{ex}
		Voici un petit exemple comparatif.
		\begin{multicols}{2}{
				\begin{itemize}
					\item[] Version écriture lourde
					\item[] $((\lambda x.((\lambda z.z)~x))~\underline{(\lambda x.x)})$
					\item[$\rightarrow_{n}^{\alpha}$] $(\underline{(\lambda x.((\lambda z.z)~x))}~(\lambda y.y))$
					\item[$\rightarrow_{n}^{\eta}$] $\underline{((\lambda z.z)~(\lambda y.y))}$
					\item[$\rightarrow_{n}^{\beta}$] $(\lambda y.y)$
				\end{itemize}
				
				\begin{itemize}
					\item[] Version écriture allégée
					\item[] $(\lambda x.(\lambda z.z)~x)~\underline{\lambda x.x}$
					\item[$\rightarrow_{n}^{\alpha}$] $\underline{(\lambda x.(\lambda z.z)~x)}~\lambda y.y$
					\item[$\rightarrow_{n}^{\eta}$] $\underline{(\lambda z.z)~\lambda y.y}$
					\item[$\rightarrow_{n}^{\beta}$] $\lambda y.y$
				\end{itemize}
			}
		\end{multicols}
	\end{ex}
	\bigbreak
	
	
	\subsection{Forme normale et stratégie de réduction}
	
	\paragraph{Forme normale} Comment peut-on savoir quand une expression est réduite au maximum ? On peut se dire que l'on a réduit une expression au maximum quand on ne peut plus appliquer de réduction. Or l'$\alpha$-réduction est presque toujours applicable. On va se focaliser sur les deux autres réductions : La $\beta$ et l'$\eta$ réduction. On en ressort la règle suivante : \textit{Une expression est une forme normale si on ne peut pas réduire l'expression via une $\beta$ ou $\eta$ réduction}.
	\medbreak
	
	\textbf{Théorème de la forme normale :}
	Si on peut réduire $L$ tels que $L =_{n}~M$ et $L =_{n}~N$ et que $N$ et $M$ sont en forme normale alors $M = N$ à n renommages près.
	\medbreak
	
	Certaines $\lambda$-expressions n'ont pas de forme normale. On va voir cela sur un exemple.
	\begin{ex}
		 L'expression $((\lambda x.x~x)~(\lambda x.x~x))$ n'a pas de forme normale, elle va boucler indéfiniment.
		\begin{itemize}
			\item[~~~~] $\underline{((\lambda x.x~x)~(\lambda x.x~x))}$
			\item[$\rightarrow_{\beta}$] $\underline{((\lambda x.x~x)~(\lambda x.x~x))}$
			\item[$\rightarrow_{\beta}$] $\underline{((\lambda x.x~x)~(\lambda x.x~x))}$
			\item ...
			\item[$\rightarrow_{\beta}$] $\underline{((\lambda x.x~x)~(\lambda x.x~x))}$
		\end{itemize}
	\end{ex}
	\medbreak
	
	Le problème de la boucle infinie de réduction est aussi possible sur une $\lambda
	$-expression qui a une forme normale si on applique une "mauvaise" réduction.
	\begin{ex}
		Par exemple, si on prend l'expression $((\lambda x.\lambda y. y) ((\lambda x.x x)~(\lambda x.x x))~z)$.
		\begin{itemize}
			\item[] Si on choisit de réduire $((\lambda x.\lambda y. y) \underline{((\lambda x.x x)~(\lambda x.x x))}~z)$ on va rentrer dans une boucle infinie. 
			\item[] Mais si on décide de $(\underline{(\lambda x.\lambda y. y) ((\lambda x.x x)~(\lambda x.x x))}~z)$ cela reviendra à $((\lambda y.y)~z)$ ce qui donnera $z$.
		\end{itemize}
		
	\end{ex}
	\medbreak
	Pour régler se problème on va utiliser \textbf{une stratégie de réduction}.
	
	
	\paragraph{Stratégie de réduction} 
	La question de l'ordre dans laquelle il faut réduire l'expression se pose. En effet si on prend l'exemple suivant : $(\lambda x.x~x)~((\lambda y.y)~(\lambda z.z))$. On a deux possibilités de réduction :
	\begin{enumerate}
		\item $\underline{(\lambda x.x~x)~((\lambda y.y)~(\lambda z.z))} \rightarrow_{\beta} ((\lambda y.y)~(\lambda z.z))~((\lambda y.y)~(\lambda z.z))$ 
		\item $(\lambda x.x~x)~\underline{((\lambda y.y)~(\lambda z.z))} \rightarrow_{\beta} (\lambda x.x~x)~(\lambda z.z)$ 
	\end{enumerate} 
	\bigbreak
	
	
	Pour palier à ce problème on va définir des règles qui vont donner un ordre précis de réduction à faire. L'idée va être d'appliquer la réduction la plus large d'abord puis la plus à gauche. Cela va permettre d'éviter l'évaluation de sous-expressions inutiles. Voici les règles qui régissent la stratégie de réduction :
	\begin{itemize}
		\item[-] $M \longrightarrow_{\bar{n}}~N$~~~si $M~\beta~N$ : $N$ est une réduction de $M$ si on peut $\beta$ réduire $M$ en $N$.
		\smallbreak
		\item[-] $M \longrightarrow_{\bar{n}}~N$~~~si $M~\eta~N$ : $N$ est une réduction de $M$ si on peut $\eta$ réduire $M$ en $N$.
		\smallbreak
		\item[-] $(\lambda X.M) \longrightarrow_{\bar{n}}~(\lambda X.N)$ : $(\lambda X.N)$ est une réduction de $(\lambda X.M)$ si on a $M~\beta~N$ ou $M~\eta~N$.
		\smallbreak
		\item[-] $(M~N) \longrightarrow_{\bar{n}}~(M'~N)$~~~si $M \longrightarrow_{\bar{n}}~M'$ et $\forall~L$, $(M~N)~\beta~L$ impossible et $(M~N)~\eta~L$ impossible :\\
		$(M'~N)$ est une réduction de $(M~N)$ si il existe une réduction pour $M$ et si on ne peut pas appliquer une réduction sur $(M~N)$.
		\smallbreak
		\item[-] $(M~N) \longrightarrow_{\bar{n}}~(M~N')$~~~si $N \longrightarrow_{\bar{n}}~N'$
		et $M$ est une forme normale
		et  $\forall~L$, $(M~N)~\beta~L$ impossible et $(M~N)~\eta~L$ \\impossible :
		$(M~N')$ est une réduction de $(M~N')$ si $M$ est en forme normale, si il existe une réduction pour $N$ et si on ne peut pas appliquer une réduction sur $(M~N)$.
	\end{itemize}
	\smallbreak
	
	Cette suite de règles permet d'être sûr d'avoir une forme normale. Cependant elle ne suit pas forcément le chemin optimal cela créer donc une lenteur. 
	\medbreak
	
	
	
	\begin{ex}
		Si on prend l'expression suivante : $(\lambda x.(x~x))~((\lambda y.y)~(\lambda z.z)))$. On va faire deux développements, un qui suit les règles de la stratégie de réduction et l'autre que l'on va faire par nous-même en regardant ce qui nous avantages le plus.
		\begin{multicols}{2}{
				\begin{itemize}
					\item[] Version qui suit la stratégie de réduction
					\item[] $\underline{(\lambda x.(x~x))~((\lambda y.y)~(\lambda z.z))}$
					\item[$\rightarrow_{n}^{\beta}$] $\underline{((\lambda y.y)~(\lambda z.z))}~((\lambda y.y)~(\lambda z.z))$
					\item[$\rightarrow_{n}^{\beta}$] $\underline{(\lambda z.z)~((\lambda y.y)~(\lambda z.z))}$
					\item[$\rightarrow_{n}^{\beta}$] $\underline{((\lambda y.y)~(\lambda z.z))}$
					\item[$\rightarrow_{n}^{\beta}$] $(\lambda z.z)$
				\end{itemize}
				
				\begin{itemize}
					\item[] Version personnelle
					\item[] $(\lambda x.(x~x))~\underline{((\lambda y.y)~(\lambda z.z))}$
					\item[$\rightarrow_{n}^{\beta}$] $\underline{(\lambda x.(x~x))~(\lambda z.z)}$
					\item[$\rightarrow_{n}^{\beta}$] $\underline{(\lambda z.z)~(\lambda z.z)}$
					\item[$\rightarrow_{n}^{\beta}$] $(\lambda z.z)$
				\end{itemize}
			}
		\end{multicols}
		\smallbreak 
		J'ai résussi à atteindre la forme normale plus vite sans suivre la stratégie de réduction.
	\end{ex} 
	\medbreak
	
	Le faite de pouvoir atteindre le même résultat avec deux suites de réductions différentes vient de la propriété du diamant.
	\smallbreak
	\textbf{Théorème (Diamond Property pour $\twoheadrightarrow_{n}$) :} Si $L \twoheadrightarrow_{n} M$ et $L \twoheadrightarrow_{n} N$ alors il existe une expression $L'$ telle que $M \twoheadrightarrow_{n} L'$ et $N \twoheadrightarrow_{n} L'$.
	
	\paragraph{Stratégie d'évaluation} Pour évaluer un langage, on utilise ce qui s'appelle une \textbf{stratégie d'évaluation}, ici on parlait de stratégie de réduction. Cette stratégie explique quand les arguments d'une fonction sont évalués. Je vous présente les 2 stratégies qui nous intéressent :
	\smallbreak
	\begin{enumerate}
		\item \textbf{l'appel par nom :} pour une fonction f donnée, on évalue chaque argument quand on en a besoin, c'est-à-dire que l'on n'évalue pas les arguments avant l'appel de la fonction. Cette stratégie est pratique quand on a des arguments non utilisés et quand on veut travailler avec des listes infinies. 
		\\Mais par contre si tous les arguments sont utilisés elle est plus lente que celle présentée après car on doit réévaluer les arguments à chaque fois. Elle fait partie du groupe des stratégies d'évaluations non strictes, c'est-à-dire qu'il n'évalue pas forcément la fonction en entier. 
		\begin{ex}
			Pour une fonction $fst$ telle que pour deux arguments $x$ et $y$ on retourne le 1er. Si on a : $fst(3+4,5/5)$ on va évalué $3+4$. Ce qui donne $fst(7,5/5)$ et on retourne 7 on n'évalue pas $5/5$.
		\end{ex}
		\item[]
		\item  \textbf{l'appel par valeurs :} pour une fonction g donnée, on évalue ses arguments avant d'évaluer la fonction.
		\\Cette stratégie fait partie du groupe des stratégies d'évaluations strictes, c'est-à-dire qu'il évalue forcément la fonction en entier.
		\begin{ex}
			Pour une fonction $fst$ telle que pour deux arguments $x$ et $y$ on retourne le 1er. Si on a : $fst(3+4,5/5)$ on va évaluer $3+4$. Ce qui donne $fst(7,5/5)$, on évalue $5/5$ . On arrive à $fst(7,1)$ et on retourne 7.
		\end{ex}
	\end{enumerate}
	\medbreak
	
	La preuve de la compréhension des $\lambda$-calculs a été faite à travers son implantation en OCaml. Cependant cette implantation reste simplifiée et une version plus complète sera présentée dans la suite. 
	\smallbreak
	L'appel par valeur est plus facile à mettre en \oe{uvre} dans un langage. En effet, on a la garantit que l'élément que l'on va appliquer est réduit au maximum et que plus aucun traitement ne sera à faire sur lui ce qui réduit considérablement le nombre de règle qui va régir le langage. Cependant on va perdre en vitesse d'exécution ce qui est dérangeant mais que l'on va préférer à un recalcule de chaque élément.
	\begin{ex}
		Si on reprend l'expression $(\lambda x.(x~x))~((\lambda y.y)~(\lambda z.z))$. Un appel par nom va faire la chose suivante :
		\begin{itemize}
			\item[] $\underline{(\lambda x.(x~x))~((\lambda y.y)~(\lambda z.z))}$
			\item[$\rightarrow_{n}^{\beta}$] $\underline{((\lambda y.y)~(\lambda z.z))}~((\lambda y.y)~(\lambda z.z))$
			\item[$\rightarrow_{n}^{\beta}$] $\underline{(\lambda z.z)~((\lambda y.y)~(\lambda z.z))}$
			\item[$\rightarrow_{n}^{\beta}$] $\underline{((\lambda y.y)~(\lambda z.z))}$
			\item[$\rightarrow_{n}^{\beta}$] $(\lambda z.z)$
		\end{itemize}
		\medbreak
		
		On ne va pas traiter tout de suite $((\lambda y.y)~(\lambda z.z))$ ce qui va nous obliger à le traiter deux fois. Alors que si on réduit avec la stratégie de l'appel par valeur, on va avoir :
		\begin{itemize}
			\item[] $(\lambda x.(x~x))~\underline{((\lambda y.y)~(\lambda z.z))}$
			\item[$\rightarrow_{n}^{\beta}$] $\underline{(\lambda x.(x~x))~(\lambda z.z)}$
			\item[$\rightarrow_{n}^{\beta}$] $\underline{(\lambda z.z)~(\lambda z.z)}$
			\item[$\rightarrow_{n}^{\beta}$] $(\lambda z.z)$
		\end{itemize}
	\end{ex} 
	\bigbreak
	
	
	On va voir un exemple de langage utilisant la stratégie de l'appel par valeur : \textbf{ISWIM}.
	\newpage
	
	
	
	\subsection{ISWIM}	
	
	ISWIM est un langage impératif à noyau fonctionnel ; de fait, c'est une syntaxe proche du $\lambda$-calcul à laquelle sont ajoutées des variables mutables et des définitions. Grâce aux $\lambda$-calculs, ISWIM comporte des fonctions d'ordre supérieur et une portée lexicale des variables. Le but est de décrire des concepts en fonction d'autres concepts. Ce langage a fortement influencé les autres langages qui l'ont suivi, principalement dans la programmation fonctionnelle.
	\medbreak
	
	ISWIM a une grammaire étendue de la grammaire du $\lambda$-calcul.
	\smallbreak
	$M,N,L,K =$
	\begin{itemize}
		\item[ ] les termes des $\lambda$-calculs :
		\item[|] $X$ 
		\item[|] $(\lambda X.M)$
		\item[|] $(M~N)$
		\item[ ] les nouveaux termes :
		\item[|] $b$ : une constante
		\item[|] $(o^{n}~M~...~N)$ avec $o^{n}$ les fonctions primitives d'arité $n$
	\end{itemize}
	\medbreak
	
	On définit une valeur telle que :
	\smallbreak
	$V,U,W =$
	\begin{itemize}
		\item[|] $b$
		\item[|] $X$
		\item[|] $(\lambda X.M)$
	\end{itemize}
	\bigbreak
	
	
	Les règles de $\beta$-réductions sont les mêmes que celles pour le $\lambda$-calcul avec deux ajouts qui sont les suivants :
	\begin{itemize}
		\item $b[X \longleftarrow M] = b$
		\item $(o^{n}~M_{1}~...~M_{n})[X \longleftarrow M] = (o^{n}~M_{1}[X \longleftarrow M]~...~M_{n}[X \longleftarrow M])$
	\end{itemize}
	\bigbreak
	
	
	La $\beta$-réduction est la même qu'en $\lambda$-calcul mais à la condition que la réduction soit faite avec une valeur $V$. 
	\begin{itemize}
		\item[-] $((\lambda X.M)~V)~\beta_{v}~M[X \longleftarrow V]$
	\end{itemize} 
	\smallbreak
	Cette restriction permet une sorte d'ordre dans les calculs.
	\medbreak
	
	Cependant l'$\eta$ et l'$\alpha$ réduction ne sont plus vues comme telles. En effet l'$\eta$-réduction n'est pas utilisée car plus très utile et contraignante à programmer.L'$\alpha$-réduction sera utilisée pour rechercher une équivalence entre deux termes, on renommera d'ailleurs l'équivalence en $\alpha$-équivalence.
	\medbreak
	
	Une réduction a été rajoutée pour gérer les opérateurs : c'est la $\delta$-réduction. Ce qui nous donne une nouvelle \textbf{n}-réduction telle que \textbf{n}-réduction = $\beta_{v} \cup \delta$
	\bigbreak
	
	\begin{ex}
		Voici un exemple de \textbf{n}-réduction. On va prendre l'expression suivante : $(\lambda f x.(f~x)~\lambda y.(+~y~y)~\ulcorner 1\urcorner)$. 
		\smallbreak
		\begin{itemize}
			\item[] $(\underline{\lambda f x.(f~x)~\lambda y.(+~y~y)}~\ulcorner 1\urcorner)$
			\item[] On a substitué $f$ par $\lambda y.(+~y~y)$
			\item[$\rightarrow^{\beta}_{n}$] $\underline{(\lambda x.(\lambda y.(+~y~y)~x)~\ulcorner 1\urcorner)}$
			
			\item[] On a substitué $x$ par $\ulcorner 1\urcorner$
			\item[$\rightarrow^{\beta}_{n}$] $\underline{(\lambda y.(+~y~y)~\ulcorner 1\urcorner)}$
			
			\item[] On a substitué $y$ par $\ulcorner 1\urcorner$
			\item[$\rightarrow^{\beta}_{n}$] $\underline{(+~\ulcorner 1\urcorner~\ulcorner 1\urcorner)}$
			
			\item[] On applique l'opérateur $+$ sur $\ulcorner 1\urcorner~\ulcorner 1\urcorner$
			\item[$\rightarrow^{\delta}_{n}$] $\ulcorner 2\urcorner$
		\end{itemize}
		\smallbreak
		Le résultat est $\ulcorner 2\urcorner$.
	\end{ex}
	\medbreak
	
	Vous pouvez retrouver un exemple d'implantation de ce langage en Ocaml.
	
	\subsection{Machines abstraites}
	
	\paragraph{CC Machine :} CC vient des termes \textbf{Control string} et \textbf{Context} qui représentent respectivement:
	\begin{itemize}
		\item la partie du $\lambda$-calcul que l'on traite
		\item la partie du $\lambda$-calcul que l'on met en attente 
	\end{itemize}
	Cette séparation permet d'appliquer l'appel par valeur simplement. En effet à chaque fois que l'on a une application on évalue le terme de gauche puis le terme de droit. Le fait de se concentrer sur une sous-expression est possible grâce au contexte qui prend la partie générale de l'expression pour la mettre en attente. Cette machine reprend la sémantique du langage ISWIM. 
	\medbreak
	
	Pour ne pas perdre la position de la sous-expression que l'on traite dans l'expression générale, on utilise un \textbf{trou} qui est représenté par $[~]$ dans notre expression.
	\bigbreak
	
	
	Basiquement la machine va évaluer l'expression comme ceci :
	\begin{itemize}
		\item[] - Quand on a une application $(M~N)$ :
		\begin{itemize}
			\item[] - la machine évalue $M$ et le garde dans le contexte $([~]~N)$.
			\item[] - elle remet la sous-expression $M$ évaluée, soit $M \twoheadrightarrow_{cc} V$, dans l'application ce qui donnera $(V~N)$
			\item[] - elle évalue $N$ et le garde dans le contexte $(V~[~])$ 
			\item[] - elle remet la sous-expression $N$ évaluée, soit $N \twoheadrightarrow_{cc} U$, dans l'application ce qui donnera $(V~U)$
			\item[] - elle évalue $(V~U)$ 
		\end{itemize}
		\item[] - Quand on a une abstraction $((\lambda X,M)~N)$ : 
		\begin{itemize}
			\item[] - c'est une application, sachant que $V = (\lambda X,M)$ on a $(V~N)$. Si on utilise ce que l'on a dit plus haut on aura $V~U$ avec  $V = (\lambda X,M)$. C'est une $\beta$-réduction, on retombe sur un cas simple.
		\end{itemize}
		\item[] - Quand on a une opération $(o^{n}~M...N)$ : c'est le même principe que l'application
		\begin{itemize}
			\item[] - la machine évalue $M$ et le garde $(o^{n}~[]...N)$.
			\item[] - elle remet la sous-expression $M$ évaluée, soit $M \twoheadrightarrow_{cc} V$, dans l'opération ce qui donnera $(o^{n}~V...N)$
			\item[] - etc jusqu'à avoir $(o^{n}~V...U)$ pour pouvoir évaluer l'opération
		\end{itemize}
	\end{itemize}
	\bigbreak
	
	
	Les règles définies pour cette machine sont les suivantes :
	\begin{enumerate}
		
		\item $\langle(M~N),E\rangle~~~~~~~~~~~~~~~~~~~~~~~~\longmapsto_{cc}~~~~~~~~\langle M,E[([]~N)]\rangle~si M \notin V$
		
		\item $\langle(V_{1}~N),E\rangle~~~~~~~~~~~~~~~~~~~~~~~~\longmapsto_{cc}~~~~~~~~\langle N,E[(V_{1}~[])]\rangle~si N \notin V$
		
		\item $\langle((\lambda X.M)~V),E\rangle~~~~~~~~~~~~~~~~~\longmapsto_{cc}~~~~~~~~\langle M[X\longleftarrow V],E\rangle$
		
		\item $\langle V,E[(U~[])]\rangle~~~~~~~~~~~~~~~~~~~~~~~\longmapsto_{cc}~~~~~~~~\langle(U~V),E\rangle$
		
		\item $\langle V,E[([]~N)]\rangle~~~~~~~~~~~~~~~~~~~~~~~\longmapsto_{cc}~~~~~~~~\langle(V~N),E\rangle$ 
		
		\item $\langle(o^{n}~V_{1}...V_{i}~M~N~...),E\rangle~~~~~~~~\longmapsto_{cc}~~~~~~~~
		\langle M,E[(o^{n}~V_{1}...V_{i}~[]~N~...)]\rangle~ si M \notin V$
		
		\item $\langle(o^{n}~b_{1}...b_{n}),E\rangle~~~~~~~~~~~~~~~~~~~~\longmapsto_{cc}~~~~~~~~\langle V,E\rangle$ avec $V = \delta(o^{n},b_{1}...b_{n})$ 
		
		\item $\langle V,E[(o^{n}~V_{1}...V_{i}~[]~N~...)]\rangle ~~~~~~\longmapsto_{cc}~~~~~~~~\langle(o^{n}~V_{1}...V_{i}~V~N ~...),E\rangle$ 
	\end{enumerate}
	\bigbreak
	
	
	La machine peut s'arrêter dans trois états différents:
	\begin{itemize}
		\item[-] Soit on a une \textbf{constante} telle que $\langle M,[]\rangle \twoheadrightarrow_{cc} \langle b,[]\rangle$;
		\item[-] Soit on a une \textbf{fonction} telle que $\langle M,[]\rangle \twoheadrightarrow_{cc} \langle\lambda X.N,[]\rangle$;
		\item[-] Sinon on a un \textbf{état inconnu} soit une \textbf{erreur}.
	\end{itemize}
	\bigbreak
	
	
	\begin{ex}
			Voici un exemple de la machine CC pour l'expression : $(((\lambda f.\lambda x.f$ $x)$ $\lambda y.(+$ $y$ $y))$ $\ulcorner 1\urcorner)$.
		
		\begin{multicols}{2}\raggedright{
				\begin{itemize}
					\item[] CC : $\langle(((\lambda f.\lambda x.f$ $x)$ $\lambda y.(+$ $y$ $y))$ $\ulcorner 1\urcorner),[]\rangle$
					\item[] > (1) 
					\item[] CC : $\langle((\lambda f.\lambda x.f$ $x)$ $\lambda y.(+$ $y$ $y)),[([]$ $\ulcorner 1\urcorner)]\rangle$
					\item[] > (3)
					\item[] CC : $\langle(\lambda x.f$ $x)[f \leftarrow \lambda y.(+$ $y$ $y)],[([]$ $\ulcorner 1\urcorner)]\rangle$
					\item[] CC : $\langle(\lambda x.(\lambda y.(+$ $y$ $y))$ $x),[([]$ $\ulcorner 1\urcorner)]\rangle$
					\item[] > (5)
					
				\end{itemize}
				
				\begin{itemize}
					\item[] CC : $\langle((\lambda x.(\lambda y.(+$ $y$ $y))$ $x)$ $\ulcorner 1\urcorner),[]\rangle$
					\item[] > (3) 
					\item[] CC : $\langle((\lambda y.(+$ $y$ $y))$ $x)[x \leftarrow \ulcorner 1\urcorner],[]\rangle$
					\item[] CC : $\langle((\lambda y.(+$ $y$ $y))$ $\ulcorner 1\urcorner),[]\rangle$
					\item[] > (3) 
					\item[] CC : $\langle(+$ $y$ $y)[y \leftarrow \ulcorner 1\urcorner],[]\rangle$
					\item[] CC : $\langle(+$ $\ulcorner 1\urcorner$ $\ulcorner 1\urcorner),[]\rangle$
					\item[] > (7)
					\item[] CC : $\langle\ulcorner 2\urcorner,[]\rangle$
				\end{itemize}
			}
		\end{multicols}
	\end{ex}
	\newpage
	
	
	
	\paragraph{SCC Machine :}
	
	La machine SCC est une simplification de la machine CC. En effet, la machine CC exploite uniquement les informations de la chaîne de contrôle (\textbf{Control string}). D'ailleurs le S de SCC est un acronyme de \textbf{Simplified}. Du coup on combine certaines règles en exploitant les informations du contexte (\textbf{Context}).
	\bigbreak
	
	
	Dans la machine CC, on peut réunir :
	
	\begin{itemize}
		\item[] (5)$_{cc}$ $\langle V,E[([]~N)]\rangle~~~\longmapsto_{cc}~~~\langle(V~N),E\rangle$
		\item[] (2)$_{cc}$ $\langle(V~N),E\rangle~~~~~~\longmapsto_{cc}~~~\langle N,E[(V~[])]\rangle$
		\item[] $\rightarrow$ sont combinées dans la règle (4)$_{scc}$ $ \langle V,E[[]~N)]\rangle~~~~\longmapsto_{scc}~~~\langle N,E[(V~[])]\rangle$
		\item[]
		\item[] (4)$_{cc}$ $\langle V,E[(U~[])]\rangle~~~~~~~~\longmapsto_{cc}~~~\langle(U~V),E\rangle$
		\item[]	(3)$_{cc}$ $\langle((\lambda X.M)~V),E\rangle~~~\longmapsto_{cc}~~~\langle M[X\longleftarrow V],E\rangle$
		\item[] $\rightarrow$ sont combinées dans la règle (3)$_{scc}$ $\langle V,E[((\lambda X.M)~[])]\rangle ~~~\longmapsto_{scc}~~~\langle M[X\leftarrow V],E\rangle$
		\item[]
		\item[] (8)$_{cc}$ $\langle V,E[(o^{n}~V_{1}...V_{i}~[]~N~...)]\rangle~~~\longmapsto_{cc}~~~ \langle(o^{n}~V_{1}...V_{i}~V~N ~...),E\rangle$ 
		\item[] (7)$_{cc}$ $\langle(o^{n}~b_{1}...b_{n}),E\rangle~~~~~~~~~~~~~~~~~\longmapsto_{cc}~~~\langle V,E\rangle$ avec $V = \delta(o^{n},b_{1}...b_{n})$ 
		\item[] $\rightarrow$ sont combinées dans la règle (5)$_{scc}$ $\langle b,E[(o^{n},b_{1},...b_{i},[])]\rangle ~~~\longmapsto_{scc}~~~\langle V,E\rangle~avec~\delta
		(o^{n},b_{1},...b_{i},b)=V$
	\end{itemize}
	\medbreak
	
	Le fonctionnement reste le même que la machine CC dans le principe et la façon de fonctionner. Le but de cette machine est d'utiliser toutes les informations que l'on peut extraire d'un état de la machine pour rendre le fonctionnement plus rapide.
	\bigbreak
	
	
	Les règles qui définissent la machine SCC sont les suivantes :
	
	\begin{enumerate}
		\item $\langle(M~N),E\rangle~~~~~~~~~~~~~~~~~~~~~~~~\longmapsto_{scc}~~~\langle M,E[([]~N)]\rangle$
		
		\item $\langle(o^{n}~M~N...),E\rangle~~~~~~~~~~~~~~~~~~\longmapsto_{scc}~~~\langle M,E[(o^{n}~[]~N...)]\rangle$
		
		\item $\langle V,E[((\lambda X.M)$ $[])]\rangle~~~~~~~~~~~~~~\longmapsto_{scc}~~~\langle M[X\leftarrow V],E\rangle$
		
		\item $\langle V,E[[]$ $N)]\rangle~~~~~~~~~~~~~~~~~~~~~~~\longmapsto_{scc}~~~\langle N,E[(V$ $[])]\rangle$
		
		\item $\langle b,E[(o^{n},b_{1},...b_{i},[])]\rangle~~~~~~~~~~~~\longmapsto_{scc}~~~\langle V,E\rangle$ avec $\delta
		(o^{n},b_{1},...b_{i},b)=V$ 
		
		\item $\langle V,E[(o^{n},V_{1},...V_{i},[],N$ $L)]\rangle~~~\longmapsto_{scc}~~~\langle N,E[(o^{n},V_{1},...V_{i},V,[],L)]\rangle$
	\end{enumerate}
	\bigbreak
	
	
	De même que pour la machine CC,la machine SCC peut s'arrêter dans trois états différents:
	\begin{itemize}
		\item[-] Soit on a une \textbf{constante b} telle que $\langle M,[]\rangle \twoheadrightarrow_{scc} \langle b,[]\rangle$;
		\item[-] Soit on a une \textbf{fonction} telle que $\langle M,[]\rangle \twoheadrightarrow_{scc} \langle\lambda X.N,[]\rangle$;
		\item[-] Sinon on a un \textbf{état inconnu} soit une \textbf{erreur}.
	\end{itemize}
	\bigbreak
	
	\begin{ex}
		Voici un exemple de la machine SCC pour l'expression : $(((\lambda f.\lambda x.f$ $x)$ $\lambda y.(+$ $y$ $y))$ $\ulcorner 1\urcorner)$.
		
		\begin{multicols}{2}\raggedright{
				\begin{itemize}
					\item[] SCC : $\langle(((\lambda f.\lambda x.f$ $x)$ $\lambda y.(+$ $y$ $y))$ $\ulcorner 1\urcorner),[]\rangle$
					\item[] > (1)
					\item[] SCC : $\langle((\lambda f.\lambda x.f$ $x)$ $\lambda y.(+$ $y$ $y)),[([]$ $\ulcorner 1\urcorner)]\rangle$
					\item[] > (1)
					\item[] SCC : $\langle(\lambda f.\lambda x.f$ $x),[([]$ $\ulcorner 1\urcorner),([]$ $(\lambda y.(+$ $y$ $y)))]\rangle$
					\item[] > (4)
					\item[] SCC : $\langle(\lambda y.(+$ $y$ $y)),[([]$ $\ulcorner 1\urcorner),((\lambda f.\lambda x.f$ $x)$ $[])]\rangle$
					\item[] > (3) 
					\item[] SCC : $\langle(\lambda x.f$ $x)[f\leftarrow(\lambda y.(+$ $y$ $y))],[([]$ $\ulcorner 1\urcorner)]\rangle$
					\item[] SCC : $\langle(\lambda x.(\lambda y.(+$ $y$ $y))$ $x),[([]$ $\ulcorner 1\urcorner)]\rangle$
					\item[] > (4) 
					\item[] SCC : $\langle\ulcorner 1\urcorner,[((\lambda x.(\lambda y.(+$ $y$ $y))$ $x)$ $[])]\rangle$
					\item[] > (3) 
					\item[] SCC : $\langle((\lambda y.(+$ $y$ $y))$ $x)[x \leftarrow\ulcorner 1\urcorner],[]\rangle$
					\item[] SCC : $\langle((\lambda y.(+$ $y$ $y))$ $\ulcorner 1\urcorner,[]\rangle$
				\end{itemize}
				
				\begin{itemize}
					\item[] > (1) 
					\item[] SCC : $\langle(\lambda y.(+$ $y$ $y)),[([]$ $\ulcorner 1\urcorner)]\rangle$
					\item[] > (4)
					\item[] SCC : $\langle\ulcorner 1\urcorner,[(\lambda y.(+$ $y$ $y))$ $[])]\rangle$
					\item[] > (3) 
					\item[] SCC : $\langle(+$ $y$ $y)[y \leftarrow \ulcorner 1\urcorner],[]\rangle$	
					\item[] SCC : $\langle(+$ $\ulcorner 1\urcorner$ $\ulcorner 1\urcorner),[]\rangle$	
					\item[] > (2) 
					\item[] SCC : $\langle\ulcorner 1\urcorner,(+$ $[]$ $\ulcorner 1\urcorner)\rangle$	
					\item[] > (6) 
					\item[] SCC : $\langle\ulcorner 1\urcorner,(+$ $\ulcorner 1\urcorner$ $[])\rangle$	
					\item[] > (5)
					\item[] SCC : $\langle\ulcorner 2\urcorner,[]\rangle$	
				\end{itemize}
			}
		\end{multicols}
	\end{ex}
	\newpage
	
	
	\paragraph{CK Machine}
	
	Les machines CC et SCC cherchent toujours à traiter l'élément le plus à gauche , c'est-à-dire que si on a une application on va en créer une intermédiaire dans le contexte avec un trou et traiter la partie gauche de cette application etc jusqu'à arriver sur une valeur pour pouvoir "reconstruire", en reprenant l'application intermédiaire. C'est le style \textbf{ LIFO (Last In, First Out)}. Ce qui fait que les étapes de transitions dépendent directement de la forme du premier élément et non de la structure générale.
	\smallbreak
	Pour palier ce problème, la machine CK ajoute un nouvel élément, le \textbf{registre de contexte d'évaluation}, nommé $\kappa$, qui permet la sauvegarde de ce qu'on appelle la \textbf{continuation},c'est-à-dire la suite des instructions qu'il lui reste à exécuter.
	\smallbreak
	La machine CK va donc fonctionner avec une chaîne de contrôle \textbf{C} (\textbf{Control string}) comme les machines CC et SCC mais remplace le contexte par la continuation \textbf{K}. 
	\medbreak
	
	On a $\kappa$ = mt
	\begin{itemize}
		\item[|] $\langle fun,V,\kappa \rangle$
		\item[|] $\langle arg,N,\kappa \rangle$
		\item[|] $\langle opd,\langle V,...,V,o^{n}\rangle,\langle N,... \rangle,\kappa \rangle$
	\end{itemize}
	\smallbreak
	Cette continuation, au-delà de sauvegarder le reste de l'expression à traiter, va garder en mémoire ce que l'on a dedans. Basiquement elle va nous dire si on a une fonction, un argument ou une opération. Cette spécification permet d'enlever les \textbf{trous} notés précédemment $[~]$.
	\medbreak
	
	Cette machine agit en fonction de ce qui est présent dans la continuation.
	\begin{itemize}
		\item[] - Quand on a rien :
		\begin{itemize}
			\item[] - Soit on a une application $(M~N)$, On va traiter $M$ et dire que $N$ est un argument.
			\item[] - Soit on a une valeur ce qui signifie la fin du fonctionnement de la machine
		\end{itemize}
		\item[] - Quand on a un argument $M$ : On aura une valeur $V$ dans la chaîne de contrôle. On l'évalue et on la stocke dans la continuation $V$ qui est une fonction car si $M$ a été stocké comme un argument cela veut dire qu'initialement on avait l'application $(N~M)$; $N$ est évalué donne $V$ donc on doit appliquer $M$ à $V$ ce qui veut dire que $V$ est une fonction.
		\item[] - Quand on a une fonction $V$ : On va appliquer l'argument $U$ qui est dans la chaîne de contrôle a $V$
		\item[] - Quand on a une opération : on va traiter successivement chaque éléments de l'opération qui sont en attente d'être traités et quand c'est fait on évalue l'opération. 
	\end{itemize}
	\bigbreak
	
	
	Les règles qui définissent la machine CK sont les suivantes :
	\begin{enumerate}
		\item $\langle(M$ $N),\kappa\rangle~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\longmapsto_{ck}~~~\langle M,\langle arg,N,\kappa\rangle\rangle$
		\item $\langle V,\langle fun,(\lambda X.M),\kappa \rangle \rangle~~~~~~~~~~~~~~~~~\longmapsto_{ck}~~~\langle M[X \leftarrow V],\kappa\rangle$
		\item $\langle V,\langle arg,N,\kappa \rangle \rangle~~~~~~~~~~~~~~~~~~~~~~~~~~\longmapsto_{ck}~~~\langle N,\langle fun,V,\kappa \rangle \rangle$
		\item $\langle(o^{n}$ $M$ $N...),\kappa\rangle~~~~~~~~~~~~~~~~~~~~~~~~\longmapsto_{ck}~~~\langle M,\langle opd,\langle o^{n}\rangle,\langle N,...\rangle,\kappa\rangle\rangle$
		
		\item $\langle b,\langle opd,\langle b_{i},...b_{1},o^{n}\rangle,\langle\rangle,\kappa\rangle\rangle ~~~~~~~~~~\longmapsto_{ck}~~~\langle V,\kappa\rangle$ avec $\delta(o^{n},b_{1},...b_{i},b) = V$
		
		\item $\langle V,\langle opd,\langle V',...o^{n}\rangle,\langle N,L,...\rangle,\kappa\rangle\rangle ~~~\longmapsto_{ck}~~~\langle N,\langle opd,\langle V,V',...o^{n}\rangle,\langle L,...\rangle,\kappa\rangle\rangle$
	\end{enumerate}
	\bigbreak
	
	
	la machine CK peut s'arrêter dans trois états différents:
	\begin{itemize}
		\item[-] Soit on a une \textbf{constante b} telle que $\langle M,mt\rangle \twoheadrightarrow_{ck} \langle b,mt\rangle$;
		\item[-] Soit on a une \textbf{fonction} telle que $\langle M,mt\rangle \twoheadrightarrow_{ck} \langle\lambda X.N,mt\rangle$;
		\item[-] Sinon on a un \textbf{état inconnu} soit une \textbf{erreur}.
	\end{itemize}
	\bigbreak
	
	\begin{ex}
		Voici une partie d'exemple de la machine CK pour l'expression : 
		$(((\lambda f.\lambda x.f$ $x)$ $\lambda y.(+$ $y$ $y))$ $\ulcorner 1\urcorner)$.
		\\ L'exemple complet peut être retrouvé dans les \hyperref[CK]{Annexes}.
		
		\begin{multicols}{2}\raggedright{
				\begin{itemize}
					\item[] CK : $\langle(((\lambda f.\lambda x.f$ $x)$ $\lambda y.(+$ $y$ $y))$ $\ulcorner 1\urcorner),mt\rangle$
					\item[] ...
					\item[] On a un exemple d'application sur une abstraction
					\item[] CK : $\langle(\lambda x.(\lambda y.(+$ $y$ $y))$ $x),\langle arg,\ulcorner 1\urcorner,mt\rangle\rangle$	
					\item[] > (3) 
					\item[] CK : $\langle\ulcorner 1\urcorner,\langle fun,(\lambda x.(\lambda y.(+$ $y$ $y))$ $x),mt\rangle\rangle$
					\item[] > (2) 
					\item[] CK : $\langle((\lambda y.(+$ $y$ $y))$ $x)[x \leftarrow \ulcorner 1\urcorner ],mt\rangle$
					\item[] CK : $\langle((\lambda y.(+$ $y$ $y))$ $\ulcorner 1\urcorner),mt\rangle$
				\end{itemize}
				
				\begin{itemize}
					\item[] ...
					\item[] On voit comment l'opération est traitée
					\item[] CK : $\langle(+$ $\ulcorner 1\urcorner$ $\ulcorner 1\urcorner),mt\rangle$
					\item[] > (4)
					\item[] CK : $\langle\ulcorner 1\urcorner,\langle opd,\langle + \rangle,\langle\ulcorner 1\urcorner\rangle,mt\rangle\rangle$
					\item[] > (6) 
					\item[] CK : $\langle\ulcorner 1\urcorner,\langle opd,\langle\ulcorner 1\urcorner,+ \rangle,\langle\rangle,mt\rangle\rangle$
					\item[] > (5) 
					\item[] CK : $\langle\ulcorner 2\urcorner,mt\rangle$
				\end{itemize}
			}
		\end{multicols}
	\end{ex}
	\newpage
	
	
	
	\paragraph{CEK Machine}
	
	Pour toutes les machines vues jusqu'à présent la $\beta$-réduction était appliquée immédiatement. Cela coûte cher surtout quand l'expression est grande. De plus, si notre substitution n'est pas une variable elle est traitée avant d'être appliquée.
	\smallbreak
	Il est plus intéressant d'appliquer les substitutions quand on en a vraiment la nécessité. Pour cela, la machine CEK ajoute les fermetures et un environnement $\varepsilon$ qui va stocker les substitutions à effectuer. Cet environnement est une fonction qui pour une variable va retourner une expression.
	\medbreak
	
	On a alors:
	\begin{itemize}
		\item[] $\varepsilon$ = une fonction $\{\langle X,c\rangle,...\}$    c = $\{\langle M,\varepsilon\rangle$ $|$ $FV(M)\subset dom(\varepsilon)\}$    v = $\{\langle V,\varepsilon\rangle$ $|$ $\langle V,\varepsilon\rangle \in c\}$
		\item[] $\varepsilon[X \leftarrow c]$ = $\{\langle X,c\rangle\}$ $\cup$ $\{\langle Y,c'\rangle$ $|$ $\langle Y,c'\rangle \in \varepsilon$ et $ Y \neq X\}$
	\end{itemize}
	\medbreak
	
	$\kappa$ est renommé $\overline{\kappa}$ et défini par :
	\smallbreak
	$\overline{\kappa}$ = mt
	\begin{itemize}
		\item[|] $\langle fun,v,\overline{\kappa} \rangle$
		\item[|] $\langle arg,c,\overline{\kappa} \rangle$
		\item[|] $\langle opd,\langle v,...,v,o^{n}\rangle,\langle c,... \rangle,\overline{\kappa} \rangle$
	\end{itemize}
	\bigbreak
	
	
	Les règles qui définissent la machine CEK sont les suivantes :
	\begin{enumerate}
		\item $\langle\langle(M$ $N),\varepsilon\rangle,\overline{\kappa}\rangle 
		~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\longmapsto_{cek}~~~
		\langle \langle M,\varepsilon\rangle,\langle arg,\langle N,\varepsilon\rangle,\overline{\kappa}\rangle\rangle$	
		
		\item $\langle\langle X,\varepsilon\rangle,\overline{\kappa}\rangle
		~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\longmapsto_{cek}~~~
		\langle c,\overline{\kappa}\rangle$ avec $\varepsilon(X) = c$
		
		\item $\langle\langle V,\varepsilon\rangle,\langle fun,\langle (\lambda X1.M),\varepsilon'\rangle,\overline{\kappa} \rangle \rangle 
		~~~~~~~~~~~~~~~\longmapsto_{cek}~~~
		\langle \langle M,\varepsilon'[X1 \leftarrow \langle V,\varepsilon\rangle]\rangle,\overline{\kappa}\rangle$ si $V \notin X$
		
		\item  $\langle \langle V,\varepsilon\rangle,\langle arg,\langle N,\varepsilon'\rangle,\kappa\rangle\rangle ~~~~~~~~~~~~~~~~~~~~~~~~~~\longmapsto_{cek}~~~
		\langle \langle N,\varepsilon'\rangle,\langle fun,\langle V,\varepsilon\rangle,\overline{\kappa}\rangle\rangle$ si $V \notin X$
		
		\item $\langle\langle(o^{n}$ $M$ $N...),\varepsilon\rangle,\overline{\kappa}\rangle ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\longmapsto_{cek}~~~
		\langle \langle M,\varepsilon\rangle,\langle opd,\langle o^{n}\rangle,\langle \langle N,\varepsilon\rangle,...\rangle,\overline{\kappa}\rangle\rangle$
		
		\item $\langle  \langle b,\varepsilon\rangle,\langle opd,\langle \langle b_{i},\varepsilon_{i}\rangle,...\langle b_{1},\varepsilon_{1}\rangle ,o^{n}\rangle,\langle\rangle,\overline{\kappa}\rangle\rangle
		~~~\longmapsto_{cek}~~~
		\langle \langle V,\emptyset\rangle,\overline{\kappa}\rangle$ avec $\delta(o^{n},b_{1},...b_{i},b) = V$
		
		\item $\langle \langle V,\varepsilon\rangle,\langle opd,\langle v',...o^{n}\rangle,\langle  \langle N,\varepsilon'\rangle,c,...\rangle,\overline{\kappa}\rangle\rangle
		~~~~\longmapsto_{cek}~~~
		\langle \langle N,\varepsilon'\rangle,\langle opd,\langle  \langle V,\varepsilon\rangle,v',...o^{n}\rangle,\langle c,...\rangle,\overline{\kappa}\rangle\rangle$ si $V \notin X$
	\end{enumerate}
	\bigbreak
	
	
	la machine CEK peut s'arrêter dans trois états différents:
	\begin{itemize}
		\item[-] Soit on a une \textbf{constante b} telle que $\langle \langle M,\emptyset\rangle,mt\rangle \twoheadrightarrow_{cek} \langle\langle b,\varepsilon\rangle,mt\rangle$;
		\item[-] Soit on a une \textbf{fonction} telle que $\langle \langle M,\emptyset\rangle,mt\rangle \twoheadrightarrow_{cek} \langle\langle \lambda X.N,\varepsilon\rangle,mt\rangle$;
		\item[-] Sinon on a un \textbf{état inconnu} soit une \textbf{erreur}.
	\end{itemize}
	\bigbreak
	
	\begin{ex}
			On va voir une partie d'un exemple pour voir le changement avec la machine CK. On se concentre sur l'utilisation de l'environnement.
		\medbreak
		
		\begin{itemize}
			\item[] CEK machine : $\langle\langle(((\lambda f.\lambda x.f$ $x)$ $\lambda y.(+$ $y$ $y))$ $\ulcorner 1\urcorner),\emptyset\rangle,mt\rangle$
			\item[] ...
			\item[] On a deux parties qui appliquent une abstraction.
			\item[] CEK : $\langle\langle(\lambda y.(+$ $y$ $y)),\emptyset\rangle,\langle fun,\langle(\lambda f.\lambda x.f$ $x),\emptyset\rangle,\langle arg,\langle\ulcorner 1\urcorner,\emptyset\rangle,mt\rangle\rangle\rangle$
			\item[] > (3) 
			\item[] CEK : $\langle\langle(\lambda x.f$ $x),\emptyset[f \leftarrow \langle(\lambda y.(+$ $y$ $y)),\emptyset\rangle]\rangle,\langle arg,\langle\ulcorner 1\urcorner,\emptyset\rangle,mt\rangle\rangle$
			\item[] CEK : $\langle\langle(\lambda x.f$ $x),\{\langle f,\langle(\lambda y.(+$ $y$ $y)),\emptyset\rangle\rangle\}\rangle,\langle arg,\langle\ulcorner 1\urcorner,\emptyset\rangle,mt\rangle\rangle$
			\item[] > (4) 
			\item[] CEK : $\langle\langle\ulcorner 1\urcorner,\emptyset\rangle,\langle fun,\langle(\lambda x.f$ $x),\{\langle f,\langle(\lambda y.(+$ $y$ $y)),\emptyset\rangle\rangle\}\rangle,mt\rangle\rangle$
			\item[] > (3) 
			\item[] CEK : $\langle\langle(f$ $x),\{\langle f,\langle(\lambda y.(+$ $y$ $y)),\emptyset\rangle\rangle\}[x \leftarrow \langle\ulcorner 1\urcorner,\emptyset\rangle]\rangle,mt\rangle$
			\item[] CEK : $\langle\langle(f$ $x),\{\langle f,\langle(\lambda y.(+$ $y$ $y)),\emptyset\rangle\rangle,\langle x,\langle\ulcorner 1\urcorner,\emptyset\rangle\rangle\}\rangle,mt\rangle$
			\item[] > (1)
			\item[] ...
			\item[] On voit comment la substitution s'applique sur cette partie.
			\item[] CEK : $\langle\langle f,\{\langle f,\langle(\lambda y.(+$ $y$ $y)),\emptyset\rangle\rangle,\langle x,\langle\ulcorner 1\urcorner,\emptyset\rangle\rangle\}\rangle,\langle arg,\langle x,\{\langle f,\langle(\lambda y.(+$ $y$ $y)),\emptyset\rangle\rangle,\langle x,\langle\ulcorner 1\urcorner,\emptyset\rangle\rangle\}\rangle,mt\rangle\rangle$
			\item[] > (2) 
			\item[] CEK : $\langle\langle(\lambda y.(+$ $y$ $y)),\emptyset\rangle,\langle arg,\langle x,\{\langle f,\langle(\lambda y.(+$ $y$ $y)),\emptyset\rangle\rangle,\langle x,\langle\ulcorner 1\urcorner,\emptyset\rangle\rangle\}\rangle,mt\rangle\rangle$
			\item[] ...
			\item[] CEK : $\langle\langle\ulcorner 2\urcorner,\emptyset\rangle,mt\rangle$
		\end{itemize}
		\medbreak
		
		L'exemple complet peut être retrouvé dans les \hyperref[CEK]{Annexes}.
	\end{ex}
	\newpage
	
	
	\paragraph{SECD Machine}
	
	La différence entre la machine CEK et SECD se situe dans la façon dont le contexte est sauvegardé pendant que les sous-expressions sont évaluées.\\
	En effet, dans la machine SECD le contexte est créé par un appel de fonction, quand tout est stocké dans $\widehat{D}$ pour laisser un espace de travail. Par contre pour la machine CEK, le contexte est créé quand on évalue une application ou un argument indépendamment de la complexité de celui-ci.
	\smallbreak 
	Dans les langages tels que Java, Pascal ou encore C la façon de faire de la machine SECD est plus naturelle. Par contre  dans les langages tels que $\lambda$-calculs, Scheme ou encore ML c'est la façon de faire de la machine CEK qui est la plus naturelle.
	\medbreak
	
	La machine SECD est composée d'une pile pour les valeurs ($\widehat{S}$), d'un environnement ($\widehat{\varepsilon}$) pour lier les variables $X$ à une valeur $\widehat{V}$, d'une chaîne de contrôle ($\widehat{C}$) et d'un dépôt ($\widehat{D}$). Les différentes définitions de ces éléments sont les suivantes :
	\smallbreak
	\begin{itemize}
		\item[] $\widehat{S} = \epsilon$ 
		\begin{itemize}
			\item[|] $\widehat{V}~\widehat{S}$
		\end{itemize}
		\item[] $\widehat{\varepsilon} =$ une fonction $\{\langle X,\widehat{V}\rangle,...\}$
		\item[] $\widehat{C}$ = $\epsilon$ 
		\begin{itemize}
			\item[|] $b~\widehat{C}$
			\item[|] $X~\widehat{C}$
			\item[|] $ap~\widehat{C}$
			\item[|] $prim_{o^{n}}~\widehat{C}$
			\item[|] $\langle X,\widehat{C}\rangle~\widehat{C}$
		\end{itemize}
		\item[] $\widehat{D}$ = $\epsilon$
		\begin{itemize}
			\item[|] $\langle\widehat{S},\widehat{\varepsilon},\widehat{C},\widehat{D}\rangle$
		\end{itemize}
		\item[] $\widehat{V} = b$
		\begin{itemize}
			\item[|] $\langle\langle X,\widehat{C}\rangle,\widehat{\varepsilon}\rangle$
		\end{itemize}
	\end{itemize}
	\bigbreak
	
	Une autre spécificité de la machine SECD vient de sa propre grammaire. En effet la machine SECD convertit la $\lambda$-expression par son propre langage. Le langage fonctionne avec des éléments simples comme des constantes, des variables, des fonctions et des commandes qui permettent de savoir ce que doit faire la machine. Voici les règles de conversion :
	\smallbreak
	
	\begin{itemize}
		\item[] $\textlbrackdbl b\textrbrackdbl _{secd}$ = b
		\item[] $\textlbrackdbl X\textrbrackdbl _{secd}$ = X
		\item[] $\textlbrackdbl (M_{1}$ $M_{2})\textrbrackdbl _{secd}$ = $\textlbrackdbl M_{1}\textrbrackdbl _{secd}$ $\textlbrackdbl M_{2}\textrbrackdbl _{secd}$ ap
		\item[] $\textlbrackdbl (o^{n}$ $M_{1}...M_{n})\textrbrackdbl _{secd}$ = $\textlbrackdbl M_{1}\textrbrackdbl _{secd}$ $...$ $\textlbrackdbl M_{n}\textrbrackdbl _{secd}$ $prim_{o^{n}}$
		\item[]  $\textlbrackdbl(\lambda X.M)\textrbrackdbl _{secd}$ =  $\langle X,\textlbrackdbl M\textrbrackdbl _{secd}\rangle$
	\end{itemize}
	\bigbreak
	
	
	Cette machine doit être la plus simple à comprendre dans son fonctionnement :
	\begin{itemize}
		\item[] - Si elle a une constante, elle la stocke dans la pile. On peut dire qu'elle la garde en attente de l'utiliser pour une commande. 
		\item[] - Si elle a une variable, elle prend sa substitution dans l'environnement et la stocke dans la pile comme une constante.
		\item[] - Si elle une abstraction, elle crée ce qu'on appelle une fermeture. C'est-à-dire qu'on va lier l'abstraction avec l'environnement. Ce processus permet de mettre en attente l'évaluation de l'expression présente dans l'abstraction. elle stocke la fermeture dans la pile comme une constante.
		\item[] - Si elle a une commande $ap$, on effectue une application sur les deux éléments de tête de la pile. Cette application met en attente l'expression principale pour se concentrer sur une sous-expression. Pour cela, la machine fait une sauvegarde d'elle-même avant et la stocke dans le dépôt.
		\item[] - Si elle a une commande $prim_{o^{n}}$, on effectue l'opération sur les $n$ premiers éléments de la pile.
		\item[] - Si elle a rien :
		\begin{itemize}
			\item[] - elle a une sauvegarde dans le dépôt, elle reprend cette sauvegarde.
			\item[] - elle n'a pas de sauvegarde, elle a fini son travail.
		\end{itemize}
	\end{itemize}
	\bigbreak
	
	Les règles qui définissent la machine SECD sont les suivantes :
	\smallbreak
	\begin{enumerate}
		\item $\langle\widehat{S},\widehat{\varepsilon},b$ $\widehat{C},\widehat{D}\rangle 
		~~~~~~~~~~~~~~~~~~~~~~~~\longmapsto_{secd}~~~
		\langle b$ $\widehat{S},\widehat{\varepsilon},\widehat{C},\widehat{D}\rangle$
		
		\item $\langle\widehat{S},\widehat{\varepsilon},X$ $\widehat{C},\widehat{D}\rangle 
		~~~~~~~~~~~~~~~~~~~~~~~\longmapsto_{secd}~~~
		\langle \widehat{V}$ $\widehat{S},\widehat{\varepsilon},\widehat{C},\widehat{D}\rangle$ où $\widehat{V} = \varepsilon(X)$
		
		\item $\langle\widehat{S},\widehat{\varepsilon},\langle X,C'\rangle$ $\widehat{C},\widehat{D}\rangle ~~~~~~~~~~~~~~~~~\longmapsto_{secd}~~~
		\langle\langle\langle X,C'\rangle,\varepsilon\rangle$ $\widehat{S},\widehat{\varepsilon},\widehat{C},\widehat{D}\rangle$
		
		\item $\langle\widehat{V}$ $\langle\langle X,C'\rangle,\varepsilon'\rangle$ $\widehat{S},\widehat{\varepsilon},ap$ $\widehat{C},\widehat{D}\rangle 
		~~~\longmapsto_{secd}~~~
		\langle\epsilon,\varepsilon'[X \leftarrow \widehat{V}],C',\langle\widehat{S},\widehat{\varepsilon},\widehat{C},\widehat{D}\rangle\rangle$
		
		\item $\langle\widehat{V}$ $\widehat{S},\widehat{\varepsilon},\emptyset,\langle\widehat{S'},\widehat{\varepsilon'},\widehat{C'},\widehat{D}\rangle\rangle
		~~~~~~~~~~\longmapsto_{secd}~~~
		\langle \widehat{V}$ $\widehat{S'},\widehat{\varepsilon'},\widehat{C'},\widehat{D}\rangle$
		
		\item $\langle b_{1}$ $...$ $b_{n}\widehat{S},\widehat{\varepsilon},prim_{o^{n}}$ $\widehat{C},\widehat{D}\rangle
		~~~~~~~\longmapsto_{secd}~~~
		\langle \widehat{V}$ $\widehat{S},\widehat{\varepsilon},\widehat{C},\widehat{D}\rangle$ où $\widehat{V} = \delta(o^{n},b_1,...b_{n})$
	\end{enumerate}
	\bigbreak
	
	
	la machine SECD peut s'arrêter dans trois états différents:
	\begin{itemize}
		\item[-] Soit on a une \textbf{constante b} telle que $\langle \epsilon,\emptyset,\textlbrackdbl M\textrbrackdbl_{secd},\epsilon\rangle \twoheadrightarrow_{secd} \langle b,\widehat{\varepsilon},\epsilon,\epsilon\rangle$;
		\item[-] Soit on a une \textbf{fonction} telle que $\langle \epsilon,\emptyset,\textlbrackdbl M\textrbrackdbl_{secd},\epsilon\rangle \twoheadrightarrow_{secd} \langle\langle\langle X,\widehat{C}\rangle,\widehat{\varepsilon'}\rangle,\widehat{\varepsilon},\epsilon,\epsilon\rangle$;
		\item[-] Sinon on a un \textbf{état inconnu} soit une \textbf{erreur}.
	\end{itemize}
	\bigbreak
	
	\begin{ex}
		Voyons sur un exemple les avantages de cette machine. Un exemple étant assez long, on s'intéresse à certaines parties. L'exemple complet est disponible dans les \hyperref[SECD]{Annexes}. 
		\\
		On teste la machine sur la $\lambda$-expression suivante : $(((\lambda f.\lambda x.f$ $x)$ $\lambda y.(+$ $y$ $y))$ $\ulcorner 1\urcorner)$ .
		\bigbreak
		
		\begin{itemize}
			\item[] On passe la conversion, utile mais pas intéressante.
			\item[] Conversion : $\textlbrackdbl(((\lambda f.\lambda x.f$ $x)$ $\lambda y.(+$ $y$ $y))$ $\ulcorner 1\urcorner)\textrbrackdbl_{secd}$
			\item[] ...
			\item[] Conversion : $\langle f,\langle x,f$ $x$ $ap\rangle\rangle$ $\langle y,y$ $y$ $prim_{+}\rangle$ $ap$ $\ulcorner 1\urcorner$ $ap$
			\item[] SECD Machine : $\langle\epsilon,\emptyset,\langle f,\langle x,f$ $x$ $ap\rangle\rangle$ $\langle y,y$ $y$ $prim_{+}\rangle$ $ap$ $\ulcorner 1\urcorner$ $ap,\epsilon\rangle$ 
			\item[] ...
			\item[] On voit comment l'application est traitée
			\item[] SECD : $\langle\langle\langle y,y$ $y$ $prim_{+}\rangle,\emptyset\rangle$ $\langle\langle f,\langle x,f$ $x$ $ap\rangle\rangle,\emptyset\rangle,\emptyset,ap$ $\ulcorner 1\urcorner$ $ap,\epsilon\rangle$
			\item[] > (4)
			\item[] SECD : $\langle\epsilon,\emptyset[f \leftarrow \langle\langle y,y$ $y$ $prim_{+}\rangle,\emptyset\rangle],\langle x,f$ $x$ $ap\rangle,\langle\epsilon,\emptyset,\ulcorner 1\urcorner$ $ap,\epsilon\rangle\rangle$
			\item[] SECD : $\langle\epsilon,\{\langle f,\langle\langle y,y$ $y$ $prim_{+}\rangle,\emptyset\rangle\rangle\},\langle x,f$ $x$ $ap\rangle,\langle\epsilon,\emptyset,\ulcorner 1\urcorner$ $ap,\epsilon\rangle\rangle$
			\item[] >  (3)
			\item[] 
			\item[] On voit l'intérêt de la sauvegarde.
			\item[] SECD : $\langle\langle\langle x,f$ $x$ $ap\rangle,\{\langle f,\langle\langle y,y$ $y$ $prim_{+}\rangle,\emptyset\rangle\rangle\}\rangle,\{f,\langle\langle y,y$ $y$ $prim_{+}\rangle,\emptyset\rangle\},\emptyset,\langle\epsilon,\emptyset,\ulcorner 1\urcorner$ $ap,\epsilon\rangle\rangle$
			\item[] > (5)
			\item[] SECD : $\langle\langle\langle x,f$ $x$ $ap\rangle,\{\langle f,\langle\langle y,y$ $y$ $prim_{+}\rangle,\emptyset\rangle\rangle\}\rangle,\emptyset,\ulcorner 1\urcorner$ $ap,\epsilon\rangle$
			\item[] ...
			\item[] On voit comment est gérée l'opération
			\item[] SECD : $\langle\ulcorner 1\urcorner$ $\ulcorner 1\urcorner,\{\langle y,\ulcorner 1\urcorner\rangle\},prim_{+},\langle\epsilon,\{\langle f,\langle\langle y,y$ $y$ $prim_{+}\rangle,\emptyset\rangle\rangle,\langle x,\ulcorner 1\urcorner\rangle\} ,\emptyset,\langle\epsilon,\emptyset,\epsilon,\epsilon\rangle\rangle\rangle$
			\item[] > (6)
			\item[] SECD : $\langle\ulcorner 2\urcorner,\{\langle y,\ulcorner 1\urcorner\rangle\},\emptyset,\langle\epsilon,\{\langle f,\langle\langle y,y$ $y$ $prim_{+}\rangle,\emptyset\rangle\rangle,\langle x,\ulcorner 1\urcorner\rangle\} ,\emptyset,\langle\epsilon,\emptyset,\epsilon,\epsilon\rangle\rangle\rangle$
			\item[] > (5)
			\item[] SECD : $\langle\ulcorner 2\urcorner,\{\langle f,\langle\langle y,y$ $y$ $prim_{+}\rangle,\emptyset\rangle\rangle,\langle x,\ulcorner 1\urcorner\rangle\} ,\emptyset,\langle\epsilon,\emptyset,\epsilon,\epsilon\rangle\rangle$
			\item[] > (5)
			\item[] SECD : $\langle\ulcorner 2\urcorner,\emptyset,\epsilon,\epsilon\rangle$
		\end{itemize}
	\end{ex}
	\newpage
	
	
	
	\section{Programmation réactive}
	
	\paragraph{Explication formelle}
	En informatique, la programmation réactive est un paradigme de programmation déclarative qui concerne les flux de données et la propagation du changement. Avec ce paradigme, il est possible d’exprimer facilement des flux de données statiques (par exemple, des tableaux) ou dynamiques (par exemple, des émetteurs d’événements) et également de signaler l’existence d’une dépendance inférée au sein du modèle d’exécution associé, ce qui facilite la propagation automatique des données modifiées.
	\medbreak
	
	\paragraph{Historique} La programmation réactive a été portée jusqu'à nos jours à travers différents langages, un des plus vieux est l'\textbf{ESTEREL}. ESTEREL est un langage de programmation développé dans les années 80 par une équipe de chercheurs des Mines de Paris et de l’INRIA. Il a initialement été conçu pour la programmation de robots industriels et pour la simulation de circuit électrique. La programmation réactive s'est diversifiée en s'implantant soit dans des langages déjà existant comme le C, le SCHEME ou encore le JAVA via l'extension \textbf{Fair Threads} (présentée dans \hyperref[FT]{[4]} datant de 2001) soit en créant un tout nouveau langage de programmation comme le \textbf{SL} (présenté dans \hyperref[SL]{[5]} datant de 1995) ou encore \textbf{Icobj} (présenté dans \hyperref[IJ]{[6]} datant de 1996).
	\medbreak
	
	Le framework \textbf{Fair Threads} est une implantation de la programmation réactive dans différents langages. Je me suis intéressé à l'implantation java. Ce langage se base sur la notion de \textit{fair thread}, basiquement ce sont des threads qui fonctionnent par concurrence coopérative (expliquée plus bas). Cependant il y a une forme de préemption via un planificateur qui donne les mêmes droits à tous. Son implantation est déterministe et portable. On peut remarquer cependant que le bon fonctionnement de la machine va beaucoup dépendre du développeur car il va devoir rendre ces threads coopératifs.
	\medbreak
	
	Le langage synchrone \textbf{SL} est, comme dit plus haut, basé sur le langage ESTEREL. Son but est de régler le problème de causalité présent dans le ESTEREL. Le problème venait de savoir si oui ou non un signal est absent. Dans l'instant courant on ne peut pas être sûr qu'il ne va pas être émis donc ESTEREL se basait sur une hypothèse. Le SL règle le problème en attendant la fin de l'instant courant pour dire si un signal est émis ou non. 
	\medbreak
	
	Le langage \textbf{Icobj} est un langage assez atypique. En effet, il n'a pas de syntaxe car il est entièrement graphique et il possède une sémantique simple basée sur le Reactive script. De plus, il n'est pas compilé mais interprété directement. Il fonctionne comme les autres langages de programmation réactif : il peut fonctionner de façon séquentielle, parallèle ou encore dans une boucle. Il fonctionne aussi avec un système d'événement qui permet une bonne communication. 
	\bigbreak
	
	
	Il y a de nombreuses implantations dont je n'ai pas parlé. Si vous souhaitez plus d'informations voici le un lien des recherches de Frédéric Bussinot : http://www-sop.inria.fr/mimosa/Frederic.Boussinot/. Ses recherches se focalisent sur la programmation réactive, tous les langages précédemment cités dans l'historique viennent de ses articles.
	\bigbreak


  	\paragraph{Le cas étudié} Chaque implantations travaillent un aspect de la programmation réactive pour une utilisation spécifique. Nous n'allons pas déroger à cette remarque en travaillant sur un aspect de la programmation réactive : la \textbf{programmation réactive synchrone concurrente}. Premièrement, on va expliquer tous ces termes.
	\begin{itemize}
		\item[] - \textbf{Synchrone} signifie que les informations seront obtenues de manière immédiate au contraire de la programmation réactive asynchrone qui attend un "instant" avant de distribuer les valeurs. 
		\item[] - \textbf{Concurrent} signifie que plusieurs processus vont se dérouler durant le même instant logique. Il existe deux sous-catégories à la concurrence :
		\begin{enumerate}
			\item \textbf{Concurrence coopérative :} les processus vont régulièrement "laisser la main aux autres"
			\item \textbf{Concurrence préemptive :} le système va "donner un temps de parole"
		\end{enumerate}
	\end{itemize}
	\medbreak
	
	Dans notre machine abstraite, on utilise un peu des deux principes en laissant les processus fonctionner seuls mais le système garde la possibilité de gérer les processus bloqués. On va voir à travers un exemple comment fonctionne la programmation réactive synchrone concurrente coopérative.
	\newpage
	
	
	
	\paragraph{Le cas de Réactive ML}
	Le langage Reactive ML utilise le modèle de programmation de concurrence coopérative. C'est-à-dire que les différents processus vont fonctionner en même temps (de façon hypothétique) tout en laissant la main pour que tout le monde puissent fonctionner. 
	\medbreak
	
	La spécificité du Reactive ML est son analyse qui va détecter les erreurs de concurrence avant de le tester via une sémantique spéciale. L'analyse est découpée en 2 sous-analyses :
	\begin{itemize}
		\item[] - \textbf{statique} : système de type et d'effet
		\item[] - \textbf{réactive} : détecter les erreurs de concurrence
	\end{itemize}
	\medbreak
	
	Cette méthode d'analyse syntaxique permet d'avoir une implantation séquentielle efficace ainsi qu'aucune création de problème de parallélisme. En revanche, la réactivité du programme est entièrement déléguée au développeur.
	\medbreak
	
	Le modèle de programmation réactif synchrone définit une notion de temps logique, appelé tick. On peut voir le fonctionnement du programme comme une succession de ticks qui lui permet de faire avancer ses processus. De là, on peut définir une condition nécessaire et suffisante pour vérifier la réactivité d'un programme : 
	\\\textbf{Un programme est r\'{e}actif si son ex\'{e}cution fait progresser les instants logiques.}
	\medbreak
	
	\begin{ex}
		Voici un exemple de programme qui contient une erreur de réactivité.
		\begin{enumerate}
			\item let process clock timer s =
			\item $\quad$ let time = ref(Unix.gettimeofday()) in
			\item $\quad$ loop
			\item $\quad$ $\quad$ let time' = Unix.gettimeofday() in
			\item $\quad$ $\quad$ if time' -. !time >= timer
			\item $\quad$ $\quad$ then(emit s(); time := time')
			\item $\quad$ end 
		\end{enumerate}
		\bigbreak


		Le problème ici est que le contenu de la boucle peut s'effectuer instantanément alors qu'il faudrait attendre un instant logique pour l'exécuter. Par conséquent, on doit ajouter une \textbf{pause entre les lignes 6 et 7}. Le nouveau programme sera donc :
		\smallbreak
		\begin{enumerate}
			\item let process clock timer s =
			\item $\quad$ let time = ref(Unix.gettimeofday()) in
			\item $\quad$ loop
			\item $\quad$ $\quad$ let time' = Unix.gettimeofday() in
			\item $\quad$ $\quad$ if time' -. !time >= timer
			\item $\quad$ $\quad$ then(emit s(); time := time')
			\item $\quad$ $\quad$ pause
			\item $\quad$ end 
		\end{enumerate}
	\end{ex}
	\bigbreak
	
	
	L'analyse étant spéciale, l'écriture du programme a des règles strict par exemple :
	Une \textbf{condition suffisante} pour qu'un \textbf{processus r\'{e}cursif soit r\'{e}actif} est qu'il y ait \textbf{toujours} \textbf{un instant logique entre l'instanciation du processus et l'appel r\'{e}cursif}.
	\bigbreak
	
	
	Le reste de l'article rentre beaucoup plus dans les détails avec l'analyse syntaxique qui prend en compte la réactivité du langage ce qui permet de vérifier la réactivité du programme très rapidement. Cette partie nous intéresse moins car on ne va pas travailler sur l'analyse mais sur la méthode d'exécution mais si cela vous intéresse vous pouvez retrouver cet article dans la \hyperref[biblio]{bibliographie}.
	
	
	\chapter{Langage fonctionnel réactif}\label{SECDConc4}
	
	Le but est de réutiliser une des machines étudiées et de la rendre réactive. Les premières machines sont trop simple pour être utilisées. Restent la machine CEK et la machine SECD. Cependant il y a une contrainte qui va réussir à les départager. En effet, il faut pouvoir incorporer les ajouts facilement. La machine SECD remplit ce critère via la composition de la chaîne de contrôle : des éléments simples et des commandes. Nous utiliserons donc la machine SECD comme base.
	\medbreak
	
	Mes encadrants m'ont donné des ajouts à faire par petites parties afin de structurer mon avancé. Je vais donc redonner les ajouts pour chaque partie ainsi que l'explication de leurs implantations.
	\bigbreak
	
	
	\section{Machine réactive pure}
	
	\subsection{Description informelle du langage}
	
	Avant tout développement sur l'implantation il faut pouvoir bien cerner le principe de la réactivité synchrone avec concurrence. Le but est de créer un "dialogue" entre plusieurs processus gérés par la machine. 
	\medbreak
	
	En arrondissant les angles, on peut voir ça comme une discussion. Je m'explique, la discussion c'est notre machine, on a une personne que l'on va nommer Monsieur X. Il représente notre processus principal. Son but est d'initier la discussion puis d'y participer.
	\smallbreak 
	Monsieur X va commencer a parler en introduisant des personnes, ce sont nos processus secondaires. À noter que tous les processus peuvent introduire un nombre non limité de processus. Lorsque Monsieur X va finir de parler ou lorsqu'il attendra une information pour continuer à parler (ce point est important) il va passer son tour. Il devient un processus commun. Un autre processus prend le relais et ainsi de suite.
	\smallbreak
	Pendant qu'une personne parle, il peut donner une information qui sera utilisée par un autre et donc qui se remettra dans la discussion. Ces informations seront représentées par des signaux. Quand tout le monde a fini de parler, c'est la fin de la discussion ce qui représente la fin du traitement de la machine.
	\medbreak
	
	Un point qu'il faut bien comprendre est que l'absence d'une information (d'un signal) est aussi importante que sa présence. Un exemple naïf, si vous demandez à quelqu'un s'il dort une réponse donne une information aussi importante qu'une absence de réponse.
	\medbreak
	
	Un autre point délicat est la fin d'un instant logique. Si on reprend l'exemple précédent, si on attend une réponse d'une personne qui dort, on peut attendre longtemps. Pour savoir si on nous répond ou pas, on attend un instant et on en déduit que l'on ne nous répondra pas. Pour la machine c'est pareil. L'instant courant est lorsque tout le monde discute, quand plus personne ne parle , et au moins une personne attend une information, c'est la fin de l'instant courant. On passe à l'instant suivant et ceux qui attendaient une information spécifique vont exhiber un autre argument et la discussion recommence jusqu'à ce que plus personne n'aient d'arguments.
	\medbreak
	
	Le principe étant expliqué, nous pouvons rentrer dans les détails. L'idée est d'avoir plusieurs machines SECD qui se parlent donc il faut créer une structure plus large qui peut les stocker. On part cependant d'une seule chaîne de contrôle donc il faut pouvoir créer ces processus. Ils sont ce que l'on va appeler des \textbf{threads}.
	\newpage
	
	
	
	\subsection{Description formelle du langage}
	
	\paragraph{Un Thread}
	
	\subparagraph{Qu'est-ce qu'un thread ?}
	Un thread est l'équivalent d'un processus, il a sa propre pile d'éxécution mais peut récupérer des informations sur une mémoire partagée. En simplifiant, si on fait un lien avec la machine SECD, on peut dire que chaque thread est une machine SECD et que toutes ces machines SECD vont communiquer entre elles.
	
	\subparagraph{Quelle forme doit avoir un thread ?} 
	Un thread est comme dit plus haut, une machine SECD en soi donc elle va prendre cette forme c'est-à-dire que l'on va avoir $T~=~\langle S,E,C,D\rangle$. Pour l'instant c'est tout ce qui nous est nécessaire dans le thread.
	
	\subparagraph{Comment les stocker ?}
	Pour les stocker, on va se demander si l'on veut un ordre ou pas dans notre stockage. Il faut noter un point important pour faire une machine fonctionnelle, il vaut mieux avoir une machine déterministe.
	\medbreak
	
	\textit{Machine déterministe :} Une machine est déterministe si pour une entrée donnée, on a une seule sortie possible et un unique "chemin" possible dans la machine, c'est-à-dire une suite unique de transitions possibles.
	\medbreak
	
	Pour éviter de la rendre non déterministe, on va opter pour une file d'attente $TL$ telle que $\forall~tl \in Tl~:~tl = T$.
	\bigbreak
	
	\paragraph{Un Signal} 
	
	\subparagraph{Qu'est-ce qu'un signal ?}
	Un signal est une information que l'on transmet entre chaque thread. Pour les bases, tout ce qui va nous intéresser est la présence ou l'absence d'un signal. C'est grâce à cela qu'un thread va pouvoir agir en conséquence d'un autre. 
	
	\subparagraph{Quelle forme doit avoir un thread ?} 
	Dans un premier temps, un signal sera constitué de deux informations : 
	\begin{enumerate}
		\item Est-il initialisé ?
		\item Est-il émis ?
	\end{enumerate}
	La forme d'un signal dans notre machine est développée dans la partie \textbf{L'initialisation d'un signal}.
	
	\subparagraph{Comment les stocker ?}
	Comme pour les threads, on doit se poser la question de la structure que l'on veut mais aussi de si l'on veut un ordre ou non. Plusieurs possibilités ont été explorées et sont directement liées, là aussi, on développe ce point dans la partie \textbf{L'initialisation d'un signal}. Mais dans tous les cas on va devoir créer une liste qui va stocker au moins le fait qu'il est émis, il faudra donc forcément un élément que l'on va nommer $SI$ qui sera une liste prévue pour stocker les signaux.
	\bigbreak 
	
	
	\paragraph{Le Spawn} 
	
	\subparagraph{Comment créer un thread ?}
	Pour créer ce que l'on va appeler \textbf{des threads}, on va devoir prendre dans la chaîne de contrôle une partie de celle-ci. Pour cela on va requérir à la commande $Spawn$. Elle va nous servir à délimiter la partie à prendre. Deux versions de cette commande existent, la première peut être retrouvée dans la plupart des versions intermédiaires de la machine et la seconde a été proposée par un de mes encadrants et elle est présente dans les deux versions présentées.
	\smallbreak
	\begin{enumerate}
		\item $bspawn~C~espawn$ : la machine prend $Spawn~C$ et le convertit en deux délimiteurs qui servent à entourer la partie de la chaîne de contrôle que l'on veut prendre. Le gros défaut de cette version bien qu'utilisable est sa forme. On crée une structure que doit reconnaître la machine alors que la machine SECD attend soit des éléments simples soit une commande.
		\item $\langle X,C\rangle~spawn$ : ici la machine convertit le $Spawn~C$ en une abstraction et une commande $spawn$. L'abstraction permet d'encapsuler la partie de la chaîne de contrôle que l'on veut. Grâce à cela la machine n'essaie pas de l'évaluer. $spawn$ est juste une commande, donc plus logique dans le fonctionnement de la machine. Elle permet de comprendre que la fermeture présente dans la pile est ce que l'on veut pour créer notre thread. 
	\end{enumerate}
	\newpage
	
	
	
	\paragraph{L'initialisation d'un signal}
	
	\subparagraph{Comment créer un signal ?}
	Pour créer un signal, on va devoir utiliser une commande $Signal~s~in~t$ avec un signal $s$ et une expression $t$. Cette commande a été modifiée dans les dernières versions. Voici une énumération du travail fait autour de cette commande.
	\smallbreak
	\begin{enumerate}
		\item $Signal~s~in~t$ : l'identifiant du signal est donné et va être initialisé seulement pour l'expression $t$. Cette version est la plus complexe car il faut stocker énormément d'informations. En effet, il faut stocker l'initialisation du signal pour le thread courant mais aussi pour une partie précise de la chaîne de contrôle du thread courant. Pour cela, deux versions ont été créées :
		\begin{enumerate}
			\item On utilise le principe de la sauvegarde. Simplement expliqué, quand la machine SECD applique une valeur sur une abstraction, elle fait une sauvegarde d'elle-même pour mettre en pause le travail sur la partie principale et se mettre à travailler sur une partie secondaire. Si on reprend le même principe, on peut stocker l'initialisation du signal dans l'environnement après l'avoir sauvegardé. L'élément $SI$ nommé plus haut sera donc de la forme $SI=\{s,...\}$ telle que $s$ représente un signal émis.
			
			\begin{ex}
				Si on prend $\langle s,C'\rangle$ la version convertie de $Signal~s~in~t$ on a : 
				\\$\langle S,E,\langle s,C'\rangle C,D,SI\rangle \longrightarrow \langle \emptyset,\emptyset~[init \leftarrow s],C',\langle S,E,C,D\rangle,SI\rangle$  
			\end{ex}
			
			Le problème de cette version est qu'il provoque un stockage double des signaux dans la machine à cause des commandes à venir. En effet, on va garder l'initialisation dans l'environnement et l'émission dans l'élément $SI$. Ce n'est pas optimal.
			
			\item On utilise la sauvegarde mais différemment. En effet on va faire une sauvegarde comme pour la première version cependant on ne met pas l'initialisation dans l'environnement mais directement là où l'on voudra stocker plus tard via un booléen. On va créer une variante de la sauvegarde de la machine SECD, dans le dépôt, de la forme $\langle s,\langle S,E,C,D\rangle\rangle$. Ce qui va nous permettre de savoir quand sortir de l'expression pour laquelle on avait initialiser le signal. La structure $SI$ ici prend une autre forme, on a $SI=\{\langle s,init,emit\rangle\}$ telle qu'un signal $s$, un booléen représentant l'initialisation $init$ et un booléen représentant l'émission du signal $emit$.
			
			\begin{ex}
				Si on prend $\langle s,C'\rangle$ la version convertie de $Signal~s~in~t$ on a : 
				\\$\langle S,E,\langle s,C'\rangle C,D,SI\rangle \longrightarrow \langle \emptyset,\emptyset,C',\langle s,\langle S,E,C,D\rangle\rangle,SI~\langle s,true,false\rangle \rangle$ 
			\end{ex}
			
			Cette version est assez efficace mais reste lourde dans la machine au niveau du stockage et la façon dont cette commande est convertie crée le même problème que pour la première version du $Spawn$:  on n'est pas censé avoir de structure à traiter dans la machine.
		\end{enumerate}
		
		\item $Init~s$ : l'identifiant du signal est donné et va être initialisé pour tous les éléments de la machine. Cette version va drastiquement simplifier le fonctionnement de la machine car on n'a plus besoin de limiter l'action de l'initialisation à une partie de la chaîne de contrôle ni à un thread en particulier. Simplement, on met le signal dans le stockage des signaux. Ce fait sera nécessaire et suffisant pour savoir qu'il est initialisé. La structure de $SI$ va donc être de la forme $\langle s,emit\rangle$ avec un signal $s$ et un booléen représentant l'émission du signal $emit$.
		
		\begin{ex}
			 Si on prend $s~Init$ la version convertie de $Signal~s~in~t$ on a : 
			\\$\langle s~S,E,Init~C,D,SI\rangle \longrightarrow \langle S,E,C,D,SI~\langle s,false\rangle \rangle$ 
		\end{ex}
		
		\item $Init$ : l'identifiant du signal sera retourné par la machine, l'utilisateur ne lui donne plus l'identifiant. On créera l'identifiant en incrémentant le dernier identifiant de signal de un. Le reste est identique au fonctionnement du $Init~s$. Cette possibilité aura la même structure pour $SI$ que la précédente à l'exception que l'on va ajouter un ordre car il faudra créer des identifiants. Pur ce fait, on va toujours mettre en fin de la liste afin de pouvoir créer facilement un nouvel identifiant. Pour faire simple on utilisera une file.
		
		\begin{ex}
			 Si on prend $s~Init$ la version convertie de $Signal~s~in~t$ on a : 
			\\$\langle s~S,E,Init~C,D,SI\rangle \longrightarrow \langle S,E,C,D,SI~\langle s,false\rangle \rangle$ 
		\end{ex}
		
	\end{enumerate}
	\bigbreak
	
	
	\paragraph{La présence d'un signal}
	
	\subparagraph{Comment savoir si un signal est présent ?}
	\textit{Un signal est présent s'il est émis.}
	\smallbreak
	C'est ici que la notion de temps logique va nous être utile. Via l'initialisation d'un signal on sait que l'on a un booléen $emit$ pour savoir si un signal est émis. Le cas émis est simple. Cependant comment sait-on qu'il ne l'est pas ?
	\smallbreak
	\textit{Un signal est absent s'il n'est pas émis durant l'instant logique.}
	\smallbreak
	On a besoin de déterminer la fin d'un instant logique. Les différents threads vont s'éxécuter à la chaîne, la fin d'un instant sera lorsqu'aucun thread ne s'éxécute. Cependant certains vont tomber dans ce cas où ils devront attendre l'absence d'un signal. Cette contrainte prise en compte, on doit redéfinir la fin d'un instant logique comme la fin ou le blocage de tous les threads de la machine.
	\medbreak
	
	Dans notre machine on va devoir différencier les threads en attente de leurs tour et ceux en attente de l'émission d'un signal. Deux possibilités ont été étudiées :
	\begin{enumerate}
		\item On scinde la file d'attente de threads en deux avec d'un côté les threads en attente de leurs tour et de l'autre ceux en attente de l'émission d'un signal. On aurait $TL =\langle W,ST\rangle$ tel que :
		\begin{itemize}
			\item[] - $W$ une file des threads qui attendent leurs tour telle que $\forall w \in W~:~w = T$ 
			\item[] - $ST$ une liste des threads qui attendent un signal telle que $\forall st \in ST~:~st = \langle s,T\rangle$ avec un signal $s$ 
		\end{itemize}
		\medbreak
		
		Le problème de cette possibilité est la necéssité de stocker quel signal attend un thread pour chaque thread de $ST$. La deuxième possibilité résout ce problème.
		\item On ne touche pas $TL$ mais on va stocker les threads bloqués par un signal directement dans les informations de ce signal. Ce qui revient à modifier $SI$ telle que $SI = \langle s , \langle emit , ST \rangle\rangle$ avec un signal $s$, le booléen représentant l'émission $emit$ et une liste de threads $ST$ qui attendent l'émission de $s$.
	\end{enumerate}
	\medbreak
	
	La différenciation des threads faite, on peut tester la présence d'un signal. La commande a eu deux versions :
	\begin{enumerate}
		\item $\langle s,C',C''\rangle$ avec un signal $s$ et deux expressions $C'$ et $C''$ . Si vous avez bien suivi jusque là, vous aurez remarqué que les premières versions ont toujours le même problème récurrent : c'est une structure que l'on veut mettre dans une machine qui ne traite que des éléments simples et des commandes. Cette forme est donc utilisable mais n'est pas dans la logique de la machine de base.
		\item $s~\langle\langle X,C'\rangle~\langle\langle X,C''\rangle~present$ avec un signal $s$. Cette version parait plus compliquée, je m'en vais donc vous l'expliquer. On a un signal jusque là rien de bien étonnant. Après on a deux abstractions, elles vont nous servir de protection pour nos deux possibilités de notre présence car elle empêche la machine d'essayer de l'évaluer. On a utilisé cette même astuce pour la commande $Spawn$ plus haut. Pour finir il y a le mot $present$ qui sert de commande pour comprendre que l'on veut faire un test.
	\end{enumerate} 
	\bigbreak
	
	
	\subparagraph{Récapitulatif :} Si on reprend le tout, pour faire notre test de présence nous avons défini :
	\begin{itemize}
		\item[] - la forme de la commande : $s~\langle\langle X,C'\rangle~\langle\langle X,C''\rangle~present$ avec un signal $s$;
		\item[] - la présence d'un signal : \textit{un signal est présent s'il est émis dans l'instant courant};
		\item[] - l'absence d'un signal : \textit{un signal est absent s'il n'est pas émis durant tout l'instant courant};
		\item[] - la fin de l'instant courant : \textit{l'instant courant est fini quand plus aucun thread ne peut plus effectuer d'instruction};
		\item[] - une structure contenant les threads bloqués : $SI = \langle s , \langle emit , ST \rangle\rangle$ avec un signal $s$, le booléen représentant l'émission $emit$ et une liste de threads $ST$ qui attendent $s$.
	\end{itemize}
	\bigbreak
	\bigbreak
	
	
	
	
	\paragraph{Émettre un signal}
	
	Cette commande est sûrement la plus simple à mettre en place car tout a été fait en amont via les trois commandes précédentes. La forme de la commande $emit$ n'a pas beaucoup bougé, seulement deux versions existent :
	\begin{enumerate}
		\item $emit_{s}$ une forme inspirée de $prim_{o^{n}}$. Cependant la grosse erreur est quand mettant un signal $s$ en indice de la commande $emit$ on a l'impression qu'il y a une commande $emit$ par signal $s$ or l'émission est indépendante du signal qu'il émet.
		\item $s~emit$ avec un signal $s$. Celle-ci est privée de toute ambiguïté et s'intègre bien à la machine. 
	\end{enumerate}
	\medbreak
	
	Le faite d'émettre va impliquer deux choses dans notre machine :
	\begin{enumerate}					
		\item Notre booléen représentant l'émission présent dans les informations d'un signal sera mis à vrai
		\item Tous les threads présents dans le tuple du signal seront mis dans la file d'attente $TL$ 
	\end{enumerate} 
	\newpage
	
	
	\subsection{Sémantique de la machine abstraite}
	
	Maintenant que l'on a défini les nouvelles commandes et ce dont elles ont besoin pour fonctionner, il est temps de voir à quoi ressemble notre machine avec ces ajouts. On a gardé la base de la machine SECD en changeant les noms, plus précisément en enlevant les accents circonflexes et en changeant le nom de l'environnement par $E$ afin d'alléger l'écriture.
	\bigbreak
	
	
	\textbf{\textit{Soit $\langle T,TL,SI\rangle$ avec :}}
	
	\begin{itemize}
		\item[] $TL =$ \textbf{une file de threads telle que :} $\forall$ $tl \in TL$ $|$ $tl = T$ avec :
		\begin{itemize}
			\item[] $T =$ $\langle S,E,C,D\rangle$ \textbf{le thread courant avec :}
			\begin{itemize}
				\item[] $b,s,n$ = une constante ou un identifiant de signal (un entier)
				\item[] $V = b$	
				\begin{itemize}
					\item[|] $\langle\langle X,C' \rangle E\rangle$
				\end{itemize}
				\item[] $S =  \emptyset$ 
				\begin{itemize}
					\item[|] $V$ $S$
				\end{itemize}
				\item[] $E = \{...,\langle X,V\rangle,...\}$
				\item[] $C = \epsilon$								
				\begin{itemize}
					\item[|] $b~C$~~~~~~~~~~~~~~~~~~~~~~~~~~~(une constante ou un identifiant de signal)
					\item[|] $X~C$~~~~~~~~~~~~~~~~~~~~~~~~~~(une variable)
					\item[|] $\langle X,C'\rangle~C$~~~~~~~~~~~~~~~~~~~(une abstraction)
					\item[|] $ap~C$~~~~~~~~~~~~~~~~~~~~~~~~~(une application)
					\item[|] $prim_{o^{n}}~C$~~~~~~~~~~~~~~~~~~~(un opérateur)
					\item[|] $spawn~C$~~~~~~~~~~~~~~~~~~~~(créateur d'un nouveau thread)
					\item[|] $present~C$~~~~~~~~~~~~~~~~~~~(teste la présence d'un signal)
					\item[|] $init~C$~~~~~~~~~~~~~~~~~~~~~~~~(initialise un signal )
					\item[|] $emit~C$~~~~~~~~~~~~~~~~~~~~~~~(émet un signal)
				\end{itemize}
				\item[] D = $\emptyset$
				\begin{itemize}
					\item[|] $\langle S,E,C,D\rangle$~~~~~~~~~~~~~~~~(une sauvegarde liée à une application)
				\end{itemize}
			\end{itemize}	
		\end{itemize}
		\item[]
		\item[] \textbf{$SI =$ une liste de signaux telle que :} $\forall$ $si \in SI$ $|$ $si =$ $\langle s,\langle emit,ST\rangle\rangle$ avec :
		\begin{itemize}
			\item[] - \textbf{un identifiant de signal :} $s$
			\item[] - \textbf{un booléen représentant l'émission de ce signal :} $emit$
			\item[] - \textbf{la liste des threads bloqués par ce signal :} $ST$ avec $\forall st \in ST~:~st = T$
		\end{itemize}
	\end{itemize}
	\bigbreak
	\bigbreak
	
	
	
	
	\textbf{On va définir une règle pour simplifier les règles futures :} 
	\begin{center}
		$\dfrac{T \rightarrow T'}{\langle T,TL,SI\rangle \rightarrow \langle T',TL,SI\rangle}$
	\end{center}
	\bigbreak
	\bigbreak
	
	
	
	
	\textbf{\textit{Une suite de fonctions ont été écrites pour simplifier la lecture des règles. Les voici :}}
	\smallbreak
	\begin{itemize}
		\item[] $\iota(SI)$ une fonction qui prend l'identifiant du dernier signal créé, l'incrémente pour en créer un nouveau et retourne l'identifiant du signal créé avec la liste mise à jour.
		\begin{ex}
			2 cas sont possibles :
			\begin{enumerate}
				\item[] Si on initialise pour la première fois alors  $\iota(\{\}) =$ $(0 ,\{\langle 0,\langle false,\{\}\rangle\rangle\})$
				\item[] Sinon $\iota(\{...,\langle s,data\rangle\}) =$ $(s+1 ,\{...,\langle s,data\rangle,\langle s+1,\langle false,\{\}\rangle\rangle\})$ avec $data = \langle emit,ST\rangle$
			\end{enumerate}
		\end{ex}
		
		\item[] 
		
		\item[] $\varepsilon(s,SI)$ une fonction qui prend un signal $s$ et met à vrai son booléen représentant l'émission et retourne la liste de threads bloqués.
		\begin{ex}
			$\varepsilon(s,\{...,\langle s,\langle emit,ST\rangle\rangle,...\}) = (ST,\{...,\langle s,\langle vraie,\{\}\rangle\rangle,...\}$)
		\end{ex}
		\item[]\newpage 
		
		\item[] $SI(s)$ une fonction qui retourne le second élément du couple $\langle s,data\rangle$ avec $data = \langle emit,ST\rangle$.
		\begin{ex}
			$SI(s) = \langle emit,ST\rangle$
		\end{ex}
		\item[]  
		
		\item[] $\tau(SI)$ une fonction qui prend tous les éléments bloqués et les retourne en prenant en compte que le signal n'est pas émis, met à faux toutes les émissions et retourne le couple $\langle TL,SI \rangle$ avec une liste de threads $TL$ et $SI$ la liste des signaux modifiés. 
		\begin{ex}
			$\tau(SI) =$ $\forall$ $si \in SI$ : 
			\begin{itemize}
				\item[] - $\langle s,\langle true,\{\}\rangle\rangle~\rightarrow~\langle s,\langle false,\{\}\rangle\rangle$
				\item[] - $\langle s,\langle true,ST\rangle\rangle~\rightarrow~\langle s,\langle false,\{\}\rangle\rangle$ et 
				\\$\forall$ $st \in ST$ : $\langle I,\langle\langle X',C''\rangle, E\rangle$ $\langle\langle X,C'\rangle, E\rangle$ $s$ $S,E,present$ $C,D\rangle$ $\rightarrow$ $ \langle I,S,E,C''$ $C,D\rangle$ et on l'ajoute dans une liste temporaire TL.
			\end{itemize}
		\end{ex}
	\end{itemize}
	\bigbreak
	\bigbreak
	
	
	
	
	\textbf{\textit{Les éléments composant la machine étant expliqués, voici les nouvelles règles :}}
	\smallbreak
	\begin{enumerate}
		\item[] \textbf{Partie de base de la machine SECD :} Nous avons ajouté des règles mais la machine doit pouvoir traiter les mêmes informations que la machine de base donc on reprend directement les règles de la machine SECD. 
		\item[]
		\begin{itemize}
			\item[] \textbf{Constante ou Signal :} On a une constante, on la déplace dans la pile.
			\smallbreak
			$\langle S,E,n~C,D\rangle 
			\longrightarrow_{TTS} 
			\langle n~S,E,C,D\rangle$ où $n$ est une constante $b$ ou un identifiant de signal $s$
			\item[]
			
			\item[] \textbf{Substitution :} On a une variable, on substitue la variable par sa valeur liée dans l'environnement via la fonction $E$.
			\smallbreak
			$\langle S,E,X~C,D\rangle
			\longrightarrow_{TTS} 
			\langle V~S,E,C,D\rangle$ avec $E(X) = V$
			\item[]
			
			\item[] \textbf{Opération :} On a un opérateur dans la chaîne de contrôle et le nombre de constantes nécessaires dans la pile, via la fonction $\delta$ on retourne le résultat dans la pile.
			\smallbreak
			$\langle b_{n},...,b_{1}~S,E,prim_{o^{n}}~C,D\rangle
			\longrightarrow_{TTS} 
			\langle V~S,E,C,D\rangle$ avec $\delta(o^{n}~b_{1}...b_{n}) = V$
			\item[]
			
			\item[]  \textbf{Abstraction :} On a une abstraction, on crée une fermeture composée de l'abstraction et de l'environnement courant. On place la fermeture dans la pile.
			\smallbreak
			$\langle S,E,\langle X,C'\rangle$ $C,D\rangle
			\longrightarrow_{TTS} 
			\langle \langle\langle X,C'\rangle,E\rangle$ $S,E,C,D\rangle$
			\item[]
			
			\item[]  \textbf{Application :} On a une application, on sauvegarde dans le dépôt, on remplace la chaîne de contrôle et l'environnement par ceux présents dans la fermeture et on ajoute une substitution dans cet environnement.
			\smallbreak
			$\langle V~\langle\langle X,C'\rangle,E'\rangle~S,E,ap~C,D\rangle
			\longrightarrow_{TTS} 
			\langle \emptyset,E'[X \leftarrow V],C',\langle S,E,C,D\rangle\rangle$
			\item[] 
			
			\item[] \textbf{Récupération de sauvegarde :}  On n'a rien mais le dépôt comporte une sauvegarde donc on prend celle-ci.
			\smallbreak  
			$\langle V$ $S,E,\epsilon,\langle S',E',C,D\rangle\rangle
			\longrightarrow_{TTS} 
			\langle V$ $S',E',C,D\rangle$
		\end{itemize}
		\item[]
		
		
		
		\item[] \textbf{Partie pour la concurrence :} Voici les règles ajoutées dans le but de gérer les threads et les signaux. Ce sont les bases de la concurrence de la machine. 
		\item[]
		\begin{itemize}
			\item[]  \textbf{Création thread :} On crée un nouveau thread.
			\smallbreak 
			$\langle\langle\langle\langle X,C'\rangle, E\rangle~S,E,spawn~C,D\rangle,TL,SI\rangle 
			\longrightarrow_{TTS} 
			\langle\langle S,E,C,D\rangle,TL~\langle S,E,C',D\rangle,SI\rangle$
			\item[]
			
			\item[] \textbf{Initialisation signal :} On initialise le signal via la fonction $\iota$.
			\smallbreak 
			$\langle\langle S,E,init~C,D\rangle,TL,SI\rangle 
			\longrightarrow_{TTS}
			\langle\langle s~S,E,C,D\rangle,TL,SI'\rangle$
			avec $\iota(SI) = (s,SI')$
			\item[]	
			
			\item[] \textbf{Présence d'un signal :} On teste la présence d'un signal, via la fonction $SI$ on sait qu'il est émis donc on prend le premier choix.
			\smallbreak
			$\langle\langle \langle\langle X',C''\rangle,E\rangle~\langle\langle X,C'\rangle,E\rangle~s~S,E,present~C,D\rangle,TL,SI\rangle 
			\longrightarrow_{TTS} 
			\langle\langle S,E,C'~C,D\rangle,TL,SI\rangle$ 
			\\avec $SI(s) = \langle vraie,ST\rangle$
			\item[]
			
			
			\item[] \textbf{ Thread bloqué remplacé :} On teste la présence d'un signal, il n'est pas émis et il y a un thread dans la file d'attente donc on met le thread courant dans la liste de threads bloqués et on prend le thread en tête de la file.
			\smallbreak
			$\langle\langle \langle\langle X',C''\rangle,E\rangle~\langle\langle X,C'\rangle,E\rangle~s~S,E,present~C,D\rangle,\langle S',E',C''',D'\rangle$ $TL,SI\rangle 
			\\\longrightarrow_{TTS} 
			\langle\langle S',E',C''',D'\rangle,TL,SI'\rangle$ 
			\\avec $SI(s) = \langle faux,ST\rangle$
			et $SI'(s) = \langle faux,ST~\langle \langle\langle X',C''\rangle,E\rangle~\langle\langle X,C'\rangle,E\rangle~s~S,E,present~C,D\rangle\rangle$
			\item[]	
			
			\item[] \textbf{Thread bloqué non remplacé :} On teste la présence d'un signal, il n'est pas émis donc on met ce thread dans la liste de threads bloqués.
			\smallbreak 
			$\langle\langle \langle\langle X',C''\rangle,E\rangle~\langle\langle X,C'\rangle,E\rangle~s~S,E,C,D\rangle,\emptyset,SI\rangle 
			\longrightarrow_{TTS} 
			\langle\langle \emptyset,\epsilon,\emptyset,\emptyset\rangle,\emptyset,SI'\rangle$
			\\avec $SI(s) = \langle faux,ST\rangle$
			et $SI'(s) = \langle faux,ST~\langle\langle\langle X',C''\rangle,E\rangle~\langle\langle X,C'\rangle,E\rangle~s~S,E,present~C,D\rangle\rangle$
			\item[]
			
			\item[] \textbf{Émettre :} On émet un signal via la fonction $\varepsilon$.
			\smallbreak 
			$\langle\langle s~S,E,emit~C,D\rangle,TL,SI\rangle 
			\longrightarrow_{TTS}
			\langle\langle S,E,C,D\rangle,TL~ST,SI'\rangle$
			avec $\varepsilon(s,SI) = (ST,SI)'$
			\item[]
			
			\item[] \textbf{Récupération dans la file d'attente :} On n'a plus rien à traiter et on n'a aucune sauvegarde, du coup on change le thread courant par le thread en tête de la file d'attente.
			\smallbreak
			$\langle\langle S,E,\epsilon,\emptyset\rangle,\langle S',E',C,D\rangle~TL,SI\rangle 
			\longrightarrow_{TTS} 
			\langle\langle S',E',C,D\rangle,TL,SI\rangle$
			\item[]
			
			\item[] \textbf{Fin d'instant logique :} On n'a plus rien à traiter, on n'a aucune sauvegarde et on n'a plus rien dans la file d'attente, c'est la fin d'un instant logique.
			\smallbreak
			$\langle\langle S,E,\epsilon,\emptyset \rangle ,\emptyset,SI\rangle 
			\longrightarrow_{TTS} 
			\langle\langle S,E,\epsilon,\emptyset\rangle,TL,SI'\rangle$
			\\avec $\tau(SI) = (TL,SI')$ 
			\item[]
			
		\end{itemize}
		\item[] \textbf{Partie commune :} Quand on ajoute des règles, le plus gros risque est de créer des conflits avec les anciennes règles. Les conflits viennent de l'application et de la récupération de sauvegarde car $spawn$ et $emit$ ne retournent rien dans la pile donc il faut pouvoir continuer de faire fonctionner la machine avec ces deux cas. 
		\item[]
		\begin{itemize}
			\item[] \textbf{Application neutre :} On a une application sur rien, cela revient juste à ne rien faire.
			\smallbreak 
			$\langle S,E,ap~C,D\rangle
			\longrightarrow_{TTS} 
			\langle S,E,C,D\rangle$
			\item[]
			
			\item[] \textbf{Récupération de sauvegarde avec pile vide :}  On n'a rien mais le dépôt comporte une sauvegarde donc on prend celle-ci.
			\smallbreak  
			$\langle \emptyset,E,\epsilon,\langle S',E',C,D\rangle\rangle
			\longrightarrow_{TTS} 
			\langle S',E',C,D\rangle$
		\end{itemize}
	\end{enumerate}
	\bigbreak
	\bigbreak
	
	
	
\textbf{\textit{la machine TTS peut s'arrêter dans 4 états différents:}}
\smallbreak
\begin{itemize}
	\item[] - Soit on a une \textbf{constante} telle que 
	$\langle\langle \emptyset,\emptyset,\textlbrackdbl M\textrbrackdbl_{TTS},\emptyset\rangle,\emptyset,\emptyset\rangle 
	\twoheadrightarrow_{TTS} 
	\langle\langle b~S,E,\epsilon,\emptyset\rangle,\emptyset,SI\rangle$;
	\item[] 
	\item[] - Soit on a une \textbf{fonction} telle que
	$\langle\langle \emptyset,\emptyset,\textlbrackdbl M\textrbrackdbl_{TTS},\emptyset\rangle,\emptyset,\emptyset\rangle 
	\twoheadrightarrow_{TTS} 
	\langle\langle\langle X,C\rangle,E\rangle~S,E,\epsilon,\emptyset\rangle,\emptyset,SI\rangle$;
	\item[]
	\item[] - Soit on a \textbf{rien} telle que
	$\langle\langle \emptyset,\emptyset,\textlbrackdbl M\textrbrackdbl_{TTS},\emptyset\rangle,\emptyset,\emptyset\rangle 
	\twoheadrightarrow_{TTS} 
	\langle\langle\epsilon,E,\epsilon,\emptyset\rangle,\emptyset,SI\rangle$;
	\item[]  
	\item[] - Sinon on a un \textbf{état inconnu} : une \textbf{erreur} 
\end{itemize}
\bigbreak
\bigbreak
	
	
	
	Cette version des règles est la plus optimale car on a pris le meilleur de chaque possibilité. Cependant il faut savoir que des règles intermédiaires ont été créées, implantées et testées en OCaml. En effet je vais vous présenter 2 versions mais 3 versions des règles existent et 4 machines ont été implantées. On peut retrouver ces règles en Annexe si cela vous intéresse. Cela vous permettra de voir tout le chemin parcouru durant le stage. Un exemple de fonctionnement de la machine TTS se trouve dans les \hyperref[TTS]{Annexes}.
	\newpage
	
	
	\section{Le partage des valeurs dans la machine}
	
	\subsection{Description informelle du langage}
	Les signaux nous permettent déjà de communiquer entre les threads par la présence ou l'absence de ceux-ci. On va monter d'un cran en ajoutant la possibilité de partager des valeurs avec les signaux. Cela va créer un semblant de mémoire partagée.
	\medbreak
	
	\paragraph{Les valeurs partagées}
	
	\subparagraph{Quelles sont les contraintes pour accéder à ces valeurs ?}
	On a déjà spécifié que l'on voulait que les valeurs soient liées à un signal précis. On va ajouter une contrainte supplémentaire. Chaque thread aura sa propre liste de valeurs partagées. C'est-à-dire que pour accéder à une valeur il faudra connaître le signal et le thread. Cela pose un problème non traité précédemment qui est de différencier chaque thread. On va devoir ajouter un identifiant à $T$, c'est-à-dire que l'on aura $T = \langle I,S,E,C,D\rangle$ avec un entier qui va représenter l'identifiant $I$. Un problème se pose par rapport à cela : l'attribution des identifiants.
	\smallbreak
	Je m'explique, dans le cas des signaux ce n'était pas compliqué car on garde tous les signaux créés dans notre machine durant tout le processus donc on ne peut pas attribuer un identifiant qui a déjà été attribué avant. Or ici, quand un thread est fini on ne le garde pas. Même quand il est en cours, on peut le stocker dans deux endroits différents $TL$ et $ST$. On va utiliser un producteur d'identifiant dans notre machine. Pour cela, on va créer un nouvel élément $IP$ qui est un entier dans notre machine ce qui nous donne pour l'instant $\langle T,TL,SI,IP\rangle$.
	\medbreak
	
	Pour éviter des problèmes de déterminisme, on va devoir séparer les valeurs partagées en deux parties :
	\begin{enumerate}
		\item Une liste de valeurs courantes : c'est là que l'on va insérer les valeurs, on ne peut pas prendre dans cette liste, on peut la voir comme une liste tampon. Cela permet d'éviter le problème suivant : 
		\smallbreak
		Un thread veut accéder à une valeur, il n'y en a pas, il laisse sa place et le thread d'après met une valeur. Le problème vient du fait que la machine est dans le même instant logique donc le premier thread devrait pouvoir y accéder car hypothétiquement il fonctionne en même temps que le second.
		
		\item Une liste de valeurs partagées : c'est là que l'on va pouvoir prendre les valeurs, on ne peut pas insérer dans cette liste.
	\end{enumerate}
	\smallbreak
	Pour faire la transition entre la liste tampon et la liste de valeurs partagées on attend la fin d'un instant logique. Si le signal est émis, on transfère ces valeurs.
	\medbreak
	
	Quand on prend une valeur on ne spécifie pas laquelle car on ne le sait pas. On va contraindre à prendre les valeurs dans l'ordre et une unique fois. Pour cela, on va avoir un pointeur pour chaque thread. 
	
	\subparagraph{Comment stocker ces valeurs ?} 
	La liste des signaux est pour l'instant de la forme $SI~|~\forall~si \in SI~:~\langle s,\langle emit,ST \rangle\rangle$. On va se contenter d'expliquer pour cette forme car une autre forme à été faite durant le stage mais n'est pas si éloignée de celle-ci. Si vous avez envie de la voir malgré tout, elle se trouve en Annexe. Comme vu plus haut il nous faut deux listes : 
	\smallbreak
	\begin{enumerate}
		\item $CS$ la liste des valeurs courantes telle que $\forall~cs \in CS~:~cs = \langle id , CL \rangle$ avec l'identifiant du thread $id$ qui insère ces valeurs dans la liste des valeurs $CL$;
		
		\item $SSI$ la liste des valeurs partagées telle que $\forall~ssi \in SSI~:~ssi = \langle id,\langle CI,EL\rangle\rangle$ avec l'identifiant du thread $id$ qui a inséré ces valeurs à l'instant précédent. On a le couple $\langle CI,EL\rangle$ qui va nous servir à itérer. $EL$ est une liste d'identifiants qui représente la fin de l'itération dans cette liste. $CI$ est la liste des valeurs telle que $\forall~ci \in CI~:~ci = \langle b,IL\rangle$ avec une valeur $b$ et une liste d'identifiants qui représente une position possible de l'itérateur $IL$.
	\end{enumerate}
	\medbreak
	
	$SI = \forall~si \in SI~:~\langle s,\langle emit,ST \rangle\rangle$ devient $SI = \forall~si \in SI~:~\langle s,\langle emit,CS,SSI,ST \rangle\rangle$
	\bigbreak
	
	
	\paragraph{Accèder à une valeur}
	
	On veut ajouter une commande $get$. Elle va servir à accéder à une valeur. Pour pouvoir y accéder, on a besoin d'un signal et d'un identifiant. On aura donc $s~b~get$ avec un signal $s$ et un identifiant $id$. Cependant une question se pose, comment faire si on a pris toutes les valeurs ? 
	\smallbreak
	\begin{itemize}
		\item[] - On pourrait lever une erreur : cela est possible si on ajoute une gestion des erreurs mais sur cette version ce n'est pas le cas. Si cela vous intéresse une version existe en Annexe avec ce principe.
		\item[] - On demande un paramètre supplémentaire que l'on nommerait $n$ et qui servirait de neutre, c'est-à-dire si on a fini d'itérer, on retourne le neutre.
	\end{itemize} 
	\smallbreak
	On a donc une commande $get$ de la forme $s~id~n~get$ avec un signal $s$, l'identifiant du thread $i$  dont on veut une valeur de ces valeurs partagées et le neutre $n$. 
	\bigbreak
	
	
	\paragraph{Insérer une valeur}
	
	Il ne manque qu'à donner la possibilité d'insérer. Pour ça une commande $put$ va être nécessaire. Pour insérer, on a besoin de deux informations : le signal et l'identifiant du thread courant. On aura juste besoin de spécifier le signal, l'autre on l'aura directement. Ce qui nous donne $s~put$ avec un signal $s$. 
	\smallbreak
	Petit point à spécifier, quand on insère un élément on a pour but de le partager. Sachant cela et que l'émission d'un signal est nécessaire pour pouvoir partager ces valeurs, on réunit les commandes $emit$ et $put$. 
	\bigbreak
	
	
	
	
	\subsection{Sémantique de la machine abstraite}
	
	Ces deux commandes ajoutées engrangent énormément de changements. On va donc devoir redéfinir nos règles. 
	\bigbreak
	
	\textbf{\textit{Soit $\langle T,TL,SI,IP\rangle$ avec :}}
	
	\begin{itemize}
		\item[] $TL =$ \textbf{une file de thread telle que :} $\forall$ $tl \in TL~|~tl = T$ avec :
		\begin{itemize}
			\item[] $T = \langle I,S,E,C,D\rangle$ \textbf{le thread courant avec :}
			\begin{itemize}
				\item[] $b,s,n$ = une constante ou un identifiant de signal (un entier)
				\item[] $V = b$	
				\begin{itemize}
					\item[|] $\langle\langle X,C' \rangle E\rangle$
				\end{itemize}
				\item[] $I =$ un entier représentant l'identifiant du thread
				\item[] $S =  \emptyset$ 
				\begin{itemize}
					\item[|] $V~S$
				\end{itemize}
				\item[] $E = \{...,\langle X,V\rangle,...\}$
				\item[] $C = \epsilon$
				\begin{itemize}
					\item[|] $b~C$~~~~~~~~~~~~~~~~~~~~~~~~~~ (une constante ou un signal)
					\item[|] $X~C$~~~~~~~~~~~~~~~~~~~~~~~~~~(une variable)
					\item[|] $\langle X,C'\rangle~C$~~~~~~~~~~~~~~~~~~~(une abstraction)
					\item[|] $ap~C$~~~~~~~~~~~~~~~~~~~~~~~~~(une application)
					\item[|] $prim_{o^{n}}~C$~~~~~~~~~~~~~~~~~~~(un opérateur)
					\item[|] $spawn~C$~~~~~~~~~~~~~~~~~~~(créer d'un nouveau thread)
					\item[|] $present~C$~~~~~~~~~~~~~~~~~~(le test de présence d'un signal)
					\item[|] $init~C$~~~~~~~~~~~~~~~~~~~~~~~(initialise un signal)
					\item[|] $put~C$~~~~~~~~~~~~~~~~~~~~~~~~(insère une valeur dans un signal)
					\item[|] $get~C$~~~~~~~~~~~~~~~~~~~~~~~~(prends une valeurs dans un signal)
				\end{itemize}
				\item[] D = $\emptyset$
				\begin{itemize}
					\item[|] $\langle S,E,C,D\rangle$~~~~~~~~~~~~~~~~(une sauvegarde liée à une abstraction)
				\end{itemize}
			\end{itemize}	
		\end{itemize}
		
		\item[]
		\item[] \textbf{$SI =$ une liste de signaux telle que :} $\forall~si \in SI~:~si = \langle s,\langle emit,CS,SSI,TL\rangle\rangle$ avec :
		\begin{itemize}
			\item[] - \textbf{un identifiant de signal :} $s$
			\item[] - \textbf{un booléen représentant l'émission du signal :} $emit$
			\item[] - \textbf{un identifiant de thread :} $I$
			\item[] - \textbf{une liste des signaux courants telle que :} $\forall~cs \in CS~:~cs = \langle I,CL\rangle$ avec 
			\begin{itemize}
				\item[] - \textbf{une liste de constantes telle que :} $\forall~cl \in CL~:~cl = b$
			\end{itemize}
			
			\item[] - \textbf{la liste des signaux partagés telle que :} $\forall~ssi \in SSI~:~ssi = \langle I,\langle CI,IL\rangle\rangle$ avec 
			\begin{itemize}
				\item[] - \textbf{une liste d'identifiant de threads telle que :} $\forall~il \in IL~:~il = I$
				\item[] - \textbf{une liste de constante avec itérateur telle que :} $\forall~ci \in CI~:~ci = \langle b, IL\rangle$
			\end{itemize}
		\end{itemize}
		\item[]
		\item[] $IP =$ un entier servant à attribuer l'identifiant à un nouveau thread 
	\end{itemize}
	\bigbreak
	
	
	\textbf{\textit{Une suite de fonctions ont été écrites afin de simplifier la lecture des règles. Les voici :}}
	\smallbreak
	\begin{itemize}
		\item[] - $\iota(SI)$ une fonction qui prend l'identifiant du dernier signal créé, l'incrémente pour en créer un nouveau et retourne l'identifiant du signal créé avec la liste mise à jour.
		\begin{ex} $\empty$ \smallbreak 
			\begin{itemize}
				\item[] Si on initialise pour la première fois alors $\iota(\{\}) = (0 ,\{\langle 0,\langle false,\{\},\{\},\{\}\rangle\rangle\})$
				\item[] sinon $\iota(\{...,\langle s,data\rangle\}) = (s+1 ,\{...,\langle s,data\rangle,\langle s+1,\langle false,\{\},\{\},\{\}\rangle\rangle\})$ avec $data = \langle emit,CS,SSI,ST\rangle$
			\end{itemize}
		\end{ex}
		\item[]
		
		\item[] - $SI(s)$ une fonction qui retourne le 2nd élément du couple $\langle s,data\rangle$ avec $data = \langle emit,CS,SSI,ST\rangle$.
		\begin{ex}
			$SI(s) = \langle emit,CS,SSI,ST\rangle$
		\end{ex}
		\item[]  
		
		\item[] - $\tau(SI)$ une fonction qui prend la liste signaux, met les liste de valeurs courantes dans la liste des valeurs partagés si il est émis, prend en compte l'absence des signaux non émis et retourne le couple $\langle TL,SI \rangle$ avec une liste de threads $TL$ et $SI$ la liste des signaux modifiés 
		\begin{ex}
			$\tau(SI) = \forall~si \in SI$ : 
			\begin{itemize}
				\item[] - $\langle true,CS,SSI,\{\}\rangle~\rightarrow~\langle false,\{\},CS',\{\}\rangle$ en mettant en place la possibilité d'itérer
				\item[] - $\langle false,CS,SSI,ST\rangle~\rightarrow~\langle false,\{\},\{\},\{\}\rangle$ et 
				\\$\forall~st \in ST~:~\langle I,\langle\langle X',C''\rangle, E\rangle~\langle\langle X,C'\rangle, E\rangle~s~S,E,present~C,D\rangle~\rightarrow~\langle I,S,E,C''~C,D\rangle$ et on l'ajoute dans une liste temporaire $TL$.
			\end{itemize}
		\end{ex}
		\item[]
		
		
		\item[] - $\gamma(id,id',\langle CI,IL\rangle)$ une fonction qui retourne la constante lié à $id'$ et décale l'itérateur lié à l'identifiant de thread $id$.
		\begin{ex}
			Trois cas sont possibles :
			\begin{enumerate}
				\item Première fois que l'on prend : $\langle id',\langle\{\langle b,\emptyset\rangle,\langle n,IL\rangle,...\},IL\rangle\rangle \rightarrow \langle id',\langle\{\langle b,\emptyset\rangle,\langle n,IL~id\rangle,...\},IL\rangle\rangle$ et on retourne $b$
				\item On a déjà pris : $\langle id',\langle\{...,\langle b,\{...,id,...\}\rangle,\langle n,IL\rangle,...\},IL\rangle\rangle \rightarrow \langle id',\langle\{...,\langle b,\{...\}\rangle,\langle n,IL~id\rangle,...\},IL\rangle\rangle$ et on retourne $b$
				\item On prend le dernier : $\langle id',\langle\{...,\langle b,\{...,id,...\}\rangle\},IL\rangle\rangle \rightarrow \langle id',\langle\{...,\langle b,\{...\}\rangle\},IL~id\rangle\rangle$ et on retourne $b$
			\end{enumerate}
		\end{ex}
		\item[] 
		
		\item[] - $SI[(s,i) \leftarrow b]$ est une fonction qui met dans la liste de valeurs ,de s pour le thread i, b et met à vrai le booléen représentant l'émission $emit$.
		\begin{ex}
			Pour $SI(s) = \langle emit,CS,SSI,ST\rangle$ on change $SI$ telle que $SI(s) = \langle true,CS,SSI',ST\rangle$\\ avec $SSI' = \gamma(id,i,SSI)$ avec $id$ l'identifiant du thread courant.
		\end{ex}
		\item[] 
		
		\item[] - $SSI(i)$ une fonction qui retourne le couple lié à un signal et un thread dans la liste des signaux partagés.
		\begin{ex}
			$SSI(i) = \langle CI,IL\rangle$
		\end{ex}
	\end{itemize}
	\bigbreak
	
	
	\textbf{On va définir une règle afin de simplifier les règles futures :} 
	\begin{itemize}
		\item[] Dans tous les cas :
		\item[] \begin{center}
			$\dfrac{\langle S,E,C,D\rangle \longrightarrow_{TTSI} \langle S',E',C',D'\rangle}{\langle\langle I,S,E,C,D\rangle,TL,SI,IP\rangle \longrightarrow_{TTSI} \langle\langle I,S',E',C',D'\rangle,TL,SI,IP\rangle}$
		\end{center}
		\item[]
		\item[]
		\item[] Si la règle utilisée n'est ni \textbf{Thread bloqué non remplacé} ni \textbf{Création thread} :
		\smallbreak 
		\item[] \begin{center}
			$\dfrac{\langle\langle S,E,C,D\rangle,TL,SI\rangle \longrightarrow_{TTSI} \langle\langle S',E',C',D'\rangle,TL',SI'\rangle}{\langle\langle I,S,E,C,D\rangle,TL,SI,IP\rangle \longrightarrow_{TTSI} \langle\langle I,S',E',C',D'\rangle,TL',SI',IP\rangle}$ 
		\end{center}
	\end{itemize}
	\newpage
	
	\textbf{\textit{Les éléments étant expliqués, voici les nouvelles règles de la machine :}}
	\smallbreak
	\begin{enumerate}
		\item[] \textbf{Partie de base de la machine SECD :} On veut garder le fonctionnement de la machine SECD de base donc il faut garder ces règles.	
		\item[]
		\begin{itemize}
			\item[] \textbf{Constante ou Signal :} On a une constante, on la déplace dans la pile.
			\smallbreak
			$\langle S,E,n~C,D\rangle 
			\longrightarrow_{TTSI} 
			\langle n~S,E,C,D\rangle$ avec $n =$ une constante $b$ ou un identifiant de signal $s$
			\item[]
			
			\item[] \textbf{Substitution :} On a une variable, on substitue la variable par sa valeur liée dans l'environnement via la fonction $E$.
			\smallbreak
			$\langle S,E,X~C,D\rangle
			\longrightarrow_{TTSI} 
			\langle V~S,E,C,D\rangle$ avec $E(X) = V$
			\item[]
			
			\item[] \textbf{Opération :} On a un opérateur et le nombre de constantes nécessaires dans la pile, \\via la fonction $\delta$ on retourne le résultat dans la pile.
			\smallbreak
			$\langle b_{n},...,b_{1}~S,E,prim_{o^{n}}~C,D\rangle
			\longrightarrow_{TTSI} 
			\langle V~S,E,C,D\rangle$ avec $\delta(o^{n}~b_{1}...b_{n}) = V$
			\item[]
			
			\item[]  \textbf{Abstraction :} On a une abstraction, on crée une fermeture comportant l'abstraction et l'environnement courant et on met la fermeture dans la pile.
			\smallbreak
			$\langle S,E,\langle X,C'\rangle~C,D\rangle
			\longrightarrow_{TTSI} 
			\langle \langle\langle X,C'\rangle,E\rangle~S,E,C,D\rangle$
			\item[]
			
			\item[]  \textbf{Application :} On a une application, on sauvegarde dans le dépôt, on remplace la chaîne de contrôle et l'environnement par ceux présents dans la fermeture et on ajoute une substitution  dans le nouvel environnement.
			\smallbreak
			$\langle V~\langle\langle X,C'\rangle,E'\rangle~S,E,ap~C,D\rangle
			\longrightarrow_{TTSI} 
			\langle \emptyset,E'[X \leftarrow V],C',\langle S,E,C,D\rangle\rangle$
			\item[] 
			
			\item[] \textbf{Récupération de sauvegarde :}  On n'a rien mais le dépôt comporte une sauvegarde donc on prend celle-ci.
			\smallbreak  
			$\langle V~S,E,\epsilon,\langle S',E',C,D\rangle\rangle
			\longrightarrow_{TTSI} 
			\langle V~S',E',C,D\rangle$
		\end{itemize}
		\item[]
		
		
		
		\item[] \textbf{Partie pour la concurrence :} Cette partie ajoute la concurrence dans notre machine. 
		\item[]
		\begin{itemize}
			\item[]  \textbf{Création thread :} On crée un nouveau thread.
			\smallbreak 
			$\langle\langle I,\langle\langle X,C'\rangle, E\rangle~S,E,spawn~C,D\rangle,TL,SI,IP\rangle 
			\longrightarrow_{TTSI} 
			\langle\langle I,IP~S,E,C,D\rangle,TL~\langle IP,S,E,C',D\rangle,SI,IP+1\rangle$
			\item[]
			
			\item[] \textbf{Ajouter dans un signal :} On ajoute une constante dans une liste de valeurs d'un signal et on met à vrai le booléen $emit$
			\smallbreak
			$\langle\langle I,s~b~S,E,put~C,D\rangle,TL,SI\rangle
			\longrightarrow_{TTSI} 
			\langle\langle I,S,E,C,D\rangle,TL,SI~[(s,I) \leftarrow b]\rangle$ 
			\item[]
			
			\item[] \textbf{Prendre une valeur partagée :} On prend dans la liste de valeurs d'un signal partagé lié à un thread et on décale l'itérateur.
			\smallbreak
			$\langle\langle I,s~b~n~\langle\langle X,C'\rangle,E'\rangle~S,E,get~C,D\rangle,TL,SI\rangle 
			\longrightarrow_{TTSI} 
			\langle\langle I,\emptyset,E'[X \leftarrow V],C',\langle S,E,C,D\rangle\rangle,TL,SI\rangle$
			\\ si pour $SI(s) = \langle emit,CS,SSI\rangle$ et $SSI(b) = \langle CI,IL\rangle$ on a $I \notin IL$ alors $\gamma(I,b,SSI(b)) = V$ sinon $n = V$
			\item[]
			
			\item[] \textbf{Initialisation signal :} On initialise le signal via la fonction $\iota$.
			\smallbreak 
			$\langle\langle I,S,E,init~C,D\rangle,TL,SI\rangle 
			\longrightarrow_{TTSI}
			\langle\langle I,s~S,E,C,D\rangle,TL,SI'\rangle$
			avec $\iota(SI) = (s,SI')$
			\item[]	
			
			\item[] \textbf{Présence du signal :} On teste la présence d'un signal, via la fonction $SI$ on sait qu'il est émis donc on prend le premier choix.
			\smallbreak
			$\langle\langle I,\langle\langle X',C''\rangle,E\rangle~\langle\langle X,C'\rangle,E\rangle~s~S,E,present~C,D\rangle,TL,SI\rangle 
			\longrightarrow_{TTSI} 
			\langle\langle I,S,E,C'~C,D\rangle,TL,SI\rangle$ 
			\\avec $SI(s) = \langle vraie,CS,SSI,TL\rangle$
			\item[] \newpage
			
			
			
			
			\item[] \textbf{ Thread bloqué remplacé :} On teste la présence d'un signal, il n'est pas émis et il y a un thread dans la file d'attente donc on met le thread courant dans la liste de threads bloqués et on prend le thread en tête de la file.
			\smallbreak
			$\langle\langle I,\langle\langle X',C''\rangle,E\rangle~\langle\langle X,C'\rangle,E\rangle~s~S,E,present~C,D\rangle,\langle I',S',E',C''',D'\rangle~TL,SI\rangle 
			\\\longrightarrow_{TTSI} 
			\langle\langle I',S',E',C''',D'\rangle,TL,SI'\rangle$ 
			\\avec $SI(s) = \langle faux,CS,SSI,ST\rangle$
			\\et $SI'(s) = \langle faux,CS,SSI,ST~\langle I,\langle\langle X',C''\rangle,E\rangle~\langle\langle X,C'\rangle,E\rangle~s~S,E,present~C,D\rangle\rangle$
			\item[]	
			
			\item[] \textbf{Thread bloqué non remplacé :} On teste la présence d'un signal, il n'est pas émis donc on met ce thread dans la liste de threads bloqués.
			\smallbreak 
			$\langle\langle I,\langle\langle X',C''\rangle,E\rangle~\langle\langle X,C'\rangle,E\rangle~s~S,E,C,D\rangle,\emptyset,SI,IP\rangle 
			\longrightarrow_{TTSI} 
			\langle\langle IP,\emptyset,\epsilon,\emptyset,\emptyset\rangle,\emptyset,SI',IP+1\rangle$
			\\avec $SI(s) = \langle faux,CS,SSI,ST\rangle$
			\\et $SI'(s) = \langle faux,CS,SSI,ST~\langle I,\langle\langle X',C''\rangle,E\rangle~\langle\langle X,C'\rangle,E\rangle~s~S,E,present~C,D\rangle\rangle$
			\item[]
			
			\item[] \textbf{Récupération dans la file d'attente :} On n'a plus rien à traiter et on n'a aucune sauvegarde, du coup on change le thread courant par le thread en tête de la file d'attente.
			\smallbreak
			$\langle\langle I,S,E,\epsilon,\emptyset\rangle,\langle I',S',E',C,D\rangle~TL,SI\rangle 
			\longrightarrow_{TTSI} 
			\langle\langle I',S',E',C,D\rangle,TL,SI\rangle$
			\item[]
			
			\item[] \textbf{Fin d'instant logique :} On n'a plus rien à traiter, on n'a aucune sauvegarde et on n'a plus rien dans la file d'attente, c'est la fin d'un instant logique.
			\smallbreak
			$\langle\langle I,S,E,\epsilon,\emptyset \rangle ,\emptyset,SI\rangle 
			\longrightarrow_{TTSI} 
			\langle\langle I,S,E,\epsilon,\emptyset\rangle,TL,SI'\rangle$
			avec $\tau(SI)$ = ($SI',TL$) 
			\item[]
			
		\end{itemize}
		\item[] \textbf{Partie commune :} Quand on ajoute des règles dans une machine déjà existante, le plus délicat est de ne pas avoir de conflits dans les règles. Pour cela, on définit des règles exprès pour faire la liaison entre ce qui existait et ce que l'on ajoute. 
		\item[]
		\begin{itemize}
			\item[] \textbf{Application neutre :} On a une application sur rien, cela revient juste à ne rien faire.
			\smallbreak 
			$\langle S,E,ap~C,D\rangle
			\longrightarrow_{TTSI} 
			\langle S,E,C,D\rangle$
			\item[]
			\item[] \textbf{Récupération de sauvegarde avec pile vide :}  On n'a rien mais le dépôt comporte une sauvegarde donc on prend celle-ci.
			\smallbreak  
			$\langle \emptyset,E,\epsilon,\langle S',E',C,D\rangle\rangle
			\longrightarrow_{TTSI} 
			\langle S',E',C,D\rangle$
		\end{itemize}
		
		\item[]
	\end{enumerate}
	\bigbreak
	\bigbreak
	
	
\textbf{\textit{la machine TTSI peut s'arrêter dans 4 états différents:}}
\smallbreak
\begin{itemize}
	\item[] - Soit on a une \textbf{constante} telle que 
	$\langle\langle 0,\emptyset,\emptyset,\textlbrackdbl M\textrbrackdbl_{TTSI},\emptyset\rangle,\emptyset,\emptyset,1\rangle 
	\twoheadrightarrow_{TTSI} 
	\langle\langle I,b~S,E,\epsilon,\emptyset\rangle,\emptyset,SI,IP\rangle$;
	\item[] 
	\item[] - Soit on a une \textbf{fonction} telle que
	$\langle\langle 0,\emptyset,\emptyset,\textlbrackdbl M\textrbrackdbl_{TTSI},\emptyset\rangle,\emptyset,\emptyset,1\rangle 
	\twoheadrightarrow_{TTSI} 
	\langle\langle I,\langle\langle X,C\rangle,E\rangle~S,E,\epsilon,\emptyset\rangle,\emptyset,SI,IP\rangle$;
	\item[] 
	\item[] - Soit on a \textbf{rien} telle que  
	$\langle\langle 0,\emptyset,\emptyset,\textlbrackdbl M\textrbrackdbl_{TTSI},\emptyset\rangle,\emptyset,\emptyset,1\rangle 
	\twoheadrightarrow_{TTSI} 
	\langle\langle I,\epsilon,E,\epsilon,\emptyset\rangle,\emptyset,SI,IP\rangle$;
	\item[]
	\item[] - Sinon on a un \textbf{état inconnu} : on a une \textbf{erreur} 
\end{itemize}
\bigbreak


 Un exemple de fonctionnement de la machine TTS se trouve dans les \hyperref[TTSI]{Annexes}.
\newpage
	
	\section{Preuve du déterminise}
	
	Notre machine a besoin d'être déterministe. En effet, il faut pouvoir savoir exactement ce qu'il se passe dans la machine. Si on a plusieurs sortie possible pour une même entrée, la machine abstraite ne serait pas utilisable. Avec les différentes explications sur la machine TTSI on peut avoir l'intution quelle est déterministe. Cependant il faut le prouver.
	\medbreak
	
	Pour cela on va faire une preuve par induction. Avant tout, je vais reprendre les différents point de la machine et montrer qu'il ne peuvent pas avoir d'incidence sur le déterminisime de la machine. Tout cela afin de réduire notre preuve aux règles et plus sur la structure.
	\bigbreak
	
	Reprenons la machine dans son entièreté : 
	\begin{enumerate}
		\item $T$ : le thread courant est de la forme $\langle I,S,E,C,D \rangle$. En enlevant $I$ on retrouve notre machine SECD. La machine SECD étant déterministe, sa structure ne peut pas provoquer de non déterminisme de notre machine. $T$ est vérifié.
		
		\item $TL$ : la file d'attente est ,comme son nom l'indique, une file (une FIFO). Ce qui veut dire que l'on va prendre toujours au "début" de notre file et ajouter à la "fin". Ce qui revient à avoir un seul ordre possible dans le traitement des threads. Avoir un non déterminisme ici reviendrait à prendre un thread au hasard à chaque fois dans notre file or par la définition de file c'est impossible. L'ordre de traitement est créé lors de la création des threads et peut être uniquement modifier par la commande $present$. En effet si un signal n'est pas émis on va mettre le thread dans la file de threads bloqués du signal qu'il attend. On va donc l'enlever de $TL$ et le remettre plus tard à l'intérieur. La file d'attente est vérifiée.
		
		\item $SI$ : On va d'abord s'intéresser à $SI$ puis à ce qui la compose. C'est une liste que l'on ne vide pas. En effet =, quand on initialise un signal, il est initialisé pour toute la durée  du fonctionnement de la machine. On a vu que l'on avait besoin de les mettre dans un ordre précis pour pouvoir initialiser (pour créer leurs identifiants on les mets dans l'ordre croissant). On a une sorte de file où l'on ne prend jamais. $SI$ est composé $\langle s,\langle emit,CS,SSI,TL\rangle\rangle$. $TL$ 
	\end{enumerate}
	\bigbreak
	
	Prenons maintenant toute les formes que peut prendre la chaîne de contrôle qui sont traités par notre machine :
	\begin{itemize}
		\item[-] \underline{$b~C$} 
		\item[-] $...~\langle X,C'\rangle~C''~ap~...~X~C$ avec $C'' \twoheadrightarrow_{TTSI} V$
		\item[-] \underline{$\langle X,C'\rangle~C$}
		\item[-] \underline{$ap~C$}
		\item[-] $\langle X,C'\rangle~C''~ap~C$ avec $C'' \twoheadrightarrow_{TTSI} V$
		\item[-] $C_{n}...C_{0}~prim_{o^{n}}~C$ avec $C_{n}...C_{0} \twoheadrightarrow_{TTSI} b_{n}...b_{0}$
		\item[-] $\langle X,C'\rangle~spawn~C$
		\item[-] $\langle X',C''\rangle~\langle X,C'\rangle~s~present~C$
		\item[-] \underline{$init~C$}
		\item[-] $s~b~n~get~C$ avec un signal $s$ et un entier $n$
		\item[-] $b~put~C$
	\end{itemize}
	Les cas soulignés sont les seuls cas que l'on peut faire durant la première transition car ils ne nécéssitent pas plusieurs éléments.
	\bigbreak
	
	
	On va commencer la preuve par induction et plus précisement une preuve par récurrence :
	\smallbreak
	\textbf{Hypothèse :} La machine TTSI est déterministe.
	\bigbreak
	
	
	\textbf{Initialisation :}  On teste le déterminisme de la machine pour la première transition de la machine. À l'état 0 on a la machine TTSI de la forme $\langle\langle 0,\emptyset,\emptyset,\textlbrackdbl M\textrbrackdbl_{TTSI},\emptyset\rangle,\emptyset,\emptyset,1\rangle$. 
	On a 4 possibilités pour la chaîne de contrôle :
	\smallbreak
	\begin{enumerate}
		\item $b~C$ : On va utiliser la règle \textbf{Constante ou Signal}
		\smallbreak
		\item $\langle X,C'\rangle~C$ : On va utiliser la règle \textbf{Abstraction}
		\smallbreak
		\item $ap~C$ : On va utiliser la règle \textbf{Application neutre}
		\smallbreak
		\item $init~C$ : On va utiliser la règle \textbf{Initialisation signal}
	\end{enumerate}
	Tous les autres éléments et commandes ne sont pas possible et provoque une erreur. La machine TTSI est déterministe à l'état 1.
	\bigbreak
	
	 
	\textbf{Hérédité :} On suppose que l'hypothèse est vrai au rang n, c'est-à-dire que l'on a n transition déterministe. Montrons que l'hypothèse est vrai au rang n+1. Le but est de montrer que pour chaque cas que notre machine peut supporter il y a q'une seule règle qui puisse s'appliquer. En priorité, ce qui va impacter le choix d'une transition se sera la chaîne de contrôle, on va donc voir tous les éléments que la chaîne peut avoir en tête pour la transition n+1. 
	%%% 21 cas traité
	%%% 13 via CDC 
	%%% 1 via Fin d'un instant logique
	%%% 2 via D
	%%% 1 via TL
	%%% 4 via FIN
	\bigbreak
	
	
	Au total 21 cas sont traités par la machine. Voici les cas :
	\medbreak
	
	\begin{enumerate}
		\item[\textbf{1} -] $b$ : on a une constante, une règle est applicable \textbf{Constante}.
		\medbreak
		
		\item[-] $X$ : on a une variable, deux cas sont possibles :
		\begin{enumerate}
			\item[\textbf{2} -] Il y a une substitution possible dans l'environnement $E$, une règle est applicable \textbf{Substitution}.
			\item[\textbf{x} -] Il n'y a pas de substitution possible dans l'environnement $E$, aucune règle est applicable : c'est une \textbf{erreur}.
		\end{enumerate}
		\medbreak
		
		\item[-] $prim_{o^{n}}$ : on a la commande qui gère les opérations, deux cas sont possibles :
		\begin{enumerate}
			\item[\textbf{3} -] il y a assez de constantes consécutives dans la pile $S$, une règle est applicable \textbf{Opération}.
			\item[\textbf{x} -] il n'y a pas assez de constantes consécutives dans la pile $S$, aucune règle est applicable : c'est une \textbf{erreur}.	
		\end{enumerate}
		\medbreak
		
		\item[\textbf{4} -] $\langle X,C'\rangle$ : on a une abstraction, une règle est applicable \textbf{Abstraction}.
		\medbreak
		
		\item[-] $ap$ : on a la commande qui gère l'application, deux cas sont possibles :
		\begin{enumerate}
			\item[\textbf{5} -] soit il y a $V~\langle\langle X,C'\rangle,E'\rangle$ dans la pile $S$, une règle est applicable \textbf{Application}.
			\item[\textbf{6} -] soit il y a rien de spécifique dans la pile $S$, une règle est applicable \textbf{Application neutre}.
		\end{enumerate}
		\medbreak
		
		\item[-] $spawn$ : on a la commande qui gère la création de thread, deux cas sont possibles : 
		\begin{enumerate}
			\item[\textbf{7} -] si on a $\langle\langle X,C'\rangle,E'\rangle$ dans la pile $S$, une règle est applicable \textbf{Création thread}.
			\item[\textbf{x} -] sinon on a aucune règle est applicable : c'est une \textbf{erreur}. 
		\end{enumerate}
		\medbreak
		
		\item[-] $put$ : on a la commande qui gère l'ajout dans un signal, deux cas sont possibles :
		\begin{enumerate}
			\item[\textbf{8} -] si on a $s~b$ en tête dans la pile $S$, une règle est applicable \textbf{Ajouter dans un signal}.
			\item[\textbf{x} -] sinon on a aucune règle est applicable : c'est une \textbf{erreur}.
		\end{enumerate}
		\medbreak
		
		\item[-] $get$ : on a la commande qui gère la prise de valeur, deux cas sont possibles :
		\begin{enumerate}
			\item[\textbf{9} -] si on a $s~b~n$ en tête dans la pile $S$, une règle est applicable \textbf{Prendre une valeur partagée}.
			\item[\textbf{x} -] sinon on a aucune règle est applicable : c'est une \textbf{erreur}.
		\end{enumerate}
		\medbreak
		
		\item[\textbf{10} -] $init$ : on a la commande qui gère l'initialisation d'un signal, une règle est applicable \textbf{Initialisation signal}.
		\medbreak
		
		\item[-] $present$ : on a la commande qui gère la présence d'un signal, deux cas sont possibles :
		\begin{enumerate}
			\item[-] si on a $\langle\langle X',C''\rangle,E''\rangle~\langle\langle X,C'\rangle,E'\rangle~s$ en tête dans la pile $S$, deux cas sont possibles : 
			\begin{enumerate}
				\item[\textbf{11} -] soit on teste un signal émis tel que $SI = \{...,\langle s,\langle true,CS,SSI,TL\rangle\rangle,...\}$, une règle est applicable \textbf{Présence du signal}
				\item[-] soit on teste un signal non émis tel que $SI = \{...,\langle s,\langle false,CS,SSI,TL\rangle\rangle,...\}$, le cas se divise alors encore en deux :
				\begin{enumerate}
					\item[\textbf{12} -] soit on met en attente ce thread et on prend un nouveau thread dans $TL$, une règle est applicable \textbf{Thread bloqué remplacé}.
					\item[\textbf{13} -] soit on met en attente ce thread et $TL$ est vide, une règle est applicable \textbf{Thread bloqué non remplacé}.
				\end{enumerate}
			\end{enumerate}
			\item[\textbf{x} -] sinon on a aucune règle est applicable : c'est une \textbf{erreur}.
		\end{enumerate}
		\medbreak
		
		\item[-] $\epsilon$ : la chaîne de contrôle est vide, deux cas sont possibles :
		\begin{enumerate}
			\item[-] le dépôt $D$ contient une sauvegarde, deux cas sont possibles :
			\begin{enumerate}
				\item[\textbf{14} -] on a un élément dans la pile $S$, une règle est applicable \textbf{Récupération de sauvegarde}.
				\item[\textbf{15} -] on a rien dans la pile $S$, une règle est applicable \textbf{Récupération de sauvegarde neutre}.  
			\end{enumerate}
			\item[-] le dépôt $D$ est vide, deux cas sont possibles :
			\begin{enumerate}
				\item[\textbf{16} -] on a un élément dans la file d'attente $TL$, une règle est applicable \textbf{Récupération dans la file d'attente}.
				\item[-] on a la file d'attente $TL$ vide, deux cas sont possibles :
				\begin{enumerate}
					\item[\textbf{17} -] au moins un signal contient un ou plusieurs threads bloqués, une règle est applicable \textbf{Fin d'instant logique}.
					\item[-] aucun signal ne contient de threads bloqués, c'est la \textbf{fin de fonctionnement de la machine}. 4 fin sont possibles :
					\begin{enumerate}
						\item[\textbf{18} -] la tête de pile $S$ est une \textbf{constante}.
						\item[\textbf{19} -] la tête de pile $S$ est une \textbf{fonction}.
						\item[\textbf{20} -] la tête de pile $S$ est \textbf{vide}.
						\item[\textbf{21} -] on a un état inconnu qui est une \textbf{erreur}.
					\end{enumerate}	  
				\end{enumerate}
			\end{enumerate}
		\end{enumerate}
	\end{enumerate}
	\newpage
	
	
	
	\section{La gestion des erreurs}
	
	Cette partie est facultative à votre lecture. Une version de la machine a été créée avec pour but de gérer les exceptions. Pour cela deux versions ont été créées avec et sans la propagation des erreurs. Je vais donc présenter brièvement le langage.
	
	\subsection{Description informelle du langage}
	
	\paragraph{Gérer des erreurs :} Quand on parle d'erreur on a deux choses qui viennent en tête :
	\begin{itemize}
		\item[] - lever une erreur
		\item[] - avoir une structure de contrôle (try...catch)
	\end{itemize}
	La présence d'une erreur est-elle toujours signe d'un problème ? Non, on peut créer une erreur pour pouvoir gérer un cas, par exemple en java on peut créer une erreur et l'afficher sans que le programme soit erroné en lui-même. Il faut donc faire une différence entre une erreur et une erreur levée. On va créer deux éléments en plus pour notre chaîne de contrôle :
	\begin{itemize}
		\item[] - $throw$ : indique qu'un erreur est levée
		\item[] - $e$ : une erreur
	\end{itemize} 
	La structure de contrôle a toujours la même forme : la partie protégée et la partie de remplacement si une erreur est levée. On va devoir trouver une structure qui est adaptée pour la machine. On va utiliser une astuce déjà présente pour le $spawn$ et le $present$, c'est-à-dire utiliser une abstraction pour éviter la structure inappropriée. Il faut une commande pour savoir que l'on a une structure de gestion d'erreur. On arrive donc à la forme suivant $\langle X,C\rangle~\langle X',C'\rangle~catch$. On ne spécifie pas l'erreur qui devra être gérée, en effet on est au niveau le plus bas du traitement du langage ce n'est donc pas nécessaire. Voyons cela sur un exemple.
	\begin{ex}
		Soit f qui a x y associe x/y. On peut avoir l'erreur de la division par zero.
		\smallbreak
		\begin{enumerate}
			\item try (f x y)
			\item with DivByZero -> printf "Division par zéro"
		\end{enumerate}
		\medbreak
		
		
		On peut découper ce try with en :
		\smallbreak
		\begin{enumerate}
			\item try (f x y)
			\item catch
			\item ~~~match exception with 
			\item ~~~~~~DivByZero $\rightarrow$ printf "Division par zéro"
			\item ~~~~~~\_ $\rightarrow$ raise exception
		\end{enumerate}
		\medbreak
		
		Le try...catch n'a donc pas la nécessité de connaître l'erreur qu'il traite.
	\end{ex}
	
	\medbreak
	
	On peut se demander ce qu'on doit sauvegarder avec la structure de gestion d'erreur. En effet, il faudrait pouvoir revenir au moment où le try...catch est traité. On crée $H$ le gestionnaire d'erreur. On ne peut pas limiter le gestionnaire d'erreur $H$ à un thread précis car les threads communiquent entre eux. Donc le gestionnaire va être un élément à part entière de la machine. On aura donc $\langle T,TL,SI,H,IP\rangle$.
	\newpage
	
	
	
	\subsection{Sémantique de la machine abstraite}
	
	Ces deux commandes ajoutées engrangent énormément de changements. On va donc devoir redéfinir nos règles. 
	\bigbreak
	
	\textbf{\textit{Soit $\langle T,TL,SI,IP,H\rangle$ avec :}}
	
	\begin{itemize}
		\item[] $TL =$ \textbf{une file de thread telle que :} $\forall$ $tl \in TL~|~tl = T$ avec :
		\begin{itemize}
			\item[] $T = \langle I,S,E,C,D\rangle$ \textbf{le thread courant avec :}
			\begin{itemize}
				\item[] $b,s,n$ = une constante ou un identifiant de signal (un entier)
				\item[] $V = b$	
				\begin{itemize}
					\item[|] $e$
					\item[|] $\langle\langle X,C' \rangle E\rangle$
				\end{itemize}
				\item[] $I =$ un entier représentant l'identifiant du thread
				\item[] $S =  \emptyset$ 
				\begin{itemize}
					\item[|] $V~S$
					\item[|] $throw~S$
				\end{itemize}
				\item[] $E = \{...,\langle X,V\rangle,...\}$
				\item[] $C = \epsilon$
				\begin{itemize}
					\item[|] $b~C$~~~~~~~~~~~~~~~~~~~~~~~~~~ (une constante ou un signal)
					\item[|] $X~C$~~~~~~~~~~~~~~~~~~~~~~~~~~(une variable)
					\item[|] $e~C$~~~~~~~~~~~~~~~~~~~~~~~~~~~(une erreur)
					\item[|] $\langle X,C'\rangle~C$~~~~~~~~~~~~~~~~~~~(une abstraction)
					\item[|] $ap~C$~~~~~~~~~~~~~~~~~~~~~~~~~(une application)
					\item[|] $prim_{o^{n}}~C$~~~~~~~~~~~~~~~~~~~(un opérateur)
					\item[|] $spawn~C$~~~~~~~~~~~~~~~~~~~(créer d'un nouveau thread)
					\item[|] $present~C$~~~~~~~~~~~~~~~~~~(le test de présence d'un signal)
					\item[|] $init~C$~~~~~~~~~~~~~~~~~~~~~~~(initialise un signal)
					\item[|] $put~C$~~~~~~~~~~~~~~~~~~~~~~~~(insère une valeur dans un signal)
					\item[|] $get~C$~~~~~~~~~~~~~~~~~~~~~~~~(prend une valeurs dans un signal)
					\item[|] $throw~C$~~~~~~~~~~~~~~~~~~~~~(lève une erreur)
					\item[|] $catch~C$~~~~~~~~~~~~~~~~~~~~~(créer un gestionnaire d'erreur)
					
				\end{itemize}
				\item[] D = $\emptyset$
				\begin{itemize}
					\item[|] $\langle S,E,C,D\rangle$~~~~~~~~~~~~~~~~(une sauvegarde liée à une abstraction)
				\end{itemize}
			\end{itemize}	
		\end{itemize}
		
		\item[]
		\item[] \textbf{$SI =$ une liste de signaux telle que :} $\forall~si \in SI~:~si = \langle s,\langle emit,CS,SSI,TL\rangle\rangle$ avec :
		\begin{itemize}
			\item[] - \textbf{un identifiant de signal :} $s$
			\item[] - \textbf{un booléen représentant l'émission du signal :} $emit$
			\item[] - \textbf{un identifiant de thread :} $I$
			\item[] - \textbf{une liste des signaux courants telle que :} $\forall~cs \in CS~:~cs = \langle I,CL\rangle$ avec 
			\begin{itemize}
				\item[] - \textbf{une liste de constantes telle que :} $\forall~cl \in CL~:~cl = b$
			\end{itemize}
			
			\item[] - \textbf{la liste des signaux partagés telle que :} $\forall~ssi \in SSI~:~ssi = \langle I,\langle CI,IL\rangle\rangle$ avec 
			\begin{itemize}
				\item[] - \textbf{une liste d'identifiant de threads telle que :} $\forall~il \in IL~:~il = I$
				\item[] - \textbf{une liste de constante avec itérateur telle que :} $\forall~ci \in CI~:~ci = \langle b, IL\rangle$
			\end{itemize}
		\end{itemize}
		\item[]
		\item[] $IP =$ un entier servant à attribuer l'identifiant à un nouveau thread 
		\item[] $H = \emptyset$
		\begin{itemize}
			\item[|] $\langle T,TL,SI,IP,H\rangle$
		\end{itemize}
	\end{itemize}
	\bigbreak
	
	
	\textbf{\textit{Une suite de fonctions ont été écrites afin de simplifier la lecture des règles. Les voici :}}
	\smallbreak
	\begin{itemize}
		\item[] - $\iota(SI)$ une fonction qui prend l'identifiant du dernier signal créé, l'incrémente pour en créer un nouveau et retourne l'identifiant du signal créé avec la liste mise à jour.
		\begin{ex} $\empty$ \smallbreak 
			\begin{itemize}
				\item[] Si on initialise pour la première fois alors $\iota(\{\}) = (0 ,\{\langle 0,\langle false,\{\},\{\},\{\}\rangle\rangle\})$
				\item[] sinon $\iota(\{...,\langle s,data\rangle\}) = (s+1 ,\{...,\langle s,data\rangle,\langle s+1,\langle false,\{\},\{\},\{\}\rangle\rangle\})$ avec $data = \langle emit,CS,SSI,ST\rangle$
			\end{itemize}
		\end{ex}
		\item[]
		
		\item[] - $SI(s)$ une fonction qui retourne le 2nd élément du couple $\langle s,data\rangle$ avec $data = \langle emit,CS,SSI,ST\rangle$.
		\begin{ex}
			$SI(s) = \langle emit,CS,SSI,ST\rangle$
		\end{ex}
		\item[]  
		
		\item[] - $\tau(SI)$ une fonction qui prend la liste signaux, met les liste de valeurs courantes dans la liste des valeurs partagés si il est émis, prend en compte l'absence des signaux non émis et retourne le couple $\langle TL,SI \rangle$ avec une liste de threads $TL$ et $SI$ la liste des signaux modifiés 
		\begin{ex}
			$\tau(SI) = \forall~si \in SI$ : 
			\begin{itemize}
				\item[] - $\langle true,CS,SSI,\{\}\rangle~\rightarrow~\langle false,\{\},CS',\{\}\rangle$ en mettant en place la possibilité d'itérer
				\item[] - $\langle false,CS,SSI,ST\rangle~\rightarrow~\langle false,\{\},\{\},\{\}\rangle$ et 
				\\$\forall~st \in ST~:~\langle I,\langle\langle X',C''\rangle, E\rangle~\langle\langle X,C'\rangle, E\rangle~s~S,E,present~C,D\rangle~\rightarrow~\langle I,S,E,C''~C,D\rangle$ et on l'ajoute dans une liste temporaire $TL$.
			\end{itemize}
		\end{ex}
		\item[]
		
		
		\item[] - $\gamma(id,id',\langle CI,IL\rangle)$ une fonction qui retourne la constante lié à $id'$ et décale l'itérateur lié à l'identifiant de thread $id$.
		\begin{ex}
			Trois cas sont possibles :
			\begin{enumerate}
				\item Première fois que l'on prend : $\langle id',\langle\{\langle b,\emptyset\rangle,\langle n,IL\rangle,...\},IL\rangle\rangle \rightarrow \langle id',\langle\{\langle b,\emptyset\rangle,\langle n,IL~id\rangle,...\},IL\rangle\rangle$ et on retourne $b$
				\item On a déjà pris : $\langle id',\langle\{...,\langle b,\{...,id,...\}\rangle,\langle n,IL\rangle,...\},IL\rangle\rangle \rightarrow \langle id',\langle\{...,\langle b,\{...\}\rangle,\langle n,IL~id\rangle,...\},IL\rangle\rangle$ et on retourne $b$
				\item On prend le dernier : $\langle id',\langle\{...,\langle b,\{...,id,...\}\rangle\},IL\rangle\rangle \rightarrow \langle id',\langle\{...,\langle b,\{...\}\rangle\},IL~id\rangle\rangle$ et on retourne $b$
			\end{enumerate}
		\end{ex}
		\item[] 
		
		\item[] - $SI[(s,i) \leftarrow b]$ est une fonction qui met dans la liste de valeurs ,de s pour le thread i, b et met à vrai le booléen représentant l'émission $emit$.
		\begin{ex}
			Pour $SI(s) = \langle emit,CS,SSI,ST\rangle$ on change $SI$ telle que $SI(s) = \langle true,CS,SSI',ST\rangle$\\ avec $SSI' = \gamma(id,i,SSI)$ avec $id$ l'identifiant du thread courant.
		\end{ex}
		\item[] 
		
		\item[] - $SSI(i)$ une fonction qui retourne le couple lié à un signal et un thread dans la liste des signaux partagés.
		\begin{ex}
			$SSI(i) = \langle CI,IL\rangle$
		\end{ex}
	\end{itemize}
	\bigbreak
	
	
	\textbf{On va définir une règle afin de simplifier les règles futures :} 
	\begin{itemize}
		\item[] Dans tous les cas :
		\item[] \begin{center}
			$\dfrac{\langle S,E,C,D\rangle \longrightarrow_{TTSIH} \langle S',E',C',D'\rangle}{\langle\langle I,S,E,C,D\rangle,TL,SI,IP,H\rangle \longrightarrow_{TTSIH} \langle\langle I,S',E',C',D'\rangle,TL,SI,IP,H\rangle}$
		\end{center}
		\item[]
		\item[]
		\item[] Si la règle utilisée n'est ni \textbf{Thread bloqué non remplacé} ni \textbf{Création thread} :
		\smallbreak 
		\item[] \begin{center}
			$\dfrac{\langle\langle S,E,C,D\rangle,TL,SI\rangle \longrightarrow_{TTSIH} \langle\langle S',E',C',D'\rangle,TL',SI'\rangle}{\langle\langle I,S,E,C,D\rangle,TL,SI,IP,H\rangle \longrightarrow_{TTSIH} \langle\langle I,S',E',C',D'\rangle,TL',SI',IP,H\rangle}$ 
		\end{center}
	\end{itemize}
	\newpage
	
	\textbf{\textit{Les éléments étant expliqués, voici les nouvelles règles de la machine :}}
	\smallbreak
	\begin{enumerate}
		\item[] \textbf{Partie de base de la machine SECD :} On veut garder le fonctionnement de la machine SECD de base donc il faut garder ces règles.	
		\item[]
		\begin{itemize}
			\item[] \textbf{Constante ou Signal :} On a une constante, on la déplace dans la pile.
			\smallbreak
			$\langle S,E,n~C,D\rangle 
			\longrightarrow_{TTSIH} 
			\langle n~S,E,C,D\rangle$ avec $n =$ une constante $b$ ou un identifiant de signal $s$
			\item[]
			
			\item[] \textbf{Substitution :} On a une variable, on substitue la variable par sa valeur liée dans l'environnement via la fonction $E$.
			\smallbreak
			$\langle S,E,X~C,D\rangle
			\longrightarrow_{TTSIH} 
			\langle V~S,E,C,D\rangle$ avec $E(X) = V$
			\item[]
			
			\item[] \textbf{Opération :} On a un opérateur et le nombre de constantes nécessaires dans la pile, \\via la fonction $\delta$ on retourne le résultat dans la pile.
			\smallbreak
			$\langle b_{n},...,b_{1}~S,E,prim_{o^{n}}~C,D\rangle
			\longrightarrow_{TTSIH} 
			\langle V~S,E,C,D\rangle$ avec $\delta(o^{n}~b_{1}...b_{n}) = V$
			\item[]
			
			\item[]  \textbf{Abstraction :} On a une abstraction, on crée une fermeture comportant l'abstraction et l'environnement courant et on met la fermeture dans la pile.
			\smallbreak
			$\langle S,E,\langle X,C'\rangle~C,D\rangle
			\longrightarrow_{TTSIH} 
			\langle \langle\langle X,C'\rangle,E\rangle~S,E,C,D\rangle$
			\item[]
			
			\item[]  \textbf{Application :} On a une application, on sauvegarde dans le dépôt, on remplace la chaîne de contrôle et l'environnement par ceux présents dans la fermeture et on ajoute une substitution  dans le nouvel environnement.
			\smallbreak
			$\langle V~\langle\langle X,C'\rangle,E'\rangle~S,E,ap~C,D\rangle
			\longrightarrow_{TTSIH} 
			\langle \emptyset,E'[X \leftarrow V],C',\langle S,E,C,D\rangle\rangle$
			\item[] 
			
			\item[] \textbf{Récupération de sauvegarde :}  On n'a rien mais le dépôt comporte une sauvegarde donc on prend celle-ci.
			\smallbreak  
			$\langle V~S,E,\epsilon,\langle S',E',C,D\rangle\rangle
			\longrightarrow_{TTSIH} 
			\langle V~S',E',C,D\rangle$
		\end{itemize}
		\item[]
		
		
		
		\item[] \textbf{Partie pour la concurrence :} Cette partie ajoute la concurrence dans notre machine. 
		\item[]
		\begin{itemize}
			\item[]  \textbf{Création thread :} On crée un nouveau thread.
			\smallbreak 
			$\langle\langle I,\langle\langle X,C'\rangle, E\rangle~S,E,spawn~C,D\rangle,TL,SI,IP,H\rangle 
			\longrightarrow_{TTSIH} 
			\langle\langle I,S,E,C,D\rangle,TL~\langle IP,S,E,C',D\rangle,SI,IP+1,H\rangle$
			\item[]
			
			\item[] \textbf{Ajouter dans un signal :} On ajoute une constante dans une liste de valeurs d'un signal et on met à vrai le booléen $emit$
			\smallbreak
			$\langle\langle I,s~b~S,E,put~C,D\rangle,TL,SI\rangle
			\longrightarrow_{TTSIH} 
			\langle\langle I,S,E,C,D\rangle,TL,SI~[(s,I) \leftarrow b]\rangle$ 
			\item[]
			
			\item[] \textbf{Prendre une valeur partagée :} On prend dans la liste de valeurs d'un signal partagé lié à un thread et on décale l'itérateur.
			\smallbreak
			$\langle\langle I,s~b~n~\langle\langle X,C'\rangle,E'\rangle~S,E,get~C,D\rangle,TL,SI\rangle 
			\longrightarrow_{TTSIH} 
			\langle\langle I,\emptyset,E'[X \leftarrow V],C',\langle S,E,C,D\rangle\rangle,TL,SI\rangle$
			\\ si pour $SI(s) = \langle emit,CS,SSI\rangle$ et $SSI(b) = \langle CI,IL\rangle$ on a $I \notin IL$ alors $\gamma(I,b,SSI(b)) = V$ sinon $n = V$
			\item[]
			
			\item[] \textbf{Initialisation signal :} On initialise le signal via la fonction $\iota$.
			\smallbreak 
			$\langle\langle I,S,E,init~C,D\rangle,TL,SI\rangle 
			\longrightarrow_{TTSIH}
			\langle\langle I,s~S,E,C,D\rangle,TL,SI'\rangle$
			avec $\iota(SI) = (s,SI')$
			\item[]	
			
			\item[] \textbf{Présence du signal :} On teste la présence d'un signal, via la fonction $SI$ on sait qu'il est émis donc on prend le premier choix.
			\smallbreak
			$\langle\langle I,\langle\langle X',C''\rangle,E\rangle~\langle\langle X,C'\rangle,E\rangle~s~S,E,present~C,D\rangle,TL,SI\rangle 
			\longrightarrow_{TTSIH} 
			\langle\langle I,S,E,C'~C,D\rangle,TL,SI\rangle$ 
			\\avec $SI(s) = \langle vraie,CS,SSI,TL\rangle$
			\item[] \newpage
			
			
			
			
			\item[] \textbf{ Thread bloqué remplacé :} On teste la présence d'un signal, il n'est pas émis et il y a un thread dans la file d'attente donc on met le thread courant dans la liste de threads bloqués et on prend le thread en tête de la file.
			\smallbreak
			$\langle\langle I,\langle\langle X',C''\rangle,E\rangle~\langle\langle X,C'\rangle,E\rangle~s~S,E,present~C,D\rangle,\langle I',S',E',C''',D'\rangle~TL,SI\rangle 
			\\\longrightarrow_{TTSIH} 
			\langle\langle I',S',E',C''',D'\rangle,TL,SI'\rangle$ 
			\\avec $SI(s) = \langle faux,CS,SSI,ST\rangle$
			\\et $SI'(s) = \langle faux,CS,SSI,ST~\langle I,\langle\langle X',C''\rangle,E\rangle~\langle\langle X,C'\rangle,E\rangle~s~S,E,present~C,D\rangle\rangle$
			\item[]	
			
			\item[] \textbf{Thread bloqué non remplacé :} On teste la présence d'un signal, il n'est pas émis donc on met ce thread dans la liste de threads bloqués.
			\smallbreak 
			$\langle\langle I,\langle\langle X',C''\rangle,E\rangle~\langle\langle X,C'\rangle,E\rangle~s~S,E,C,D\rangle,\emptyset,SI,IP,H\rangle 
			\longrightarrow_{TTSIH} 
			\langle\langle IP,\emptyset,\epsilon,\emptyset,\emptyset\rangle,\emptyset,SI',IP+1,H\rangle$
			\\avec $SI(s) = \langle faux,CS,SSI,ST\rangle$
			\\et $SI'(s) = \langle faux,CS,SSI,ST~\langle I,\langle\langle X',C''\rangle,E\rangle~\langle\langle X,C'\rangle,E\rangle~s~S,E,present~C,D\rangle\rangle$
			\item[]
			
			\item[] \textbf{Récupération dans la file d'attente :} On n'a plus rien à traiter et on n'a aucune sauvegarde, du coup on change le thread courant par le thread en tête de la file d'attente.
			\smallbreak
			$\langle\langle I,S,E,\epsilon,\emptyset\rangle,\langle I',S',E',C,D\rangle~TL,SI\rangle 
			\longrightarrow_{TTSIH} 
			\langle\langle I',S',E',C,D\rangle,TL,SI\rangle$
			\item[]
			
			\item[] \textbf{Fin d'instant logique :} On n'a plus rien à traiter, on n'a aucune sauvegarde et on n'a plus rien dans la file d'attente, c'est la fin d'un instant logique.
			\smallbreak
			$\langle\langle I,S,E,\epsilon,\emptyset \rangle ,\emptyset,SI\rangle 
			\longrightarrow_{TTSIH} 
			\langle\langle I,S,E,\epsilon,\emptyset\rangle,TL,SI'\rangle$
			avec $\tau(SI)$ = ($SI',TL$) 
			\item[]
			
		\end{itemize}
		\item[] \textbf{Partie pour la gestion des erreurs :} Cette partie ajoute la gestion des erreurs dans notre machine. 
		\item[]
		\begin{itemize}
			\item[] \textbf{Erreur :} On a une erreur, on la déplace dans la pile 
			\smallbreak
			$\langle S,E,e~C,D\rangle 
			\longrightarrow_{TTSIH} 
			\langle e~S,E,C,D\rangle $
			\item[]
			
			\item[] \textbf{Lever une erreur et la gérer :} On a la commande throw, on regarde si on peut gérer l'erreur. On le peut donc on prend la sauvegarde dans le gestionnaire d'erreur
			\smallbreak
			$\langle\langle e~S,E,throw~C,D\rangle,TL,SI,IP,\langle \langle S',E',\langle X,C''\rangle~C',D'\rangle,TL',SI',IP',H\rangle\rangle 
			\\\longrightarrow_{TTSIH} 
			\langle\langle \epsilon,E'[X \leftarrow e],C'',\langle S',E',C',D\rangle\rangle,TL',SI',IP',H\rangle $
			\item[]
			
			\item[] \textbf{Lever une erreur et arrêter la machine :} On a la commande throw, on regarde si on peut gérer l'erreur. On ne le peut pas donc on arrête la machine
			\smallbreak
			$\langle\langle e~S,E,throw~C,D\rangle,TL,SI,IP,\emptyset\rangle 
			\longrightarrow_{TTSIH} 
			\langle\langle e,E,throw,\emptyset\rangle,\emptyset,\emptyset,IP,\emptyset\rangle $
			\item[]
			
			\item[] \textbf{Créer un gestionnaire d'erreur :} On a la commande catch, 
			\smallbreak
			$\langle\langle \langle\langle X',C''\rangle,E\rangle~\langle\langle X,C'\rangle,E\rangle~S,E,catch~C,D\rangle,TL,SI,IP,H\rangle 
			\\\longrightarrow_{TTSIH} 
			\langle\langle S,E,C'~C,D\rangle,TL,SI,IP,\langle \langle S,E,\langle X,C''\rangle~C,D\rangle,TL,SI,IP,H\rangle\rangle $
			\item[]
		\end{itemize}
		\item[] \textbf{Partie commune :} Quand on ajoute des règles dans une machine déjà existante, le plus délicat est de ne pas avoir de conflits dans les règles. Pour cela, on définit des règles exprès pour faire la liaison entre ce qui existait et ce que l'on ajoute. 
		\item[]
		\begin{itemize}
			\item[] \textbf{Application neutre :} On a une application sur rien, cela revient juste à ne rien faire.
			\smallbreak 
			$\langle S,E,ap~C,D\rangle
			\longrightarrow_{TTSIH} 
			\langle S,E,C,D\rangle$
			\item[]
			\item[] \textbf{Récupération de sauvegarde avec pile vide :}  On n'a rien mais le dépôt comporte une sauvegarde donc on prend celle-ci.
			\smallbreak  
			$\langle \emptyset,E,\epsilon,\langle S',E',C,D\rangle\rangle
			\longrightarrow_{TTSIH} 
			\langle S',E',C,D\rangle$
		\end{itemize}
		
		\item[]
	\end{enumerate}
	\bigbreak
	\bigbreak
	
	
	\textbf{\textit{la machine TTSIH peut s'arrêter dans 5 états différents:}}
	\smallbreak
	\begin{itemize}
		\item[] - Soit on a une \textbf{constante} telle que 
		$\langle\langle 0,\emptyset,\emptyset,\textlbrackdbl M\textrbrackdbl_{TTSIH},\emptyset\rangle,\emptyset,\emptyset,1\rangle 
		\twoheadrightarrow_{TTSIH} 
		\langle\langle I,b~S,E,\epsilon,\emptyset\rangle,\emptyset,SI,IP\rangle$;
		\item[] 
		\item[] - Soit on a une \textbf{fonction} telle que
		$\langle\langle 0,\emptyset,\emptyset,\textlbrackdbl M\textrbrackdbl_{TTSIH},\emptyset\rangle,\emptyset,\emptyset,1\rangle 
		\twoheadrightarrow_{TTSIH} 
		\langle\langle I,\langle\langle X,C\rangle,E\rangle~S,E,\epsilon,\emptyset\rangle,\emptyset,SI,IP\rangle$;
		\item[] 
		\item[] - Soit on a \textbf{rien} telle que  
		$\langle\langle 0,\emptyset,\emptyset,\textlbrackdbl M\textrbrackdbl_{TTSIH},\emptyset\rangle,\emptyset,\emptyset,1\rangle 
		\twoheadrightarrow_{TTSIH} 
		\langle\langle I,\epsilon,E,\epsilon,\emptyset\rangle,\emptyset,SI,IP\rangle$;
		\item[]
		\item[] - Soit on a \textbf{une erreur traitée} telle que  
		$\langle\langle 0,\emptyset,\emptyset,\textlbrackdbl M\textrbrackdbl_{TTSIH},\emptyset\rangle,\emptyset,\emptyset,1\rangle 
		\twoheadrightarrow_{TTSIH} 
		\langle\langle I,e,E,\epsilon,\emptyset\rangle,\emptyset,SI,IP\rangle$;
		\item[]
		\item[] - Soit on a \textbf{une erreur non traitée} telle que  
		$\langle\langle 0,\emptyset,\emptyset,\textlbrackdbl M\textrbrackdbl_{TTSIH},\emptyset\rangle,\emptyset,\emptyset,1\rangle 
		\twoheadrightarrow_{TTSIH} 
		\langle\langle I,e,E,throw,\emptyset\rangle,\emptyset,SI,IP\rangle$;
	\end{itemize}
	\bigbreak
	
	
	Un exemple de fonctionnement de la machine TTS se trouve dans les \hyperref[TTSI]{Annexes}.
	\newpage
	
	
	
	
	
	\chapter{Conclusion}
	
	(À retravailler)
	Le sujet traitait \textit{la programmation réactive synchrone} à travers un travail d'implantation d'une machine virtuelle. Pour cela, nous sommes repartis de la base en apprenant le langage de programmation $\lambda$-calcul. On a continué notre apprentissage avec le langage de programmation ISWIM. On s'est intéressé aux machines abstraites qui découle de ces langages, c'est-à-dire les machines CC, SCC, CK, CEK et SECD. On sait aussi intéressé à la programmation réactive. De là, nous sommes partis d'une machine existante, la machine SECD, pour créer notre machine fonctionnelle réactive.
	\begin{itemize}
		\item[-] Dans un premier temps on a créé une machine abstraite fonctionnelle réactive pure. On a mis les bases de la programmation réactive via l'ajout des threads et des signaux en prenant le principe du langage SL pour connaître l'absence d'un signal. 
		\item[-]Dans un deuxième temps on a créé une machine abstraite fonctionnelle réactive avec partage de valeurs. Les signaux ne sont plus seulement présents ou absents mais permettent de transférer des données entre chaque thread. On a créé une mémoire partagée découpée grâce au signal qui le contient et au thread qui la mis dans la mémoire.
		\item[-] Dans un troisième temps un petit mot a été glissé sur la gestion des erreurs. 
	\end{itemize}
	\medbreak
	
	J'aimerai souligner tout le travail effectué durant le stage qui n'est pas présent dans le rapport ou seulement en Annexe. Beaucoup de versions intermédiaires de notre travail final existe ainsi que leurs implantations en OCaml.
	\medbreak
	
	Encore beaucoup de travail reste à faire. En effet, il manque une preuve du déterminisme de la machine qui a été effectuée en partie au brouillon. Une implantation avec un système de gestion d'erreur est une prochaine étape à franchir pour que notre machine abstraite fonctionnelle réactive soit entièrement opérationnelle.
	\medbreak
	
	Ce stage m'a permi d'entrevoir le monde de la recherche, ses avantages et ses inconvénients. Je pense avoir gagné en rigueur, grâce à l'écriture de la sémantique stricte ainsi que la preuve de déterminisme qui est en cours d'écriture, ainsi qu'en rapidité d'exécution grâce aux dates butoirs données pour faire chaque parties de la machine. Je suis content d'avoir postulé pour ce stage, le monde de la recherche est fascinant.
	
	
	
	\chapter*{Bibliographie}\label{biblio}
	
	\begin{itemize}
		\item[] [1] \textit{Réactivité des systèmes coopératifs : le cas Réactive ML} de Louis Mandrel et Cédric Pasteur\label{ReactiveML}
		\item[] [2] \textit{The ZINC experiment: an economical implementation of the ML language} de Xavier Leroy\label{ZINC}
		\item[] [3] \textit{Programming Languages And Lambda Calculi} de Mathias Felleisen et Matthew Flatt\label{Calculi}
		\item[] [4] \textit{Java Fair Threads} de Frédéric Bussinot \label{FT} 
		\item[] [5] \textit{The SL Synchronous Language} de Frédéric Bussinot et Robert de Simone \label{SL}
		\item[] [6] \textit{Icobj Programming} de Frédéric Bussinot \label{IJ}
	\end{itemize}
	
	\chapter*{Annexes}
	
	\subsection*{Les Exemples des machines}
	
	Cette section des annexes regroupent les exemples des machines étudiées et créées.
	
	\begin{ex}\label{CK} Voici un exemple de fonctionnement de la machine CK :
		\medbreak
		
		\begin{itemize}
			\item[] CK machine : $\langle(((\lambda f.\lambda x.f$ $x)$ $\lambda y.(+$ $y$ $y))$ $\ulcorner 1\urcorner),mt\rangle$
			\item[] > (1) $\langle(M$ $N),\kappa\rangle \longmapsto_{ck} \langle M,\langle arg,N,\kappa\rangle\rangle$
			\item[] CK machine : $\langle((\lambda f.\lambda x.f$ $x)$ $\lambda y.(+$ $y$ $y)),\langle arg,\ulcorner 1\urcorner,mt\rangle\rangle$
			\item[] > (1) $\langle(M$ $N),\kappa\rangle \longmapsto_{ck} \langle M,\langle arg,N,\kappa\rangle\rangle$
			\item[] CK machine : $\langle(\lambda f.\lambda x.f$ $x),\langle arg,(\lambda y.(+$ $y$ $y)),\langle arg,\ulcorner 1\urcorner,mt\rangle\rangle\rangle$	
			\item[] > (3) $\langle V,\langle arg,N,\kappa \rangle \rangle \longmapsto_{ck} \langle N,\langle fun,V,\kappa \rangle \rangle$
			\item[] CK machine : $\langle(\lambda y.(+$ $y$ $y)),\langle fun,(\lambda f.\lambda x.f$ $x),\langle arg,\ulcorner 1\urcorner,mt\rangle\rangle\rangle$	
			\item[] > (2) $\langle V,\langle fun,(\lambda X.M),\kappa \rangle \rangle \longmapsto_{ck} \langle M[X \leftarrow V],\kappa\rangle$
			\item[] CK machine : $\langle(\lambda x.f$ $x)[f\leftarrow(\lambda y.(+$ $y$ $y))],\langle arg,\ulcorner 1\urcorner,mt\rangle\rangle$	
			\item[] CK machine : $\langle(\lambda x.(\lambda y.(+$ $y$ $y))$ $x),\langle arg,\ulcorner 1\urcorner,mt\rangle\rangle$	
			\item[] > (3) $\langle V,\langle arg,N,\kappa \rangle \rangle \longmapsto_{ck} \langle N,\langle fun,V,\kappa \rangle \rangle$
			\item[] CK machine : $\langle\ulcorner 1\urcorner,\langle fun,(\lambda x.(\lambda y.(+$ $y$ $y))$ $x),mt\rangle\rangle$
			\item[] > (2) $\langle V,\langle fun,(\lambda X.M),\kappa \rangle \rangle \longmapsto_{ck} \langle M[X \leftarrow V],\kappa\rangle$		
			\item[] CK machine : $\langle((\lambda y.(+$ $y$ $y))$ $x)[x \leftarrow \ulcorner 1\urcorner ],mt\rangle$
			\item[] CK machine : $\langle((\lambda y.(+$ $y$ $y))$ $\ulcorner 1\urcorner),mt\rangle$
			\item[] > (1) $\langle(M$ $N),\kappa\rangle \longmapsto_{ck} \langle M,\langle arg,N,\kappa\rangle\rangle$
			\item[] CK machine : $\langle(\lambda y.(+$ $y$ $y)),\langle arg,\ulcorner 1\urcorner,mt\rangle\rangle$	
			\item[] > (3) $\langle V,\langle arg,N,\kappa \rangle \rangle \longmapsto_{ck} \langle N,\langle fun,V,\kappa \rangle \rangle$
			\item[] CK machine : $\langle\ulcorner 1\urcorner,\langle fun,(\lambda y.(+$ $y$ $y)),mt\rangle\rangle$	
			\item[] > (2) $\langle V,\langle fun,(\lambda X.M),\kappa \rangle \rangle \longmapsto_{ck} \langle M[X \leftarrow V],\kappa\rangle$	
			\item[] CK machine : $\langle(+$ $y$ $y)[y \leftarrow\ulcorner 1\urcorner],mt\rangle$
			\item[] CK machine : $\langle(+$ $\ulcorner 1\urcorner$ $\ulcorner 1\urcorner),mt\rangle$
			\item[] > (4) $\langle(o^{n}$ $M$ $N...),\kappa\rangle \longmapsto_{ck} \langle M,\langle opd,\langle o^{n}\rangle,\langle N,...\rangle,\kappa\rangle\rangle$
			\item[] CK machine : $\langle\ulcorner 1\urcorner,\langle opd,\langle + \rangle,\langle\ulcorner 1\urcorner\rangle,mt\rangle\rangle$
			\item[] > (6) $\langle V,\langle opd,\langle V',...o^{n}\rangle,\langle N,L,...\rangle,\kappa\rangle\rangle \longmapsto_{ck} \langle N,\langle opd,\langle V,V',...o^{n}\rangle,\langle L,...\rangle,\kappa\rangle\rangle$
			\item[] CK machine : $\langle\ulcorner 1\urcorner,\langle opd,\langle\ulcorner 1\urcorner,+ \rangle,\langle\rangle,mt\rangle\rangle$
			\item[] > (5) $\langle b,\langle opd,\langle b_{i},...b_{1},o^{n}\rangle,\langle\rangle,\kappa\rangle\rangle \longmapsto_{ck} \langle V,\kappa\rangle$ avec $\delta(o^{n},b_{1},...b_{i},b) = V$
			\item[] CK machine : $\langle\ulcorner 2\urcorner,mt\rangle$
		\end{itemize}
	\end{ex}
	\newpage
	
	
	
	\begin{ex}\label{CEK} Voici un exemple de fonctionnement de la machine CEK :
		\medbreak
		
		\begin{itemize}
			\item[] CEK machine : $\langle\langle(((\lambda f.\lambda x.f$ $x)$ $\lambda y.(+$ $y$ $y))$ $\ulcorner 1\urcorner)\emptyset\rangle,mt\rangle$
			\item[] > (1) $\langle\langle(M$ $N),\varepsilon\rangle,\overline{\kappa}\rangle \longmapsto_{cek} \langle \langle M,\varepsilon\rangle,\langle arg,\langle N,\varepsilon\rangle,\overline{\kappa}\rangle\rangle$
			\item[] CEK machine : $\langle\langle((\lambda f.\lambda x.f$ $x)$ $\lambda y.(+$ $y$ $y))\emptyset\rangle,\langle arg,\langle\ulcorner 1\urcorner,\emptyset\rangle,mt\rangle\rangle$
			\item[] > (1) $\langle\langle(M$ $N),\varepsilon\rangle,\overline{\kappa}\rangle \longmapsto_{cek} \langle \langle M,\varepsilon\rangle,\langle arg,\langle N,\varepsilon\rangle,\overline{\kappa}\rangle\rangle$
			\item[] CEK machine : $\langle\langle(\lambda f.\lambda x.f$ $x),\emptyset\rangle,\langle arg,\langle(\lambda y.(+$ $y$ $y)),\emptyset\rangle,\langle arg,\langle\ulcorner 1\urcorner,\emptyset\rangle,mt\rangle\rangle\rangle$
			\item[] > (4) $\langle \langle V,\varepsilon\rangle,\langle arg,\langle N,\varepsilon'\rangle,\kappa\rangle\rangle \longmapsto_{cek} \langle \langle N,\varepsilon'\rangle,\langle fun,\langle V,\varepsilon\rangle,\overline{\kappa}\rangle\rangle$ si $V \notin X$
			\item[] CEK machine : $\langle\langle(\lambda y.(+$ $y$ $y)),\emptyset\rangle,\langle fun,\langle(\lambda f.\lambda x.f$ $x),\emptyset\rangle,\langle arg,\langle\ulcorner 1\urcorner,\emptyset\rangle,mt\rangle\rangle\rangle$
			\item[] > (3) $\langle\langle V,\varepsilon\rangle,\langle fun,\langle (\lambda X1.M),\varepsilon'\rangle,\overline{\kappa} \rangle \rangle \longmapsto_{cek} \langle \langle M,\varepsilon'[X1 \leftarrow \langle V,\varepsilon\rangle]\rangle,\overline{\kappa}\rangle$ si $V \notin X$
			\item[] CEK machine : $\langle\langle(\lambda x.f$ $x),\emptyset[f \leftarrow \langle(\lambda y.(+$ $y$ $y)),\emptyset\rangle]\rangle,\langle arg,\langle\ulcorner 1\urcorner,\emptyset\rangle,mt\rangle\rangle$
			\item[] CEK machine : $\langle\langle(\lambda x.f$ $x),\{\langle f,\langle(\lambda y.(+$ $y$ $y)),\emptyset\rangle\rangle\}\rangle,\langle arg,\langle\ulcorner 1\urcorner,\emptyset\rangle,mt\rangle\rangle$
			\item[] > (4) $\langle \langle V,\varepsilon\rangle,\langle arg,\langle N,\varepsilon'\rangle,\kappa\rangle\rangle \longmapsto_{cek} \langle \langle N,\varepsilon'\rangle,\langle fun,\langle V,\varepsilon\rangle,\overline{\kappa}\rangle\rangle$ si $V \notin X$
			\item[] CEK machine : $\langle\langle\ulcorner 1\urcorner,\emptyset\rangle,\langle fun,\langle(\lambda x.f$ $x),\{\langle f,\langle(\lambda y.(+$ $y$ $y)),\emptyset\rangle\rangle\}\rangle,mt\rangle\rangle$
			\item[] > (3) $\langle\langle V,\varepsilon\rangle,\langle fun,\langle (\lambda X1.M),\varepsilon'\rangle,\overline{\kappa} \rangle \rangle \longmapsto_{cek} \langle \langle M,\varepsilon'[X1 \leftarrow \langle V,\varepsilon\rangle]\rangle,\overline{\kappa}\rangle$ si $V \notin X$
			\item[] CEK machine : $\langle\langle(f$ $x),\{\langle f,\langle(\lambda y.(+$ $y$ $y)),\emptyset\rangle\rangle\}[x \leftarrow \langle\ulcorner 1\urcorner,\emptyset\rangle]\rangle,mt\rangle$
			\item[] CEK machine : $\langle\langle(f$ $x),\{\langle f,\langle(\lambda y.(+$ $y$ $y)),\emptyset\rangle\rangle,\langle x,\langle\ulcorner 1\urcorner,\emptyset\rangle\rangle\}\rangle,mt\rangle$
			\item[] > (1) $\langle\langle(M$ $N),\varepsilon\rangle,\overline{\kappa}\rangle \longmapsto_{cek} \langle \langle M,\varepsilon\rangle,\langle arg,\langle N,\varepsilon\rangle,\overline{\kappa}\rangle\rangle$
			\item[] CEK machine : $\langle\langle f,\{\langle f,\langle(\lambda y.(+$ $y$ $y)),\emptyset\rangle\rangle,\langle x,\langle\ulcorner 1\urcorner,\emptyset\rangle\rangle\}\rangle,\langle arg,\langle x,\{\langle f,\langle(\lambda y.(+$ $y$ $y)),\emptyset\rangle\rangle,\langle x,\langle\ulcorner 1\urcorner,\emptyset\rangle\rangle\}\rangle,mt\rangle\rangle$
			\item[] > (2) $\langle\langle X,\varepsilon\rangle,\overline{\kappa}\rangle \longmapsto_{cek} \langle c,\overline{\kappa}\rangle$ avec $\varepsilon(X) = c$
			\item[] CEK machine : $\langle\langle(\lambda y.(+$ $y$ $y)),\emptyset\rangle,\langle arg,\langle x,\{\langle f,\langle(\lambda y.(+$ $y$ $y)),\emptyset\rangle\rangle,\langle x,\langle\ulcorner 1\urcorner,\emptyset\rangle\rangle\}\rangle,mt\rangle\rangle$
			\item[] > (4) $\langle \langle V,\varepsilon\rangle,\langle arg,\langle N,\varepsilon'\rangle,\kappa\rangle\rangle \longmapsto_{cek} \langle \langle N,\varepsilon'\rangle,\langle fun,\langle V,\varepsilon\rangle,\overline{\kappa}\rangle\rangle$ si $V \notin X$
			\item[] CEK machine : $\langle\langle x,\{\langle f,\langle(\lambda y.(+$ $y$ $y)),\emptyset\rangle\rangle,\langle x,\langle\ulcorner 1\urcorner,\emptyset\rangle\rangle\}\rangle,\langle fun,\langle(\lambda y.(+$ $y$ $y)),\emptyset\rangle,mt\rangle\rangle$	
			\item[] > (2) $\langle\langle X,\varepsilon\rangle,\overline{\kappa}\rangle \longmapsto_{cek} \langle c,\overline{\kappa}\rangle$ avec $\varepsilon(X) = c$
			\item[] CEK machine : $\langle \langle\ulcorner 1\urcorner,\emptyset\rangle,\langle fun,\langle(\lambda y.(+$ $y$ $y)),\emptyset\rangle,mt\rangle\rangle$	
			\item[] > (3) $\langle\langle V,\varepsilon\rangle,\langle fun,\langle (\lambda X1.M),\varepsilon'\rangle,\overline{\kappa} \rangle \rangle \longmapsto_{cek} \langle \langle M,\varepsilon'[X1 \leftarrow \langle V,\varepsilon\rangle]\rangle,\overline{\kappa}\rangle$ si $V \notin X$
			\item[] CEK machine : $\langle\langle(+$ $y$ $y),\emptyset[y \leftarrow\langle\ulcorner 1\urcorner,\emptyset\rangle]\rangle ,mt\rangle$
			\item[] CEK machine : $\langle\langle(+$ $y$ $y),\{\langle y,\langle\ulcorner 1\urcorner,\emptyset\rangle\rangle\}\rangle ,mt\rangle$
			\item[] > (5) $\langle\langle(o^{n}$ $M$ $N...),\varepsilon\rangle,\overline{\kappa}\rangle \longmapsto_{cek} \langle \langle M,\varepsilon\rangle,\langle opd,\langle o^{n}\rangle,\langle \langle N,\varepsilon\rangle,...\rangle,\overline{\kappa}\rangle\rangle$
			\item[] CEK machine : $\langle\langle y,\{\langle y,\langle\ulcorner 1\urcorner,\emptyset\rangle\rangle\}\rangle ,\langle opd,\langle+\rangle,\langle\langle y,\{\langle y,\langle\ulcorner 1\urcorner,\emptyset\rangle\rangle\}\rangle\rangle,mt\rangle\rangle$
			\item[] > (2) $\langle\langle X,\varepsilon\rangle,\overline{\kappa}\rangle \longmapsto_{cek} \langle c,\overline{\kappa}\rangle$ avec $\varepsilon(X) = c$
			\item[] CEK machine : $\langle\langle\ulcorner 1\urcorner,\emptyset\rangle,\langle opd,\langle+\rangle,\langle\langle y,\{\langle y,\langle\ulcorner 1\urcorner,\emptyset\rangle\rangle\}\rangle\rangle,mt\rangle\rangle$
			\item[] > (7) $\langle \langle V,\varepsilon\rangle,\langle opd,\langle v',...o^{n}\rangle,\langle  \langle N,\varepsilon'\rangle,c,...\rangle,\overline{\kappa}\rangle\rangle \longmapsto_{cek} \langle \langle N,\varepsilon'\rangle,\langle opd,\langle  \langle V,\varepsilon\rangle,v',...o^{n}\rangle,\langle c,...\rangle,\overline{\kappa}\rangle\rangle$ si $V \notin X$
			\item[] CEK machine : $\langle\langle y,\{\langle y,\langle\ulcorner 1\urcorner,\emptyset\rangle\rangle\}\rangle,\langle opd,\langle\ulcorner 1\urcorner$ $+\rangle,\langle\rangle,mt\rangle\rangle$
			\item[] > (2) $\langle\langle X,\varepsilon\rangle,\overline{\kappa}\rangle \longmapsto_{cek} \langle c,\overline{\kappa}\rangle$ avec $\varepsilon(X) = c$
			\item[] CEK machine : $\langle\langle\ulcorner 1\urcorner,\emptyset\rangle,\langle opd,\langle\ulcorner 1\urcorner$ $+\rangle,\langle\rangle,mt\rangle\rangle$
			\item[] > (6) $\langle  \langle b,\varepsilon\rangle,\langle opd,\langle \langle b_{i},\varepsilon_{i}\rangle,...\langle b_{1},\varepsilon_{1}\rangle ,o^{n}\rangle,\langle\rangle,\overline{\kappa}\rangle\rangle \longmapsto_{cek} \langle \langle V,\emptyset\rangle,\overline{\kappa}\rangle$ avec $\delta(o^{n},b_{1},...b_{i},b) = V$
			\item[] CEK machine : $\langle\langle\ulcorner 2\urcorner,\emptyset\rangle,mt\rangle$
		\end{itemize}
	\end{ex}
	\newpage
	
	
	
	\begin{ex}\label{SECD} Voici un exemple de fonctionnement de la machine SECD : 
		\medbreak
			
		\begin{itemize}
			\item[] Conversion : $\textlbrackdbl(((\lambda f.\lambda x.f$ $x)$ $\lambda y.(+$ $y$ $y))$ $\ulcorner 1\urcorner)\textrbrackdbl_{secd}$
			\item[] Conversion : $\textlbrackdbl((\lambda f.\lambda x.f$ $x)$ $\lambda y.(+$ $y$ $y))\textrbrackdbl_{secd}$ $\textlbrackdbl\ulcorner 1\urcorner\textrbrackdbl_{secd}$ $ap$
			\item[] Conversion : $\textlbrackdbl(\lambda f.\lambda x.f$ $x)\textrbrackdbl_{secd}$ $\textlbrackdbl\lambda y.(+$ $y$ $y)\textrbrackdbl_{secd}$ $ap$ $\ulcorner 1\urcorner$ $ap$
			\item[] Conversion : $\langle f,\textlbrackdbl\lambda x.(f$ $x)\textrbrackdbl_{secd}\rangle$ $\langle y,y$ $y$ $prim_{+}\rangle$ $ap$ $\ulcorner 1\urcorner$ $ap$
			\item[] Conversion : $\langle f,\langle x,\textlbrackdbl f$ $x\textrbrackdbl_{secd}\rangle\rangle$ $\langle y,y$ $y$ $prim_{+}\rangle$ $ap$ $\ulcorner 1\urcorner$ $ap$
			\item[] Conversion : $\langle f,\langle x,f$ $x$ $ap\rangle\rangle$ $\langle y,y$ $y$ $prim_{+}\rangle$ $ap$ $\ulcorner 1\urcorner$ $ap$
			\item[] SECD Machine : $\langle\epsilon,\emptyset,\langle f,\langle x,f$ $x$ $ap\rangle\rangle$ $\langle y,y$ $y$ $prim_{+}\rangle$ $ap$ $\ulcorner 1\urcorner$ $ap,\epsilon\rangle$ 
			\item[] > (3) $\langle\widehat{S},\widehat{\varepsilon},\langle X,C'\rangle$ $\widehat{C},\widehat{D}\rangle \longmapsto_{secd} \langle\langle\langle X,C'\rangle,\varepsilon\rangle$ $\widehat{S},\widehat{\varepsilon},\widehat{C},\widehat{D}\rangle$
			\item[] SECD Machine : $\langle\langle\langle f,\langle x,f$ $x$ $ap\rangle\rangle,\emptyset\rangle,\emptyset,\langle y,y$ $y$ $prim_{+}\rangle$ $ap$ $\ulcorner 1\urcorner$ $ap,\epsilon\rangle$ 
			\item[] > (3) $\langle\widehat{S},\widehat{\varepsilon},\langle X,C'\rangle$ $\widehat{C},\widehat{D}\rangle \longmapsto_{secd} \langle\langle\langle X,C'\rangle,\varepsilon\rangle$ $\widehat{S},\widehat{\varepsilon},\widehat{C}\widehat{,D}\rangle$
			\item[] SECD Machine : $\langle\langle\langle y,y$ $y$ $prim_{+}\rangle,\emptyset\rangle$ $\langle\langle f,\langle x,f$ $x$ $ap\rangle\rangle,\emptyset\rangle,\emptyset,ap$ $\ulcorner 1\urcorner$ $ap,\epsilon\rangle$
			\item[] > (4) $\langle\widehat{V}$ $\langle\langle X,C'\rangle,\varepsilon'\rangle$ $\widehat{S},\widehat{\varepsilon},ap$ $\widehat{C},\widehat{D}\rangle \longmapsto_{secd} \langle\epsilon,\varepsilon'[X \leftarrow \widehat{V}],C',\langle\widehat{S},\widehat{\varepsilon},\widehat{C},\widehat{D}\rangle\rangle$
			\item[] SECD Machine : $\langle\epsilon,\emptyset[f \leftarrow \langle\langle y,y$ $y$ $prim_{+}\rangle,\emptyset\rangle],\langle x,f$ $x$ $ap\rangle,\langle\epsilon,\emptyset,\ulcorner 1\urcorner$ $ap,\epsilon\rangle\rangle$
			\item[] SECD Machine : $\langle\epsilon,\{\langle f,\langle\langle y,y$ $y$ $prim_{+}\rangle,\emptyset\rangle\rangle\},\langle x,f$ $x$ $ap\rangle,\langle\epsilon,\emptyset,\ulcorner 1\urcorner$ $ap,\epsilon\rangle\rangle$
			\item[] >  (3) $\langle\widehat{S},\widehat{\varepsilon},\langle X,C'\rangle$ $\widehat{C},\widehat{D}\rangle \longmapsto_{secd} \langle\langle\langle X,C'\rangle,\varepsilon\rangle$ $\widehat{S},\widehat{\varepsilon},\widehat{C},\widehat{D}\rangle$
			\item[] SECD Machine : $\langle\langle\langle x,f$ $x$ $ap\rangle,\{\langle f,\langle\langle y,y$ $y$ $prim_{+}\rangle,\emptyset\rangle\rangle\}\rangle,\{f,\langle\langle y,y$ $y$ $prim_{+}\rangle,\emptyset\rangle\},\emptyset,\langle\epsilon,\emptyset,\ulcorner 1\urcorner$ $ap,\epsilon\rangle\rangle$
			\item[] > (5) $\langle\widehat{V}$ $\widehat{S},\widehat{\varepsilon},\emptyset,\langle\widehat{S'},\widehat{\varepsilon'},\widehat{C'},\widehat{D}\rangle\rangle \longmapsto_{secd} \langle \widehat{V}$ $\widehat{S'},\widehat{\varepsilon'},\widehat{C'},\widehat{D}\rangle$
			\item[] SECD Machine : $\langle\langle\langle x,f$ $x$ $ap\rangle,\{\langle f,\langle\langle y,y$ $y$ $prim_{+}\rangle,\emptyset\rangle\rangle\}\rangle,\emptyset,\ulcorner 1\urcorner$ $ap,\epsilon\rangle$
			\item[] >  (1) $\langle\widehat{S},\widehat{\varepsilon},b$ $\widehat{C},\widehat{D}\rangle \longmapsto_{secd} \langle b$ $\widehat{S},\widehat{\varepsilon},\widehat{C},\widehat{D}\rangle$
			\item[] SECD Machine :  $\langle\ulcorner 1\urcorner$ $\langle\langle x,f$ $x$ $ap\rangle,\{\langle f,\langle\langle y,y$ $y$ $prim_{+}\rangle,\emptyset\rangle\rangle\}\rangle,\emptyset,ap,\epsilon\rangle$
			\item[] >  (4) $\langle\widehat{V}$ $\langle\langle X,C'\rangle,\varepsilon'\rangle$ $\widehat{S},\widehat{\varepsilon},ap$ $\widehat{C},\widehat{D}\rangle \longmapsto_{secd} \langle\epsilon,\varepsilon'[X \leftarrow \widehat{V}],C',\langle\widehat{S},\widehat{\varepsilon},\widehat{C},\widehat{D}\rangle\rangle$
			\item[] SECD Machine : $\langle\epsilon,\{\langle f,\langle\langle y,y$ $y$ $prim_{+}\rangle,\emptyset\rangle\rangle\}[x \leftarrow \ulcorner 1\urcorner],f$ $x$ $ap,\langle\epsilon,\emptyset,\epsilon,\epsilon\rangle\rangle$
			\item[] SECD Machine : $\langle\epsilon,\{\langle f,\langle\langle y,y$ $y$ $prim_{+}\rangle,\emptyset\rangle\rangle,\langle x,\ulcorner 1\urcorner\rangle\},f$ $x$ $ap,\langle\epsilon,\emptyset,\epsilon,\epsilon\rangle\rangle$
			\item[] > (2) $\langle\widehat{S},\widehat{\varepsilon},X$ $\widehat{C},\widehat{D}\rangle \longmapsto_{secd} \langle \widehat{V}$ $\widehat{S},\widehat{\varepsilon},\widehat{C},\widehat{D}\rangle$ où $\widehat{V} = \varepsilon(X)$
			\item[] SECD Machine : $\langle\langle\langle y,y$ $y$ $prim_{+}\rangle,\emptyset\rangle,\{\langle f,\langle\langle y,y$ $y$ $prim_{+}\rangle,\emptyset\rangle\rangle,\langle x,\ulcorner 1\urcorner\rangle\},x$ $ap,\langle\epsilon,\emptyset,\epsilon,\epsilon\rangle\rangle$
			\item[] > (2) $\langle\widehat{S},\widehat{\varepsilon},X$ $\widehat{C},\widehat{D}\rangle \longmapsto_{secd} \langle \widehat{V}$ $\widehat{S},\widehat{\varepsilon},v~
			\widehat{C},\widehat{D}\rangle$ où $\widehat{V} = \varepsilon(X)$
			\item[] SECD Machine : $\langle\ulcorner 1\urcorner$ $\langle\langle y,y$ $y$ $prim_{+}\rangle,\emptyset\rangle,\{\langle f,\langle\langle y,y$ $y$ $prim_{+}\rangle,\emptyset\rangle\rangle,\langle x,\ulcorner 1\urcorner\rangle\},ap,\langle\epsilon,\emptyset,\epsilon,\epsilon\rangle\rangle$
			\item[] > (4) $\langle\widehat{V}$ $\langle\langle X,C'\rangle,\varepsilon'\rangle$ $\widehat{S},\widehat{\varepsilon},ap$ $\widehat{C},\widehat{D}\rangle \longmapsto_{secd} \langle\epsilon,\varepsilon'[X \leftarrow \widehat{V}],C',\langle\widehat{S},\widehat{\varepsilon},\widehat{C},\widehat{D}\rangle\rangle$
			\item[] SECD Machine :	$\langle\epsilon,\emptyset[y \leftarrow \ulcorner 1\urcorner],y$ $y$ $prim_{+},\langle\epsilon,\{\langle f,\langle\langle y,y$ $y$ $prim_{+}\rangle,\emptyset\rangle\rangle,\langle x,\ulcorner 1\urcorner\rangle\} ,\emptyset,\langle\epsilon,\emptyset,\epsilon,\epsilon\rangle\rangle\rangle$
			\item[] SECD Machine : $\langle\epsilon,\{\langle y,\ulcorner 1\urcorner\rangle\},y$ $y$ $prim_{+},\langle\epsilon,\{\langle f,\langle\langle y,y$ $y$ $prim_{+}\rangle,\emptyset\rangle\rangle,\langle x,\ulcorner 1\urcorner\rangle\} ,\emptyset,\langle\epsilon,\emptyset,\epsilon,\epsilon\rangle\rangle\rangle$
			\item[] > (2) $\langle\widehat{S},\widehat{\varepsilon},X$ $\widehat{C},\widehat{D}\rangle \longmapsto_{secd} \langle \widehat{V}$ $\widehat{S},\widehat{\varepsilon},\widehat{C},\widehat{D}\rangle$ où $\widehat{V} = \varepsilon(X)$
			\item[] SECD Machine : $\langle\ulcorner 1\urcorner,\{\langle y,\ulcorner 1\urcorner\rangle\},y$ $prim_{+},\langle\epsilon,\{\langle f,\langle\langle y,y$ $y$ $prim_{+}\rangle,\emptyset\rangle\rangle,\langle x,\ulcorner 1\urcorner\rangle\} ,\emptyset,\langle\epsilon,\emptyset,\epsilon,\epsilon\rangle\rangle\rangle$
			\item[] > (2) $\langle\widehat{S},\widehat{\varepsilon},X$ $\widehat{C},\widehat{D}\rangle \longmapsto_{secd} \langle \widehat{V}$ $\widehat{S},\widehat{\varepsilon},\widehat{C},\widehat{D}\rangle$ où $\widehat{V} = \varepsilon(X)$
			\item[] SECD Machine : $\langle\ulcorner 1\urcorner$ $\ulcorner 1\urcorner,\{\langle y,\ulcorner 1\urcorner\rangle\},prim_{+},\langle\epsilon,\{\langle f,\langle\langle y,y$ $y$ $prim_{+}\rangle,\emptyset\rangle\rangle,\langle x,\ulcorner 1\urcorner\rangle\} ,\emptyset,\langle\epsilon,\emptyset,\epsilon,\epsilon\rangle\rangle\rangle$
			\item[] > (6) $\langle b_{1}$ $...$ $b_{n}\widehat{S},\widehat{\varepsilon},prim_{o^{n}}$ $\widehat{C},\widehat{D}\rangle \longmapsto_{secd} \langle \widehat{V}$ $\widehat{S},\widehat{\varepsilon},\widehat{C},\widehat{D}\rangle$ où $\widehat{V} = \delta(o^{n},b_1,...b_{n})$
			\item[] SECD Machine : $\langle\ulcorner 2\urcorner,\{\langle y,\ulcorner 1\urcorner\rangle\},\emptyset,\langle\epsilon,\{\langle f,\langle\langle y,y$ $y$ $prim_{+}\rangle,\emptyset\rangle\rangle,\langle x,\ulcorner 1\urcorner\rangle\} ,\emptyset,\langle\epsilon,\emptyset,\epsilon,\epsilon\rangle\rangle\rangle$
			\item[] > (5) $\langle\widehat{V}$ $\widehat{S},\widehat{\varepsilon},\emptyset,\langle\widehat{S'},\widehat{\varepsilon'},\widehat{C'},\widehat{D}\rangle\rangle \longmapsto_{secd} \langle \widehat{V}$ $\widehat{S'},\widehat{\varepsilon'},\widehat{C'},\widehat{D}\rangle$
			\item[] SECD Machine : $\langle\ulcorner 2\urcorner,\{\langle f,\langle\langle y,y$ $y$ $prim_{+}\rangle,\emptyset\rangle\rangle,\langle x,\ulcorner 1\urcorner\rangle\} ,\emptyset,\langle\epsilon,\emptyset,\epsilon,\epsilon\rangle\rangle$
			\item[] > (5) $\langle\widehat{V}$ $\widehat{S},\widehat{\varepsilon},\emptyset,\langle\widehat{S'},\widehat{\varepsilon'},\widehat{C'},\widehat{D}\rangle\rangle \longmapsto_{secd} \langle \widehat{V}$ $\widehat{S'},\widehat{\varepsilon'},\widehat{C'},\widehat{D}\rangle$
			\item[] SECD Machine : $\langle\ulcorner 2\urcorner,\emptyset,\epsilon,\epsilon\rangle$
		\end{itemize}
	\end{ex}
	\newpage
	
	
	
	\begin{ex} \label{TTS} 	Voici un exemple de fonctionnement de la machine SECD :	 
		\medbreak
		
		\begin{itemize}
			\item[] TTS Machine : $\langle\langle \epsilon,\emptyset,\langle s,\langle ,s~\langle,6\rangle~\langle,9\rangle~present\rangle~spawn~\langle ,s~emit\rangle~spawn~ap\rangle~init~ap,\emptyset\rangle,\emptyset,\emptyset\rangle$
			\item[] > \textbf{Abstraction} 	$\langle S,E,\langle X,C'\rangle$ $C,D\rangle
			\longrightarrow_{TTS} 
			\langle \langle\langle X,C'\rangle,E\rangle$ $S,E,C,D\rangle$
			\item[] TTS Machine : $\langle\langle \langle\langle s,\langle ,s~\langle,6\rangle~\langle,9\rangle~present\rangle~spawn~\langle ,s~emit\rangle~spawn~ap\rangle,\emptyset\rangle,\emptyset,init~ap,\emptyset\rangle,\emptyset,\emptyset\rangle$
			\item[] > \textbf{Initialisation signal} $\langle\langle S,E,init~C,D\rangle,TL,SI\rangle 
			\longrightarrow_{TTS}
			\langle\langle s~S,E,C,D\rangle,TL,SI'\rangle$
			avec $\iota(SI) = (s,SI')$
			\item[] TTS Machine : $\langle\langle 0~\langle\langle s,\langle ,s~\langle,6\rangle~\langle,9\rangle~present\rangle~spawn~\langle ,s~emit\rangle~spawn~ap\rangle,\emptyset\rangle,\emptyset,ap,\emptyset\rangle,\emptyset,\{\langle 0,\langle false,\emptyset\rangle\rangle\}\rangle$ 
			\item[] \textbf{Application} $\langle V~\langle\langle X,C'\rangle,E'\rangle~S,E,ap~C,D\rangle
			\longrightarrow_{TTS} 
			\langle \emptyset,E'[X \leftarrow V],C',\langle S,E,C,D\rangle\rangle$
			\item[] TTS Machine : $\langle\langle\epsilon,\emptyset[s \leftarrow 0],\langle ,s~\langle,6\rangle~\langle,9\rangle~present\rangle~spawn~\langle ,s~emit\rangle~spawn~ap,\langle \epsilon,\emptyset,\epsilon,\emptyset\rangle\rangle,\emptyset,\{\langle 0,\langle false,\emptyset\rangle\rangle\}\rangle$ 
			\item[] TTS Machine : $\langle\langle\epsilon,\{\langle s,0\rangle\},\langle ,s~\langle,6\rangle~\langle,9\rangle~present\rangle~spawn~\langle ,s~emit\rangle~spawn~ap,\langle \epsilon,\emptyset,\epsilon,\emptyset\rangle\rangle,\emptyset,\{\langle 0,\langle false,\emptyset\rangle\rangle\}\rangle$ 
			\item[] > \textbf{Abstraction} 	$\langle S,E,\langle X,C'\rangle$ $C,D\rangle
			\longrightarrow_{TTS} 
			\langle \langle\langle X,C'\rangle,E\rangle$ $S,E,C,D\rangle$
			\item[] TTS Machine : $\langle \langle\langle ,s~\langle,6\rangle~\langle,9\rangle~present\rangle,\{\langle s,0\rangle\}\rangle,\{\langle s,0\rangle\},spawn~\langle ,s~emit\rangle~spawn~ap,\langle \epsilon,\emptyset,\epsilon,\emptyset\rangle\rangle,\emptyset,\{\langle 0,\langle false,\emptyset\rangle\rangle\}\rangle$ 
			\item[] > \textbf{Création thread} $\langle\langle\langle\langle X,C'\rangle, E\rangle~S,E,spawn~C,D\rangle,TL,SI\rangle 
			\longrightarrow_{TTS} 
			\langle\langle S,E,C,D\rangle,TL~\langle S,E,C',D\rangle,SI\rangle$
			\item[] TTS Machine : $\langle\langle\epsilon,\{\langle s,0\rangle\},\langle ,s~emit\rangle~spawn~ap,\langle \epsilon,\emptyset,\epsilon,\emptyset\rangle\rangle,\{\langle\epsilon,\{\langle s,0\rangle\},s~\langle,6\rangle~\langle,9\rangle~present,\langle \epsilon,\emptyset,\epsilon,\emptyset\rangle\rangle\},\{\langle 0,\langle false,\emptyset\rangle\rangle\}\rangle$ 
			\item[] > \textbf{Abstraction} 	$\langle S,E,\langle X,C'\rangle$ $C,D\rangle
			\longrightarrow_{TTS} 
			\langle \langle\langle X,C'\rangle,E\rangle$ $S,E,C,D\rangle$
			\item[] TTS Machine : $\langle \langle\langle ,s~emit\rangle,\{\langle s,0\rangle\}\rangle,\{\langle s,0\rangle\},spawn~ap,\langle \epsilon,\emptyset,\epsilon,\emptyset\rangle\rangle,\{\langle\epsilon,\{\langle s,0\rangle\},s~\langle,6\rangle~\langle,9\rangle~present,\langle \epsilon,\emptyset,\epsilon,\emptyset\rangle\rangle\}\\,\{\langle 0,\langle false,\emptyset\rangle\rangle\}\rangle$ 
			\item[] > \textbf{Création thread} $\langle\langle\langle\langle X,C'\rangle, E\rangle~S,E,spawn~C,D\rangle,TL,SI\rangle 
			\longrightarrow_{TTS} 
			\langle\langle S,E,C,D\rangle,TL~\langle S,E,C',D\rangle,SI\rangle$
			\item[] TTS Machine : $\langle\langle\epsilon,\{\langle s,0\rangle\},ap,\langle \epsilon,\emptyset,\epsilon,\emptyset\rangle\rangle,\{\langle\epsilon,\{\langle s,0\rangle\},s~\langle,6\rangle~\langle,9\rangle~present,\langle \epsilon,\emptyset,\epsilon,\emptyset\rangle\rangle,\langle\epsilon,\{\langle s,0\rangle\},s~emit,\langle \epsilon,\emptyset,\epsilon,\emptyset\rangle\rangle\}\\,\{\langle 0,\langle false,\emptyset\rangle\rangle\}\rangle$ 
			\item[] > \textbf{Application neutre} $\langle S,E,ap~C,D\rangle
			\longrightarrow_{TTS} 
			\langle S,E,C,D\rangle$
			\item[] TTS Machine : $\langle\langle\epsilon,\{\langle s,0\rangle\},\epsilon,\langle \epsilon,\emptyset,\epsilon,\emptyset\rangle\rangle,\{\langle\epsilon,\{\langle s,0\rangle\},s~\langle,6\rangle~\langle,9\rangle~present,\langle \epsilon,\emptyset,\epsilon,\emptyset\rangle\rangle,\langle\epsilon,\{\langle s,0\rangle\},s~emit,\langle \epsilon,\emptyset,\epsilon,\emptyset\rangle\rangle\}\\,\{\langle 0,\langle false,\emptyset\rangle\rangle\}\rangle$ 
			\item[] > \textbf{Récupération de sauvegarde avec pile vide} $\langle S,E,\epsilon,\langle S',E',C,D\rangle\rangle
			\longrightarrow_{TTS} 
			\langle S',E',C,D\rangle$
			\item[] TTS Machine : $\langle\langle\epsilon,\emptyset,\epsilon,\emptyset\rangle,\{\langle\epsilon,\{\langle s,0\rangle\},s~\langle,6\rangle~\langle,9\rangle~present,\langle \epsilon,\emptyset,\epsilon,\emptyset\rangle\rangle,\langle\epsilon,\{\langle s,0\rangle\},s~emit,\langle \epsilon,\emptyset,\epsilon,\emptyset\rangle\rangle\},\{\langle 0,\langle false,\emptyset\rangle\rangle\}\rangle$
			\item[] > \textbf{Récupération dans la file d'attente}
			$\langle\langle S,E,\epsilon,\emptyset\rangle,\langle S',E',C,D\rangle~TL,SI\rangle 
			\longrightarrow_{TTS} 
			\langle\langle S',E',C,D\rangle,TL,SI\rangle$
			\item[] TTS Machine : $\langle\langle\epsilon,\{\langle s,0\rangle\},s~\langle,6\rangle~\langle,9\rangle~present,\langle \epsilon,\emptyset,\epsilon,\emptyset\rangle\rangle,\{\langle\epsilon,\{\langle s,0\rangle\},s~emit,\langle \epsilon,\emptyset,\epsilon,\emptyset\rangle\rangle\},\{\langle 0,\langle false,\emptyset\rangle\rangle\}\rangle$
			\item[] > \textbf{Substitution} $\langle S,E,X~C,D\rangle
			\longrightarrow_{TTS} 
			\langle V~S,E,C,D\rangle$ avec $E(X) = V$
			\item[] TTS Machine : $\langle\langle 0,\{\langle s,0\rangle\},\langle,6\rangle~\langle,9\rangle~present,\langle \epsilon,\emptyset,\epsilon,\emptyset\rangle\rangle,\{\langle\epsilon,\{\langle s,0\rangle\},s~emit,\langle \epsilon,\emptyset,\epsilon,\emptyset\rangle\rangle\},\{\langle 0,\langle false,\emptyset\rangle\rangle\}\rangle$
			\item[] > \textbf{Abstraction} 	$\langle S,E,\langle X,C'\rangle$ $C,D\rangle
			\longrightarrow_{TTS} 
			\langle \langle\langle X,C'\rangle,E\rangle$ $S,E,C,D\rangle$
			\item[] TTS Machine : $\langle\langle \langle\langle,6\rangle,\{\langle s,0\rangle\}\rangle~0,\{\langle s,0\rangle\},\langle,9\rangle~present,\langle \epsilon,\emptyset,\epsilon,\emptyset\rangle\rangle,\{\langle\epsilon,\{\langle s,0\rangle\},s~emit,\langle \epsilon,\emptyset,\epsilon,\emptyset\rangle\rangle\},\{\langle 0,\langle false,\emptyset\rangle\rangle\}\rangle$
			\item[] > \textbf{Abstraction} 	$\langle S,E,\langle X,C'\rangle$ $C,D\rangle
			\longrightarrow_{TTS} 
			\langle \langle\langle X,C'\rangle,E\rangle$ $S,E,C,D\rangle$
			\item[] TTS Machine : $\langle\langle \langle\langle,9\rangle,\{\langle s,0\rangle\}\rangle~\langle\langle,6\rangle,\{\langle s,0\rangle\}\rangle~0,\{\langle s,0\rangle\},present,\langle \epsilon,\emptyset,\epsilon,\emptyset\rangle\rangle,\{\langle\epsilon,\{\langle s,0\rangle\},s~emit,\langle \epsilon,\emptyset,\epsilon,\emptyset\rangle\rangle\},\{\langle 0,\langle false,\\\emptyset\rangle\rangle\}\rangle$
			\item[] > \textbf{Thread bloqué remplacé} $\langle\langle \langle\langle X',C''\rangle,E\rangle~\langle\langle X,C'\rangle,E\rangle~s~S,E,present~C,D\rangle,\langle S',E',C''',D'\rangle$ $TL,SI\rangle 
			\\\longrightarrow_{TTS} 
			\langle\langle S',E',C''',D'\rangle,TL,SI'\rangle$ 
			\\avec $SI(s) = \langle faux,ST\rangle$
			et $SI'(s) = \langle faux,ST~\langle \langle\langle X',C''\rangle,E\rangle~\langle\langle X,C'\rangle,E\rangle~s~S,E,present~C,D\rangle\rangle$
			\item[] TTS Machine : $\langle \langle\epsilon,\{\langle s,0\rangle\},s~emit,\langle \epsilon,\emptyset,\epsilon,\emptyset\rangle\rangle,\emptyset,\{\langle 0,\langle false,\\\{\langle \langle\langle,9\rangle,\{\langle s,0\rangle\}\rangle~\langle\langle,6\rangle,\{\langle s,0\rangle\}\rangle~0,\{\langle s,0\rangle\},present,\langle \epsilon,\emptyset,\epsilon,\emptyset\rangle\rangle\}\rangle\rangle\}\rangle$
			\item[] > \textbf{Substitution} $\langle S,E,X~C,D\rangle
			\longrightarrow_{TTS} 
			\langle V~S,E,C,D\rangle$ avec $E(X) = V$
			\item[] TTS Machine : $\langle \langle 0,\{\langle s,0\rangle\},emit,\langle \epsilon,\emptyset,\epsilon,\emptyset\rangle\rangle,\emptyset,\{\langle 0,\langle false,\\\{\langle \langle\langle,9\rangle,\{\langle s,0\rangle\}\rangle~\langle\langle,6\rangle,\{\langle s,0\rangle\}\rangle~0,\{\langle s,0\rangle\},present,\langle \epsilon,\emptyset,\epsilon,\emptyset\rangle\rangle\}\rangle\rangle\}\rangle$
			\item[] > \textbf{Émettre :} 
			$\langle\langle s~S,E,emit~C,D\rangle,TL,SI\rangle 
			\longrightarrow_{TTS}
			\langle\langle S,E,C,D\rangle,TL,SI'\rangle$
			avec $\varepsilon(s,SI) = SI'$
			\item[] TTS Machine : $\langle \langle \epsilon,\{\langle s,0\rangle\},\epsilon,\langle \epsilon,\emptyset,\epsilon,\emptyset\rangle\rangle,\{\langle \langle\langle,9\rangle,\{\langle s,0\rangle\}\rangle~\langle\langle,6\rangle,\{\langle s,0\rangle\}\rangle~0,\{\langle s,0\rangle\},present,\langle \epsilon,\emptyset,\epsilon,\emptyset\rangle\rangle\},\{\langle 0,\langle true,\\\emptyset\rangle\rangle\}\rangle$
			\item[] > \textbf{Récupération de sauvegarde avec pile vide} $\langle S,E,\epsilon,\langle S',E',C,D\rangle\rangle
			\longrightarrow_{TTS} 
			\langle S',E',C,D\rangle$
			\item[] TTS Machine : $\langle \langle \epsilon,\emptyset,\epsilon,\emptyset\rangle,\{\langle \langle\langle,9\rangle,\{\langle s,0\rangle\}\rangle~\langle\langle,6\rangle,\{\langle s,0\rangle\}\rangle~0,\{\langle s,0\rangle\},present,\langle \epsilon,\emptyset,\epsilon,\emptyset\rangle\rangle\},\{\langle 0,\langle true,\emptyset\rangle\rangle\}\rangle$
			\item[] > \textbf{Récupération dans la file d'attente}
			$\langle\langle S,E,\epsilon,\emptyset\rangle,\langle S',E',C,D\rangle~TL,SI\rangle 
			\longrightarrow_{TTS} 
			\langle\langle S',E',C,D\rangle,TL,SI\rangle$
			\item[] TTS Machine : $\langle \langle \langle\langle,9\rangle,\{\langle s,0\rangle\}\rangle~\langle\langle,6\rangle,\{\langle s,0\rangle\}\rangle~0,\{\langle s,0\rangle\},present,\langle \epsilon,\emptyset,\epsilon,\emptyset\rangle\rangle,\emptyset,\{\langle 0,\langle true,\emptyset\rangle\rangle\}\rangle$
			\item[] > \textbf{Présence d'un signal} $\langle\langle \langle\langle X',C''\rangle,E\rangle~\langle\langle X,C'\rangle,E\rangle~s~S,E,present~C,D\rangle,TL,SI\rangle 
			\longrightarrow_{TTS} 
			\langle\langle S,E,C'~C,D\rangle,TL,SI\rangle$ 
			\\avec $SI(s) = \langle vraie,ST\rangle$
			\item[] TTS Machine : $\langle \langle \epsilon,\{\langle s,0\rangle\},6,\langle \epsilon,\emptyset,\epsilon,\emptyset\rangle\rangle,\emptyset,\{\langle 0,\langle true,\emptyset\rangle\rangle\}\rangle$
			\item[] > \textbf{Constante} $\langle S,E,n~C,D\rangle 
			\longrightarrow_{TTS} 
			\langle n~S,E,C,D\rangle$ avec $n$ une constante $b$ ou un signal $s$
			\item[] TTS Machine : $\langle \langle 6,\{\langle s,0\rangle\},\epsilon,\langle \epsilon,\emptyset,\epsilon,\emptyset\rangle\rangle,\emptyset,\{\langle 0,\langle true,\emptyset\rangle\rangle\}\rangle$
			\item[] > \textbf{Récupération de sauvegarde} $\langle V~S,E,\epsilon,\langle S',E',C,D\rangle\rangle
			\longrightarrow_{TTS} 
			\langle V~S',E',C,D\rangle$
			\item[] TTS Machine : $\langle \langle 6,\emptyset,\epsilon,\emptyset\rangle,\emptyset,\{\langle 0,\langle true,\emptyset\rangle\rangle\}\rangle$
		\end{itemize}
	\end{ex}
	\newpage
	
	
	
	\begin{ex} \label{TTSI}	Voici un exemple de fonctionnement de la machine TTSI :
		\medbreak
		
		\begin{itemize}
			\item[] Machine TTSI $\langle\langle 0,\epsilon,\emptyset,\langle s,\langle s', \langle, s'~\langle,1\rangle~\langle,s~0~3~get~s~0~3~get~prim_{+}\rangle~present\rangle~spawn~10~s~put~ap\rangle\rangle~init~ap~init~ap,\emptyset\rangle,\emptyset,\emptyset,1\rangle$
			\item[] > \textbf{Abstraction} $\langle S,E,\langle X,C'\rangle~C,D\rangle
			\longrightarrow_{TTSI} 
			\langle \langle\langle X,C'\rangle,E\rangle~S,E,C,D\rangle$
			\item[] Machine TTSI $\langle\langle 0,\langle\langle s,\langle s', \langle, s'~\langle,1\rangle~\langle,s~0~3~get~s~0~3~get~prim_{+}\rangle~present\rangle~spawn~10~s~put~ap\rangle\rangle,\emptyset \rangle,\emptyset,init~ap~init~ap,\emptyset\rangle,\\\emptyset,\emptyset,1\rangle$
			\item[] > \textbf{Initialisation Signal} $\langle\langle I,S,E,init~C,D\rangle,TL,SI\rangle 
			\longrightarrow_{TTSI}
			\langle\langle I,s~S,E,C,D\rangle,TL,SI'\rangle$
			avec $\iota(SI) = (s,SI')$
			\item[] Machine TTSI $\langle\langle 0,\langle 0~\langle s,\langle s', \langle, s'~\langle,1\rangle~\langle,s~0~3~get~s~0~3~get~prim_{+}\rangle~present\rangle~spawn~10~s~put~ap\rangle\rangle,\emptyset \rangle,\emptyset,ap~init~ap,\emptyset\rangle,\\\emptyset,\{\langle 0,\langle false,\emptyset,\emptyset,\emptyset\rangle\rangle\},1\rangle$
			\item[] > \textbf{Application} $\langle V~\langle\langle X,C'\rangle,E'\rangle~S,E,ap~C,D\rangle
			\longrightarrow_{TTSI} 
			\langle \emptyset,E'[X \leftarrow V],C',\langle S,E,C,D\rangle\rangle$
			\item[] Machine TTSI $\langle\langle 0,\epsilon,\emptyset[s \leftarrow 0],\langle s', \langle, s'~\langle,1\rangle~\langle,s~0~3~get~s~0~3~get~prim_{+}\rangle~present\rangle~spawn~10~s~put~ap\rangle,\langle\epsilon,\emptyset,init~ap,\emptyset\rangle\rangle,\\\emptyset,\{\langle 0,\langle false,\emptyset,\emptyset,\emptyset\rangle\rangle\},1\rangle$
			\item[] Machine TTSI $\langle\langle 0,\epsilon,\{\langle s,0\rangle\},\langle s', \langle, s'~\langle,1\rangle~\langle,s~0~3~get~s~0~3~get~prim_{+}\rangle~present\rangle~spawn~10~s~put~ap\rangle,\langle\epsilon,\emptyset,init~ap,\emptyset\rangle\rangle,\\\emptyset,\{\langle 0,\langle false,\emptyset,\emptyset,\emptyset\rangle\rangle\},1\rangle$
			\item[] > \textbf{Abstraction} $\langle S,E,\langle X,C'\rangle~C,D\rangle
			\longrightarrow_{TTSI} 
			\langle \langle\langle X,C'\rangle,E\rangle~S,E,C,D\rangle$
			\item[] Machine TTSI $\langle\langle 0,\langle\langle s', \langle, s'~\langle,1\rangle~\langle,s~0~3~get~s~0~3~get~prim_{+}\rangle~present\rangle~spawn~10~s~put~ap\rangle,\{\langle s,0\rangle\}\rangle,\{\langle s,0\rangle\},\epsilon,\\\langle\epsilon,\emptyset,init~ap,\emptyset\rangle\rangle,\emptyset,\{\langle 0,\langle false,\emptyset,\emptyset,\emptyset\rangle\rangle\},1\rangle$
			\item[] > \textbf{Récupération de sauvegarde} $\langle V~S,E,\epsilon,\langle S',E',C,D\rangle\rangle
			\longrightarrow_{TTSI} 
			\langle V~S',E',C,D\rangle$
			\item[] Machine TTSI $\langle\langle 0,\langle\langle s', \langle, s'~\langle,1\rangle~\langle,s~0~3~get~s~0~3~get~prim_{+}\rangle~present\rangle~spawn~10~s~put~ap\rangle,\{\langle s,0\rangle\}\rangle,\emptyset,init~ap,\emptyset\rangle\\,\emptyset,\{\langle 0,\langle false,\emptyset,\emptyset,\emptyset\rangle\rangle\},1\rangle$
			\item[] > \textbf{Initialisation Signal} $\langle\langle I,S,E,init~C,D\rangle,TL,SI\rangle 
			\longrightarrow_{TTSI}
			\langle\langle I,s~S,E,C,D\rangle,TL,SI'\rangle$
			avec $\iota(SI) = (s,SI')$
			\item[] Machine TTSI $\langle\langle 0, 1~\langle\langle s', \langle, s'~\langle,1\rangle~\langle,s~0~3~get~s~0~3~get~prim_{+}\rangle~present\rangle~spawn~10~s~put~ap\rangle,\{\langle s,0\rangle\}\rangle,\emptyset,ap,\emptyset\rangle\\,\emptyset,\{\langle 0,\langle false,\emptyset,\emptyset,\emptyset\rangle\rangle,\langle 1,\langle false,\emptyset,\emptyset,\emptyset\rangle\rangle\},1\rangle$
			\item[] > \textbf{Application} $\langle V~\langle\langle X,C'\rangle,E'\rangle~S,E,ap~C,D\rangle
			\longrightarrow_{TTSI} 
			\langle \emptyset,E'[X \leftarrow V],C',\langle S,E,C,D\rangle\rangle$
			\item[] Machine TTSI $\langle\langle 0, \epsilon ,\{\langle s,0\rangle\}[s' \leftarrow 1],\langle, s'~\langle,1\rangle~\langle,s~0~3~get~s~0~3~get~prim_{+}\rangle~present\rangle~spawn~10~s~put~ap,\langle\epsilon,\emptyset,\epsilon,\emptyset\rangle\rangle\\,\emptyset,\{\langle 0,\langle false,\emptyset,\emptyset,\emptyset\rangle\rangle,\langle 1,\langle false,\emptyset,\emptyset,\emptyset\rangle\rangle\},1\rangle$
			\item[] Machine TTSI $\langle\langle 0, \epsilon ,\{\langle s,0\rangle,\langle s',1\rangle\},\langle, s'~\langle,1\rangle~\langle,s~0~3~get~s~0~3~get~prim_{+}\rangle~present\rangle~spawn~10~s~put~ap,\langle\epsilon,\emptyset,\epsilon,\emptyset\rangle\rangle\\,\emptyset,\{\langle 0,\langle false,\emptyset,\emptyset,\emptyset\rangle\rangle,\langle 1,\langle false,\emptyset,\emptyset,\emptyset\rangle\rangle\},1\rangle$
			\item[] > \textbf{Abstraction} $\langle S,E,\langle X,C'\rangle~C,D\rangle
			\longrightarrow_{TTSI} 
			\langle \langle\langle X,C'\rangle,E\rangle~S,E,C,D\rangle$
			\item[] Machine TTSI $\langle\langle 0, \langle, s'~\langle,1\rangle~\langle,s~0~3~get~s~0~3~get~prim_{+}\rangle~present\rangle,\{\langle s,0\rangle,\langle s',1\rangle\}\rangle ,\{\langle s,0\rangle,\langle s',1\rangle\},spawn~10~s~put~ap,\\\langle\epsilon,\emptyset,\epsilon,\emptyset\rangle\rangle,\emptyset,\{\langle 0,\langle false,\emptyset,\emptyset,\emptyset\rangle\rangle,\langle 1,\langle false,\emptyset,\emptyset,\emptyset\rangle\rangle\},1\rangle$
			\item[] > \textbf{Création thread} $\langle\langle I,\langle\langle X,C'\rangle, E\rangle~S,E,spawn~C,D\rangle,TL,SI,IP\rangle 
			\longrightarrow_{TTSI} 
			\\\langle\langle I,S,E,C,D\rangle,TL~\langle IP,S,E,C',D\rangle,SI,IP+1\rangle$
			\item[] Machine TTSI $\langle\langle 0,\epsilon,\{\langle s,0\rangle,\langle s',1\rangle\},10~s~put~ap,\langle\epsilon,\emptyset,\epsilon,\emptyset\rangle\rangle,\{\langle 1,\epsilon,\{\langle s,0\rangle,\langle s',1\rangle\}, s'~\langle,1\rangle~\langle,s~0~3~get~s~0~3~get~prim_{+}\rangle~present ,\\\langle\epsilon,\emptyset,\epsilon,\emptyset\rangle\rangle\},\{\langle 0,\langle false,\emptyset,\emptyset,\emptyset\rangle\rangle,\langle 1,\langle false,\emptyset,\emptyset,\emptyset\rangle\rangle\},2\rangle$
			\item[] > \textbf{Constante} $\langle S,E,n~C,D\rangle 
			\longrightarrow_{TTSI} 
			\langle n~S,E,C,D\rangle$ avec $n$ une constante $b$ ou un signal $s$
			\item[] Machine TTSI $\langle\langle 0,10,\{\langle s,0\rangle,\langle s',1\rangle\},s~put~ap,\langle\epsilon,\emptyset,\epsilon,\emptyset\rangle\rangle,\{\langle 1,\epsilon,\{\langle s,0\rangle,\langle s',1\rangle\}, s'~\langle,1\rangle~\langle,s~0~3~get~s~0~3~get~prim_{+}\rangle~present ,\\\langle\epsilon,\emptyset,\epsilon,\emptyset\rangle\rangle\},\{\langle 0,\langle false,\emptyset,\emptyset,\emptyset\rangle\rangle,\langle 1,\langle false,\emptyset,\emptyset,\emptyset\rangle\rangle\},2\rangle$
			\item[] > \textbf{Substitution} $\langle S,E,X~C,D\rangle
			\longrightarrow_{TTSI} 
			\langle V~S,E,C,D\rangle$ avec $E(X) = V$
			\item[] Machine TTSI $\langle\langle 0,0~10,\{\langle s,0\rangle,\langle s',1\rangle\},put~ap,\langle\epsilon,\emptyset,\epsilon,\emptyset\rangle\rangle,\{\langle 1,\epsilon,\{\langle s,0\rangle,\langle s',1\rangle\}, s'~\langle,1\rangle~\langle,s~0~3~get~s~0~3~get~prim_{+}\rangle~present ,\\\langle\epsilon,\emptyset,\epsilon,\emptyset\rangle\rangle\},\{\langle 0,\langle false,\emptyset,\emptyset,\emptyset\rangle\rangle,\langle 1,\langle false,\emptyset,\emptyset,\emptyset\rangle\rangle\},2\rangle$
			\item[] > \textbf{Ajouter dans un signal} $\langle\langle I,s~b~S,E,put~C,D\rangle,TL,SI\rangle
			\longrightarrow_{TTSI} 
			\langle\langle I,S,E,C,D\rangle,TL,SI~[(s,I) \leftarrow b]\rangle$ 
			\item[] Machine TTSI $\langle\langle 0,\epsilon,\{\langle s,0\rangle,\langle s',1\rangle\},ap,\langle\epsilon,\emptyset,\epsilon,\emptyset\rangle\rangle,\{\langle 1,\epsilon,\{\langle s,0\rangle,\langle s',1\rangle\}, s'~\langle,1\rangle~\langle,s~0~3~get~s~0~3~get~prim_{+}\rangle~present ,\\\langle\epsilon,\emptyset,\epsilon,\emptyset\rangle\rangle\},\{\langle 0,\langle false,\emptyset,\emptyset,\emptyset\rangle\rangle,\langle 1,\langle false,\emptyset,\emptyset,\emptyset\rangle\rangle\}[(0,0) \leftarrow 10],2\rangle$
			\item[] Machine TTSI $\langle\langle 0,\epsilon,\{\langle s,0\rangle,\langle s',1\rangle\},ap,\langle\epsilon,\emptyset,\epsilon,\emptyset\rangle\rangle,\{\langle 1,\epsilon,\{\langle s,0\rangle,\langle s',1\rangle\}, s'~\langle,1\rangle~\langle,s~0~3~get~s~0~3~get~prim_{+}\rangle~present ,\\\langle\epsilon,\emptyset,\epsilon,\emptyset\rangle\rangle\},\{\langle 0,\langle true,\{\langle 0,\{10\}\rangle\},\emptyset,\emptyset\rangle\rangle,\langle 1,\langle false,\emptyset,\emptyset,\emptyset\rangle\rangle\},2\rangle$
			\item[] > \textbf{Application neutre} $\langle S,E,ap~C,D\rangle
			\longrightarrow_{TTSI} 
			\langle S,E,C,D\rangle$
			\item[] Machine TTSI $\langle\langle 0,\epsilon,\{\langle s,0\rangle,\langle s',1\rangle\},\epsilon,\langle\epsilon,\emptyset,\epsilon,\emptyset\rangle\rangle,\{\langle 1,\epsilon,\{\langle s,0\rangle,\langle s',1\rangle\}, s'~\langle,1\rangle~\langle,s~0~3~get~s~0~3~get~prim_{+}\rangle~present ,\\\langle\epsilon,\emptyset,\epsilon,\emptyset\rangle\rangle\},\{\langle 0,\langle true,\{\langle 0,\{10\}\rangle\},\emptyset,\emptyset\rangle\rangle,\langle 1,\langle false,\emptyset,\emptyset,\emptyset\rangle\rangle\},2\rangle$
			\item[] > \textbf{Récupération de sauvegarde neutre} $\langle S,E,\epsilon,\langle S',E',C,D\rangle\rangle
			\longrightarrow_{TTSI} 
			\langle S',E',C,D\rangle$
			\item[] Machine TTSI $\langle\langle 0,\epsilon,\emptyset,\epsilon,\emptyset\rangle,\{\langle 1,\epsilon,\{\langle s,0\rangle,\langle s',1\rangle\}, s'~\langle,1\rangle~\langle,s~0~3~get~s~0~3~get~prim_{+}\rangle~present ,\\\langle\epsilon,\emptyset,\epsilon,\emptyset\rangle\rangle\},\{\langle 0,\langle true,\{\langle 0,\{10\}\rangle\},\emptyset,\emptyset\rangle\rangle,\langle 1,\langle false,\emptyset,\emptyset,\emptyset\rangle\rangle\},2\rangle$
			\item[] > \textbf{Récupération dans la file d'attente} $\langle\langle I,S,E,\epsilon,\emptyset\rangle,\langle I',S',E',C,D\rangle~TL,SI\rangle 
			\longrightarrow_{TTSI} 
			\langle\langle I',S',E',C,D\rangle,TL,SI\rangle$
			\item[] Machine TTSI $\langle\langle 1,\epsilon,\{\langle s,0\rangle,\langle s',1\rangle\}, s'~\langle,1\rangle~\langle,s~0~3~get~s~0~3~get~prim_{+}\rangle~present ,\langle\epsilon,\emptyset,\epsilon,\emptyset\rangle\rangle,\emptyset,\{\langle 0,\langle true,\{\langle 0,\{10\}\rangle\},\emptyset,\emptyset\rangle\rangle,\\\langle 1,\langle false,\emptyset,\emptyset,\emptyset\rangle\rangle\},2\rangle$
			\item[] > \textbf{Substitution} $\langle S,E,X~C,D\rangle
			\longrightarrow_{TTSI} 
			\langle V~S,E,C,D\rangle$ avec $E(X) = V$
			\item[] Machine TTSI $\langle\langle 1,1,\{\langle s,0\rangle,\langle s',1\rangle\}, \langle,1\rangle~\langle,s~0~3~get~s~0~3~get~prim_{+}\rangle~present ,\langle\epsilon,\emptyset,\epsilon,\emptyset\rangle\rangle,\emptyset,\{\langle 0,\langle true,\{\langle 0,\{10\}\rangle\},\emptyset,\emptyset\rangle\rangle,\\\langle 1,\langle false,\emptyset,\emptyset,\emptyset\rangle\rangle\},2\rangle$
			\item[] > \textbf{Abstraction} $\langle S,E,\langle X,C'\rangle~C,D\rangle
			\longrightarrow_{TTSI} 
			\langle \langle\langle X,C'\rangle,E\rangle~S,E,C,D\rangle$
			\item[] Machine TTSI $\langle\langle 1,\langle\langle,1\rangle,\{\langle s,0\rangle,\langle s',1\rangle\}\rangle~1,\{\langle s,0\rangle,\langle s',1\rangle\}, \langle,s~0~3~get~s~0~3~get~prim_{+}\rangle~present ,\langle\epsilon,\emptyset,\epsilon,\emptyset\rangle\rangle,\emptyset,\\\{\langle 0,\langle true,\{\langle 0,\{10\}\rangle\},\emptyset,\emptyset\rangle\rangle,\langle 1,\langle false,\emptyset,\emptyset,\emptyset\rangle\rangle\},2\rangle$
			\item[] > \textbf{Abstraction} $\langle S,E,\langle X,C'\rangle~C,D\rangle
			\longrightarrow_{TTSI} 
			\langle \langle\langle X,C'\rangle,E\rangle~S,E,C,D\rangle$
			\item[] Machine TTSI $\langle\langle 1,\langle\langle,s~0~3~get~s~0~3~get~prim_{+}\rangle,\{\langle s,0\rangle,\langle s',1\rangle\}\rangle~\langle\langle,1\rangle,\{\langle s,0\rangle,\langle s',1\rangle\}\rangle~1,\{\langle s,0\rangle,\langle s',1\rangle\},present ,\langle\epsilon,\emptyset,\epsilon,\emptyset\rangle\rangle,\\\emptyset,\{\langle 0,\langle true,\{\langle 0,\{10\}\rangle\},\emptyset,\emptyset\rangle\rangle,\langle 1,\langle false,\emptyset,\emptyset,\emptyset\rangle\rangle\},2\rangle$
			\item[] \textbf{Thread bloqué non remplacé } $\langle\langle I,\langle\langle X',C''\rangle,E\rangle~\langle\langle X,C'\rangle,E\rangle~s~S,E,C,D\rangle,\emptyset,SI,IP\rangle 
			\longrightarrow_{TTSI} 
			\\\langle\langle IP,\emptyset,\epsilon,\emptyset,\emptyset\rangle,\emptyset,SI',IP+1\rangle$
			avec $SI(s) = \langle faux,CS,SSI,ST\rangle$
			\\et $SI'(s) = \langle faux,CS,SSI,ST~\langle I,\langle\langle X',C''\rangle,E\rangle~\langle\langle X,C'\rangle,E\rangle~s~S,E,present~C,D\rangle\rangle$
			\item[] Machine TTSI $\langle\langle 2,\epsilon,\emptyset,\epsilon,\emptyset\rangle,\emptyset,\{\langle 0,\langle true,\{\langle 0,\{10\}\rangle\},\emptyset,\emptyset\rangle\rangle,\langle 1,\langle false,\emptyset,\emptyset,\{\langle 1,\langle\langle,s~0~3~get~s~0~3~get~prim_{+}\rangle,\\\{\langle s,0\rangle,\langle s',1\rangle\}\rangle~\langle\langle,1\rangle, \{\langle s,0\rangle,\langle s',1\rangle\}\rangle~1,\{\langle s,0\rangle,\langle s',1\rangle\},present ,\langle\epsilon,\emptyset,\epsilon,\emptyset\rangle\rangle\}\rangle\rangle\},3\rangle$
			\item[] > \textbf{Fin d'instant logique} $\langle\langle I,S,E,\epsilon,\emptyset \rangle ,\emptyset,SI\rangle 
			\longrightarrow_{TTSI} 
			\langle\langle I,S,E,\epsilon,\emptyset\rangle,TL,SI'\rangle$
			avec $\tau(SI) = (SI',TL)$
			\item[] Machine TTSI $\langle\langle 2,\epsilon,\emptyset,\epsilon,\emptyset\rangle,\{\langle 1,\epsilon,\{\langle s,0\rangle,\langle s',1\rangle\},s~0~3~get~s~0~3~get~prim_{+} ,\langle\epsilon,\emptyset,\epsilon,\emptyset\rangle\rangle\},\\\{\langle 0,\langle false,\emptyset,\{\langle 0,\{\langle 10,\emptyset\rangle\},\emptyset\rangle\},\emptyset\rangle\rangle,\langle 1,\langle false,\emptyset,\emptyset,\emptyset\rangle\rangle\},3\rangle$ 
			\item[] > \textbf{Récupération dans la file d'attente} $\langle\langle I,S,E,\epsilon,\emptyset\rangle,\langle I',S',E',C,D\rangle~TL,SI\rangle 
			\longrightarrow_{TTSI} 
			\langle\langle I',S',E',C,D\rangle,TL,SI\rangle$
			\item[] Machine TTSI $\langle\langle 1,\epsilon,\{\langle s,0\rangle,\langle s',1\rangle\},s~0~3~get~s~0~3~get~prim_{+} ,\langle\epsilon,\emptyset,\epsilon,\emptyset\rangle\rangle,\emptyset,\{\langle 0,\langle false,\emptyset,\{\langle 0,\{\langle 10,\emptyset\rangle\},\emptyset\rangle\},\emptyset\rangle\rangle,\\\langle 1,\langle false,\emptyset,\emptyset,\emptyset\rangle\rangle\},3\rangle$ 
			\item[] > \textbf{Substitution} $\langle S,E,X~C,D\rangle
			\longrightarrow_{TTSI} 
			\langle V~S,E,C,D\rangle$ avec $E(X) = V$
			\item[] Machine TTSI $\langle\langle 1,0,\{\langle s,0\rangle,\langle s',1\rangle\},0~3~get~s~0~3~get~prim_{+} ,\langle\epsilon,\emptyset,\epsilon,\emptyset\rangle\rangle,\emptyset,\{\langle 0,\langle false,\emptyset,\{\langle 0,\{\langle 10,\emptyset\rangle\},\emptyset\rangle\},\emptyset\rangle\rangle,\\\langle 1,\langle false,\emptyset,\emptyset,\emptyset\rangle\rangle\},3\rangle$ 
			\item[] > \textbf{Constante} $\langle S,E,n~C,D\rangle 
			\longrightarrow_{TTSI} 
			\langle n~S,E,C,D\rangle$ avec $n$ une constante $b$ ou un signal $s$
			\item[] Machine TTSI $\langle\langle 1,0~0,\{\langle s,0\rangle,\langle s',1\rangle\},3~get~s~0~3~get~prim_{+} ,\langle\epsilon,\emptyset,\epsilon,\emptyset\rangle\rangle,\emptyset,\{\langle 0,\langle false,\emptyset,\{\langle 0,\{\langle 10,\emptyset\rangle\},\emptyset\rangle\},\emptyset\rangle\rangle,\\\langle 1,\langle false,\emptyset,\emptyset,\emptyset\rangle\rangle\},3\rangle$ 
			\item[] > \textbf{Constante} $\langle S,E,n~C,D\rangle 
			\longrightarrow_{TTSI} 
			\langle n~S,E,C,D\rangle$ avec $n$ une constante $b$ ou un signal $s$
			\item[] Machine TTSI $\langle\langle 1,3~0~0,\{\langle s,0\rangle,\langle s',1\rangle\},get~s~0~3~get~prim_{+} ,\langle\epsilon,\emptyset,\epsilon,\emptyset\rangle\rangle,\emptyset,\{\langle 0,\langle false,\emptyset,\{\langle 0,\{\langle 10,\emptyset\rangle\},\emptyset\rangle\},\emptyset\rangle\rangle,\\\langle 1,\langle false,\emptyset,\emptyset,\emptyset\rangle\rangle\},3\rangle$ 
			\item[] > \textbf{Prendre une valeur partagée} $\langle\langle I,s~b~n~\langle\langle X,C'\rangle,E'\rangle~S,E,get~C,D\rangle,TL,SI\rangle 
			\longrightarrow_{TTSI} 
			\\\langle\langle I,\emptyset,E'[X \leftarrow V],C',\langle S,E,C,D\rangle\rangle,TL,SI\rangle$
			\\ si pour $SI(s) = \langle emit,CS,SSI\rangle$ et $SSI(b) = \langle CI,IL\rangle$ on a $I \notin IL$ alors $\gamma(SSI(b)) = V$ sinon $n = V$
			\item[] Machine TTSI $\langle\langle 1,10,\{\langle s,0\rangle,\langle s',1\rangle\},s~0~3~get~prim_{+} ,\langle\epsilon,\emptyset,\epsilon,\emptyset\rangle\rangle,\emptyset,\{\langle 0,\langle false,\emptyset,\{\langle 0,\{\langle 10,\emptyset\rangle\},\{1\}\rangle\},\emptyset\rangle\rangle,\\\langle 1,\langle false,\emptyset,\emptyset,\emptyset\rangle\rangle\},3\rangle$ 
			\item[] > \textbf{Substitution} $\langle S,E,X~C,D\rangle
			\longrightarrow_{TTSI} 
			\langle V~S,E,C,D\rangle$ avec $E(X) = V$
			\item[] Machine TTSI $\langle\langle 1,0~10,\{\langle s,0\rangle,\langle s',1\rangle\},0~3~get~prim_{+} ,\langle\epsilon,\emptyset,\epsilon,\emptyset\rangle\rangle,\emptyset,\{\langle 0,\langle false,\emptyset,\{\langle 0,\{\langle 10,\emptyset\rangle\},\{1\}\rangle\},\emptyset\rangle\rangle,\\\langle 1,\langle false,\emptyset,\emptyset,\emptyset\rangle\rangle\},3\rangle$ 
			\item[] > \textbf{Constante} $\langle S,E,n~C,D\rangle 
			\longrightarrow_{TTSI} 
			\langle n~S,E,C,D\rangle$ avec $n$ une constante $b$ ou un signal $s$
			\item[] Machine TTSI $\langle\langle 1,0~0~10,\{\langle s,0\rangle,\langle s',1\rangle\},3~get~prim_{+} ,\langle\epsilon,\emptyset,\epsilon,\emptyset\rangle\rangle,\emptyset,\{\langle 0,\langle false,\emptyset,\{\langle 0,\{\langle 10,\emptyset\rangle\},\{1\}\rangle\},\emptyset\rangle\rangle,\\\langle 1,\langle false,\emptyset,\emptyset,\emptyset\rangle\rangle\},3\rangle$ 
			\item[] > \textbf{Constante} $\langle S,E,n~C,D\rangle 
			\longrightarrow_{TTSI} 
			\langle n~S,E,C,D\rangle$ avec $n$ une constante $b$ ou un signal $s$
			\item[] Machine TTSI $\langle\langle 1,3~0~0~10,\{\langle s,0\rangle,\langle s',1\rangle\},get~prim_{+} ,\langle\epsilon,\emptyset,\epsilon,\emptyset\rangle\rangle,\emptyset,\{\langle 0,\langle false,\emptyset,\{\langle 0,\{\langle 10,\emptyset\rangle\},\{1\}\rangle\},\emptyset\rangle\rangle,\\\langle 1,\langle false,\emptyset,\emptyset,\emptyset\rangle\rangle\},3\rangle$ 
			\item[] > \textbf{Prendre une valeur partagée} $\langle\langle I,s~b~n~\langle\langle X,C'\rangle,E'\rangle~S,E,get~C,D\rangle,TL,SI\rangle 
			\longrightarrow_{TTSI} 
			\\\langle\langle I,\emptyset,E'[X \leftarrow V],C',\langle S,E,C,D\rangle\rangle,TL,SI\rangle$
			\\ si pour $SI(s) = \langle emit,CS,SSI\rangle$ et $SSI(b) = \langle CI,IL\rangle$ on a $I \notin IL$ alors $\gamma(SSI(b)) = V$ sinon $n = V$
			\item[] Machine TTSI $\langle\langle 1,3~10,\{\langle s,0\rangle,\langle s',1\rangle\},prim_{+} ,\langle\epsilon,\emptyset,\epsilon,\emptyset\rangle\rangle,\emptyset,\{\langle 0,\langle false,\emptyset,\{\langle 0,\{\langle 10,\emptyset\rangle\},\{1\}\rangle\},\emptyset\rangle\rangle,\langle 1,\langle false,\emptyset,\emptyset,\emptyset\rangle\rangle\},3\rangle$ 
			\item[] \textbf{Opération} $\langle b_{n},...,b_{1}~S,E,prim_{o^{n}}~C,D\rangle
			\longrightarrow_{TTSI} 
			\langle V~S,E,C,D\rangle$ avec $\delta(o^{n}~b_{1}...b_{n}) = V$
			\item[] Machine TTSI $\langle\langle 1,13,\{\langle s,0\rangle,\langle s',1\rangle\},\epsilon ,\langle\epsilon,\emptyset,\epsilon,\emptyset\rangle\rangle,\emptyset,\{\langle 0,\langle false,\emptyset,\{\langle 0,\{\langle 10,\emptyset\rangle\},\{1\}\rangle\},\emptyset\rangle\rangle,\langle 1,\langle false,\emptyset,\emptyset,\emptyset\rangle\rangle\},3\rangle$ 
			\item[] > \textbf{Récupération de sauvegarde} $\langle V~S,E,\epsilon,\langle S',E',C,D\rangle\rangle
			\longrightarrow_{TTSI} 
			\langle V~S',E',C,D\rangle$
			\item[] Machine TTSI $\langle\langle 1,13,\emptyset,\epsilon,\emptyset\rangle,\emptyset,\{\langle 0,\langle false,\emptyset,\{\langle 0,\{\langle 10,\emptyset\rangle\},\{1\}\rangle\},\emptyset\rangle\rangle,\langle 1,\langle false,\emptyset,\emptyset,\emptyset\rangle\rangle\},3\rangle$ 
		\end{itemize}
	\end{ex}
	\newpage
	
	\subsection*{Les différentes versions faite pour rendre la machine SECD concurrente}
	
	Cette partie énumére les différentes versions créées depuis le début du stage jusqu'à ce jour. Elle paraissent compliqué à comprendre à cause de leurs format qui est bien trop lourd mais elle garde le même principe que celle exprimé plus haut dans le rapport. Il ne faut donc pas avoir peur de chercher à comprendre.
	
	\subsubsection{1ère-2ème version des règles de la machine SECD Concurrente}\label{SECDConc1-2}
	\smallbreak
	Cette version ajoute les prémisses de la concurrence dans la machine SECD avec la possibilité de créer des threads, d'initialiser des signaux et les émettre où encore de tester la présence d'un signal. Cette version est un condensée de 2 versions.
	\bigbreak
	
	\textbf{\textit{Soit}} $\langle S,E,C,D,W,ST,SI\rangle$ \textbf{\textit{avec :}}
	
	
	\begin{itemize}
		\item[] $V~=~b$
		\begin{itemize}
			\item[|] $\langle\langle X,C\rangle,E\rangle$
		\end{itemize}
		\item[] $S~=~\epsilon$ 
		\begin{itemize}
			\item[|] $V~S$ 
			\item[|] $Remp~S$
		\end{itemize}
		\item[] $E$ = une fonction $\{\langle X,V\rangle,...\}$
		\item[] $C~=~\epsilon$ 
		\begin{itemize}
			\item[|] $b~C$
			\item[|] $X~C$
			\item[|] $ap~C$
			\item[|] $prim_{o^{n}}~C$  
			\item[|] $\langle X,C\rangle~C$
			\item[|] $bspawn~C$ 
			\item[|] $espawn~C$
			\item[|] $\langle s,C',C''\rangle~C$
			\item[|] $\langle s,C'\rangle~C$ 
			\item[|] $emit_{s}~C$ 
		\end{itemize}
		\item[] $D = \emptyset$
		\begin{itemize}
			\item[|] $\langle S,E,C,D\rangle$ 
		\end{itemize}
		\item[] $W = \{D,...\}$
		\item[] $ST = \{...,\langle s,D\rangle,...\}$
		\item[] $SI = \{ s,...\}$
	\end{itemize}
	\bigbreak
	\bigbreak
	
	
	\textbf{\textit{Les nouvelles règles sont les suivantes :}}
	\smallbreak
	\begin{itemize}
		\item[] \textbf{Partie de base de la machine SECD}
		\begin{itemize}
			\item[] \textbf{Constante :} On a une constante, on la déplace dans la pile. 
			\smallbreak
			$\langle S,E,b~C,D,W,ST,SI\rangle 
			\longmapsto_{secdv1c} 
			\langle b~S,E,C,D,W,ST,SI\rangle$
			\item[]
			
			\item[] \textbf{Substitution :} On a une variable, on prend la substitution dans l'environnement lié à la variable via la fonction $E$ et on la met dans la pile.  
			\smallbreak 
			$\langle S,E,X~C,D,W,ST,SI\rangle 
			\longmapsto_{secdv1-2} 
			\langle V~S,E,C,D,W,ST,SI\rangle$ 
			où $V = E(X)$
			\item[]
			
			\item[] \textbf{Opération :} On a un opérateur et le nombre de constante nécessaire dans la pile, via la fonction $\delta$ et in retourne le résultat dans la pile. 
			\smallbreak
			$\langle b_{1}~...~b_{n}~S,E,prim_{o^{n}}~C,D,W,ST,SI\rangle 
			\longmapsto_{secdv1-2} 
			\langle V~S,E,C,D,W,ST,SI\rangle$ 
			où $V = \delta(o^{n},b_1,...b_{n})$
			\item[]
			
			\item[] \textbf{Abstraction :} On a une abstraction, on crée une fermeture comportant l'abstraction et l'environnement courant et on met la fermeture dans la pile
			\smallbreak
			$\langle S,E,\langle X,C'\rangle~C,D,W,ST,SI\rangle 
			\longmapsto_{secdv1-2} 
			\langle\langle\langle X,C'\rangle,E\rangle~S,E,C,D,W,ST,SI\rangle$
			\item[]
			
			\item[] \textbf{Application :} On a une application, donc on sauvegarde dans le dépôt, on remplace la chaîne de contrôle et l'environnement par ceux présent dans la fermeture et on ajoute une substitution dans le nouveau environnement.
			\smallbreak
			$\langle V~\langle\langle X,C'\rangle,E'\rangle~S,E,ap~C,D,W,ST,SI\rangle 
			\longmapsto_{secdv1-2} 
			\langle\epsilon,E'[X \leftarrow V],C',\langle S,E,C,D\rangle,W,ST,SI\rangle$
			\item[]
			
			\item[] \textbf{Récupération de sauvegarde :} On a rien mais le dépôt comporte une sauvegarde donc on prend celle-ci.
			\smallbreak
			$\langle V~S,E,\epsilon,\langle S,E,C,D\rangle,W,ST,SI\rangle 
			\longmapsto_{secdv1-2} 
			\langle V~S',E,C',D,W,ST,SI\rangle$
			\item[]
			
		\end{itemize}
		\item[] \textbf{Partie pour la concurrence}
		\begin{itemize}
			\item[] \textbf{Création thread :} On crée un nouveau thread
			\smallbreak
			$\langle S,E,bspawn~C'~espawn~C,D,W,ST,SI\rangle 
			\longmapsto_{secdv1-2} 
			\langle Remp~S,E,C,D,W~\langle S,E,C',D\rangle,ST,SI\rangle$
			\item[]
			
			
			\item[] \textbf{Initialisation signal :} On initialise le signal 
			\smallbreak 
			$\langle S,E,\langle s, C'\rangle~C,D,W,ST,SI\rangle 
			\longmapsto_{secdv1-2} 
			\langle\epsilon,E~[init \leftarrow s],C',\langle S,E,C,D\rangle,W,ST,SI\rangle$
			\item[] 
			
			\item[] \textbf{Présence d'un signal :} On teste la présence d'un signal et il l'est donc on prend la 1ère option. 
			\smallbreak
			$\langle S,E,\langle s, C',C''\rangle~C,D,W,ST,SI\rangle 
			\longmapsto_{secdv1-2} 
			\langle S,E,C'~C,D,W,ST,SI\rangle$ 
			\\si $s \in SI$ et $s \in E$ 
			\item[]
			
			\item[] \textbf{Thread bloqué remplacé :} On teste la présence d'un signal et il ne l'est pas donc on le remplace par le thread en tête de la file d'attente.
			\smallbreak 
			$\langle S,E,\langle s, C',C''\rangle~C,D,\langle S',E',C''',D'\rangle W,ST,SI\rangle 
			\longmapsto_{secdv1-2} 
			\langle S',E',C''',D',W,ST~\langle S,E,\langle s, C',C''\rangle~C,D\rangle,SI\rangle$ 
			\\si $s \notin SI$ et $S \in E$ 
			\item[]
			
			\item[] \textbf{Thread bloqué non remplacé :} On teste la présence d'un signal et il ne l'est pas et la file est vide, on met juste le thread courant dans la liste de threads bloqués.
			\smallbreak
			$\langle S,E,\langle s, C',C''\rangle~C,D,\emptyset,ST,SI\rangle 
			\longmapsto_{secdv1-2} 
			\langle\emptyset,\emptyset,\epsilon,\emptyset,\emptyset,ST~\langle S,E,\langle s, C',C''\rangle~C,D\rangle,SI\rangle$ 
			\\si $s \notin SI$ et $s \in E$ 
			\item[]
			
			\item[] \textbf{\'{E}mettre :} on émet un signal 
			\smallbreak
			$\langle S,E,emit_{s}~C,D,W,ST,SI\rangle 
			\longmapsto_{secdv1-2} 
			\langle S,E,C,D,W',ST',SI\rangle$ 
			\\avec $W' = W~\cup$ tous les éléments de $ST$ qui attendent l'émission de $s$ et
			\\avec $ST' = ST~\setminus$ tous les éléments de $ST$ qui attendent l'émission de $s$
			\item[]
			
			\item[] \textbf{Récupération dans la file d'attente :} On a plus rien à traiter et on a aucune sauvegarde, du coup on change de thread courant par le thread en tête de la file d'attente.
			\smallbreak $\langle S,E,\epsilon,\emptyset,\langle S',E',C,D\rangle$ $W,ST,SI\rangle 
			\longmapsto_{secdv1-2} 
			\langle S',E',C,D,W,ST,SI\rangle$
			\item[]
			
			\item[] \textbf{Fin d'instant logique :} On a plus rien à traiter et on a plus rien dans la file d'attente. C'est la fin de l'instant logique
			\smallbreak  $\langle S,E,\epsilon,\emptyset,\emptyset,ST,SI\rangle 
			\longmapsto_{secdv1-2} \langle S,E,\emptyset,\emptyset,W,\emptyset,\emptyset\rangle$ 
			\\avec $W$ = tous les éléments de $ST$ prennent leurs 2nd choix 
			\item[]
		\end{itemize}
		\item[] \textbf{Partie commune}
		\begin{itemize}
			\item[] \textbf{Application neutre droite :} on a une application avec un neutre dans la pile donc on l'enlève
			\smallbreak
			$\langle V~Remp~S,E,ap~C,D,W,ST,SI\rangle 
			\longmapsto_{secdv1-2} 
			\langle V~S,E,C,D,W,ST,SI\rangle$
			\item[]
			\item[] \textbf{Application neutre gauche :} on a une application avec un neutre dans la pile donc on l'enlève
			\smallbreak
			$\langle Remp~V~S,E,ap~C,D,W,ST,SI\rangle 
			\longmapsto_{secdv1-2} 
			\langle V~S,E,C,D,W,ST,SI\rangle$
			\item[]
		\end{itemize}
	\end{itemize}
	\bigbreak
	
	
	\textbf{\textit{la machine SECD version 1 peut s'arrêter dans 4 états différents:}}
	\smallbreak
	\begin{itemize}
		\item[]$\longrightarrow$ Soit on a une \textbf{constante b} tels que $\langle \epsilon,\emptyset,\textlbrackdbl M\textrbrackdbl_{secdv1-2},\emptyset,\emptyset,\emptyset,\emptyset\rangle \twoheadrightarrow_{secdv1-2} \langle b,E,\epsilon,\emptyset,\emptyset,\emptyset,SI\rangle$;
		\item[]$\longrightarrow$ Soit on a une \textbf{abstraction function} tels que $\langle \epsilon,\emptyset,\textlbrackdbl M\textrbrackdbl_{secdv1-2},\emptyset,\emptyset,\emptyset,\emptyset\rangle \twoheadrightarrow_{secdv1-2} \langle\langle\langle X,C\rangle,E'\rangle,E,\epsilon,\emptyset,\emptyset,\emptyset,SI\rangle$;
		\item[]$\longrightarrow$ Soit on a un \textbf{remplacement} tels que $\langle \epsilon,\emptyset,\textlbrackdbl M\textrbrackdbl_{secdv1-2},\emptyset,\emptyset,\emptyset,\emptyset\rangle \twoheadrightarrow_{secdv1-2} \langle Remp,E,\epsilon,\emptyset,\emptyset,\emptyset,SI\rangle$;
		\item[]$\longrightarrow$ Sinon on a un \textbf{état inconnu} soit une \textbf{erreur}.
	\end{itemize}
	\newpage
	
	
	\subsubsection{3ème version des règles de la machine SECD Concurrente}\label{SECDConc3}
	\smallbreak
	Cette version ajoute le contrôle des erreurs sans propagation via l'ajout d'un gestionnaire d'erreur dans la machine. Il commence a y avoir beaucoup d'éléments dans notre machine donc on va en rassembler certains. On va définir $TL$ un couple qui regroupe $W$ et $ST$, c'est-à-dire $TL = \langle W,ST\rangle$.
	\bigbreak
	
	\textbf{\textit{Soit}} $\langle S,E,C,D,TL,SI,H\rangle$ \textbf{\textit{avec :}}
	
	\begin{itemize}
		\item[] $V~=~b$
		\begin{itemize}
			\item[|] $\langle\langle X,C\rangle,E\rangle$
			\item[|] $erreur_{e}$
		\end{itemize}
		\item[] $S$ = $\epsilon$ 
		\begin{itemize}
			\item[|] $V~S$ 
			\item[|] $Remp~S$
			\item[|] $throw_{e}~S$
		\end{itemize}
		\item[] $E$ = une fonction $\{\langle X,V\rangle,...\}$
		\item[] $C~=~\epsilon$ 
		\begin{itemize}
			\item[|] $b~C$
			\item[|] $X~C$
			\item[|] $ap~C$
			\item[|] $prim_{o^{n}}~C$  
			\item[|] $\langle X,C\rangle~C$
			\item[|] $bspawn~C$ 
			\item[|] $espawn~C$
			\item[|] $\langle s,C',C''\rangle~C$
			\item[|] $\langle s,C'\rangle~C$ 
			\item[|] $emit_{s}~C$ 
			\item[|] $throw_{e}~C$
			\item[|] $\langle e,\langle C',\langle X,C''\rangle\rangle\rangle~C$ 
		\end{itemize}
		\item[] $D = \epsilon$
		\begin{itemize}
			\item[|] $\langle S,E,C,D\rangle$ 
		\end{itemize}
		\item[] $TL = \langle W,ST\rangle$ avec 
		\begin{itemize}
			\item[] - $W = \{D,...\}$
			\item[] - $ST = \{...,\langle s,D\rangle,...\}$
		\end{itemize}
		\item[] $SI = \{ s,...\}$
		\item[] $H$ = $\epsilon$ 
		\begin{itemize}
			\item[|] $\langle e,\langle S,E,C,D,TL,SI,H\rangle\rangle$ 
		\end{itemize}
	\end{itemize}
	\bigbreak
	\bigbreak
	
	
	
	\textbf{\textit{Les nouvelles règles sont les suivantes :}}
	\smallbreak
	\begin{itemize}
		\item[] \textbf{Partie de base de la machine SECD}
		\begin{itemize}
			\item[] \textbf{Constante :} On a une constante, on la déplace dans la pile.
			\smallbreak
			$\langle S,E,b~C,D,TL,SI,H\rangle \longmapsto_{secdv3} \langle b~S,E,C,TL,SI,H\rangle$
			\item[]
			
			\item[] \textbf{Substitution :} On a une variable, on prend la substitution dans l'environnement lié à la variable via la fonction $E$ et on la met dans la pile.
			\smallbreak
			$\langle S,E,X~C,D,TL,SI,H\rangle \longmapsto_{secdv3} \langle V~S,E,C,D,TL,SI,H\rangle$
			\\où $V = E(X)$
			\item[]
			
			\item[] \textbf{Opération :} On a un opérateur et le nombre de constante nécessaire dans la pile, \\via la fonction $\delta$ on retourne le résultat dans la pile.
			\smallbreak
			$\langle b_{1}~...~b_{n}~S,E,prim_{o^{n}}~C,D,TL,SI,H\rangle \longmapsto_{secdv3} \langle V~S,E,C,D,TL,SI,H\rangle$ 
			\\où $V = \delta(o^{n},b_1,...b_{n})$
			\item[]
			
			\item[]  \textbf{Abstraction :} On a une abstraction, on crée une fermeture comportant l'abstraction et l'environnement courant et on met la fermeture dans la pile.
			\smallbreak 
			$\langle S,E,\langle X,C'\rangle~C,D,TL,SI,H\rangle \longmapsto_{secdv3} \langle\langle\langle X,C'\rangle,E\rangle~S,E,C,D,TL,SI,H\rangle$
			\item[]
			
			\item[]  \textbf{Application :} On a une application, donc on sauvegarde dans le dépôt, on remplace la chaîne de contrôle et l'environnement par ceux présent dans la fermeture et on ajoute une substitution dans le nouvel environnement.
			\smallbreak
			$\langle V~\langle\langle X,C'\rangle,E'\rangle~S,E,ap~C,D,TL,SI,H\rangle \longmapsto_{secdv3} \langle\epsilon,E'[X \leftarrow V],C',\langle S,E,C,D\rangle,TL,SI,H\rangle$
			\item[]
			
			\item[] \textbf{Récupération de sauvegarde :}  On a rien mais le dépôt comporte une sauvegarde donc on prend celle-ci.
			\smallbreak 
			$\langle V~S,E,\epsilon,\langle S',E',C,D\rangle,TL,SI,H\rangle \longmapsto_{secdv3} \langle V~S',E',C,D,TL,SI,H\rangle$
			\item[]
		\end{itemize}
		\item[] \textbf{Partie pour les erreurs}
		\begin{itemize}
			\item[] \textbf{Erreur :} On a une erreur, on la déplace en tête de la pile.
			\smallbreak
			$\langle S,E,throw_{e}~C,D,TL,SI,H\rangle \longmapsto_{secdv3} \langle throw_{e}~S,E,C,D,TL,SI,H\rangle$	
			\item[]
			
			
			\item[] \textbf{Traiter erreur via gestionnaire d'erreur :} On a plus rien, cependant il y a une erreur levée dans la pile du coup on regarde si le gestionnaire d'erreur gère celle-ci ; c'est la cas du coup prend la sauvegarde.
			\smallbreak 
			$\langle throw_{e}~S,E,C,D,TL,SI,\langle e,\langle S',E',\langle X,C''\rangle~C',D',TL',SI',H\rangle\rangle\rangle 
			\\\longmapsto_{secdv3} \langle \epsilon,E'[X \leftarrow erreur_{e}],C'',\langle S',E',C',D'\rangle,TL',SI',H\rangle$
			\item[]
			
			\item[]  \textbf{Traitement erreur récursif :} On a plus rien, cependant on a une erreur levée dans la pile du coup on regarde si le gestionnaire d'erreur gère celle-ci; ce n'est pas le cas, du coup on regarde pour le gestionnaire sauvegardé.
			\smallbreak 
			$\langle throw_{e}~S,E,C,D,TL,SI,\langle e',\langle S',E',\langle X,C''\rangle~C',D',TL',SI',H\rangle\rangle\rangle 
			\\\longmapsto_{secdv3} \langle throw_{e}~S,E,C,D,TL,SI,H \rangle$
			\item[]
			
			\item[]  \textbf{Erreur non traitée :} On a plus rien, cependant on a une erreur levée dans la pile du coup on arrête la machine en vidant tout sauf la pile.
			\smallbreak 
			$\langle throw_{e}~S,E,C,D,TL,SI,\emptyset\rangle \longmapsto_{secdv3} \langle throw_{e}~S,E,\epsilon,\emptyset,\emptyset,\emptyset,\emptyset,\emptyset\rangle$  
			\item[]
			
			\item[]  \textbf{Création d'un gestionnaire d'erreur :} On a un try...catch donc on teste la chaîne de contrôle du try et on sauvegarde catch dans le gestionnaire d'erreur.
			\smallbreak 
			$\langle S,E,\langle e,\langle C',\langle X,C''\rangle\rangle\rangle~C,D,TL,SI,H\rangle \longmapsto_{secdv3} \langle S,E,C'~C,D,TL,SI,\langle e,\langle S,E,\langle X,C''\rangle~C,D,TL,SI,H\rangle\rangle\rangle$
			\item[]
		\end{itemize}
		\item[] \textbf{Partie pour la concurrence}
		\begin{itemize}
			\item[]  \textbf{Création thread :} On crée un nouveau thread.
			\smallbreak
			$\langle S,E,bspawn~C'~espawn~C,D,\langle W,ST\rangle,SI,H\rangle \longmapsto_{secdv3} \langle Remp~S,E,C,D,\langle W~\langle S,E,C',D\rangle,ST\rangle,SI,H\rangle$
			\item[]
			
			\item[] \textbf{Initialisation signal :} On initialise le signal.
			\smallbreak
			$\langle S,E,\langle s, C'\rangle~C,D,TL,SI,H\rangle \longmapsto_{secdv3} \langle\epsilon,E~[init \leftarrow s],C',\langle S,E,C,D\rangle,TL,SI,H\rangle$
			\item[]
			
			\item[] \textbf{Présence signal :} On teste la présence d'un signal, on sait qu'il est émis donc on prend le 1er choix.
			\smallbreak
			$\langle S,E,\langle s, C',C''\rangle~C,D,TL,SI,H\rangle \longmapsto_{secdv3} \langle S,E,C'~C,D,TL,SI,H\rangle$ 
			\\si $s \in SI$ et $s \in E$ 
			\item[]
			
			\item[] \textbf{ Thread bloqué remplacé :} On teste la présence d'un signal, on sait qu'il n'est pas émis et il y a un thread dans la file d'attente
			donc on mets le thread courant dans la liste des threads bloqués et on prend le thread en tête de la file.
			\smallbreak
			$\langle S,E,\langle s, C',C''\rangle~C,D,\langle\langle S',E',C''',D'\rangle~W,ST\rangle,SI,H\rangle 
			\\\longmapsto_{secdv3} \langle S',E',C''',D',\langle W,ST~\langle s,\langle S,E,\langle s, C',C''\rangle~C,D\rangle\rangle\rangle,SI,H\rangle$ si $s \notin SI$ et $s \in E$ 
			\item[]\newpage
			
			
			
			\item[] \textbf{Thread bloqué non remplacé :} On teste la présence d'un signal, on sait qu'il n'est pas émis donc on met le thread courant dans la liste de threads bloqués.
			\smallbreak 
			$\langle S,E,\langle s, C',C''\rangle~C,D,\langle\emptyset,ST\rangle,SI,H\rangle \longmapsto_{secdv3} \langle\epsilon,\emptyset,\epsilon,\emptyset,\langle\emptyset,ST~\langle s,\langle S,E,\langle s, C',C''\rangle~C,D\rangle\rangle\rangle,SI,H\rangle$
			\\si $s \notin SI$ et $s \in E$ 
			\item[]
			
			\item[] \textbf{Émission :} On émet un signal donc on met dans la file d'attente tous les threads attendant le signal.
			\smallbreak
			$\langle S,E,emit_{s}~C,D,\langle W,ST\rangle,SI,H\rangle \longmapsto_{secdv3} \langle S,E,C,D,\langle W',ST'\rangle,SI,H\rangle$
			\\ avec $W' = W~\cup$ tous les éléments de $ST$ qui attendent l'émission de $s$ et
			\\ avec $ST' = ST~\setminus$ tous les éléments de $ST$ qui attendent l'émission de $s$
			\item[]
			
			\item[] \textbf{Récupération dans la file d'attente :} On a plus rien à traiter et on a aucune sauvegarde, du coup on change le thread courant par le thread en tête de la file d'attente.
			\smallbreak
			$\langle S,E,\epsilon,\emptyset,\langle\langle S',E',C',D'\rangle~W,ST\rangle,SI,H\rangle \longmapsto_{secdv3} \langle S',E',C',D',\langle W,ST\rangle,SI,H\rangle$
			\item[]
			
			\item[] \textbf{Fin d'instant logique :} On a plus rien à traiter, on a aucune sauvegarde et on a plus rien dans la file d'attente, c'est la fin d'un instant logique.
			\smallbreak
			$\langle S,E,\epsilon,\emptyset,\langle\emptyset,ST\rangle,SI,H\rangle \longmapsto_{secdv3} \langle S,E,\epsilon,\emptyset,\langle W,\emptyset\rangle,\emptyset,H\rangle$\\ avec $W$ = tous les éléments de $ST$ qui prennent leurs 2nd choix 
			\item[]
		\end{itemize}	
		\item[] \textbf{Partie commune}
		\begin{itemize}
			\item[] \textbf{Application neutre droite :} On a une application avec un $Remp$ à droite donc on enlève $Remp$.
			\smallbreak
			$\langle V~Remp~S,E,ap~C,D,TL,SI,H\rangle \longmapsto_{secdv3} \langle V~S,E,C,D,TL,SI,H\rangle$
			\item[]
			
			\item[] \textbf{Application neutre gauche :} On a une application avec un $Remp$ à gauche donc on enlève $Remp$.
			\smallbreak
			$\langle Remp~V~S,E,ap~C,D,TL,SI,H\rangle \longmapsto_{secdv3} \langle V~S,E,C,D,TL,SI,H\rangle$
			\item[]
		\end{itemize}
	\end{itemize}
	\bigbreak
	\bigbreak
	
	\textbf{\textit{la machine SECD version 3 peut s'arrêter dans 4 états différents:}}
	\smallbreak
	\begin{itemize}
		\item[]$\longrightarrow$ Soit on a une \textbf{constante} telle que $\langle \emptyset,\emptyset,\textlbrackdbl M\textrbrackdbl_{secdv3},\emptyset,\langle\emptyset,\emptyset\rangle,\emptyset,\emptyset\rangle \twoheadrightarrow_{secdv3} \langle b,E,\epsilon,\emptyset,\langle\emptyset,\emptyset\rangle,SI,H\rangle$;
		\item[]
		\item[]$\longrightarrow$ Soit on a une \textbf{fonction} telle que $\langle \epsilon,\emptyset,\textlbrackdbl M\textrbrackdbl_{secdv3},\emptyset,\langle\emptyset,\emptyset\rangle,\emptyset,\emptyset\rangle \twoheadrightarrow_{secdv3} \langle\langle\langle X,C\rangle,E'\rangle,E,\epsilon,\emptyset,\langle\emptyset,\emptyset\rangle,SI,H\rangle$;
		\item[]
		\item[]$\longrightarrow$ Soit on a un \textbf{remplacement} telle que $\langle \epsilon,\emptyset,\textlbrackdbl M\textrbrackdbl_{secdv3},\emptyset,\langle\emptyset,\emptyset\rangle,\emptyset,\emptyset\rangle \twoheadrightarrow_{secdv3} \langle Remp,E,\epsilon,\emptyset,\langle\emptyset,\emptyset\rangle,SI,H\rangle$;
		\item[]
		\item[]$\longrightarrow$ Sinon on a une \textbf{erreur} telle que $\langle \epsilon,\emptyset,\textlbrackdbl M\textrbrackdbl_{secdv3},\emptyset,\langle\emptyset,\emptyset\rangle,\emptyset,\emptyset\rangle \twoheadrightarrow_{secdv3} \langle throw_{e},E,\epsilon,\emptyset,\langle\emptyset,\emptyset\rangle,SI,H\rangle$.
	\end{itemize}
	\newpage
	
	
	
	\subsubsection{4ème version des règles de la machine SECD Concurrente}
	Cette version ajoute la propagation des erreurs ainsi que la gestion des listes de valeurs partagées. Cette version se rapproche beaucoup de la dernière version de la partie 2. De base la gestion des erreurs étaient aussi présente dans la dernière version. Cependant la forme du gestionnaire d'erreur n'arrivant pas à être choisie, il a été décidés d'enlever la gestion des erreurs.
	\bigbreak
	
	
	\textbf{\textit{Une suite de fonctions ont été écrite pour simplifier la lecture des règles. Les voici :}}
	\smallbreak
	\begin{itemize}
		\item[] $\rho(l,v,s,i) =$ la fonction qui ,pour une liste des signaux $l$, une valeur $v$, un signal $s$ et un identifiant du thread courant $i$ donnés, renvoie la liste $l'$ avec $v$ ajoutée à la liste des valeurs du signal $s$ pour le thread $i$.
		\begin{ex}
			$\rho(\{...,\langle s,\{...,\langle id,valeur\rangle,...\},emit\rangle,...\},v,s,id) = \{...,\langle s,\{...,\langle id,valeur$ $v\rangle,...\},emit\rangle,...\}$
		\end{ex}
		\item[] 
		
		\item[] $\gamma(l,s,i,i') =$ la fonction qui ,pour une liste de valeurs partagées $l$ classés par signal $s$ et par thread $i$, un signal $s$, l'identifiant du thread courant $i'$ et l'identifiant du thread $i$ auquel on veut accéder, renvoie soit un couple la liste avec l'itérateur déplacé et la valeur ou une exception si on ne peut plus donner de nouvelles valeurs. 
		\begin{ex} 
			Trois cas sont possibles :
			\begin{enumerate}
				\item On prend pourla première fois :
				\\$\gamma(\{...,\langle s,\{...,\langle id,\{\langle b,\emptyset\rangle,\langle n,\{...\}\rangle,...\},\{...\}\rangle,...\}\rangle,...\},s,id,id') = 
				\\\langle b , \{...,\langle s,\{...,\langle id,\{\langle b,\emptyset\rangle,\langle n,\{...,id'\}\rangle,...\},\{...\}\rangle,...\}\rangle,...\} \rangle$
				\item On a déjà pris :
				\\$\gamma(\{...,\langle s,\{...,\langle id,\{...,\langle b,\{...,id',...\}\rangle,\langle n,\{...\}\rangle,...\},\{...\}\rangle,...\}\rangle,...\},s,id,id') = 
				\\\langle b , \{...,\langle s,\{...,\langle id,\{...,\langle b,\{...\}\rangle,\langle n,\{...,id'\}\rangle,...\},\{...\}\rangle,...\}\rangle,...\} \rangle$
				\item On prend le dernier :
				\\$\gamma(\{...,\langle s,\{...,\langle id,\{...,\langle b,\{...,id',...\}\rangle\},\{...\}\rangle,...\}\rangle,...\},s,id,id') = 
				\\\langle b , \{...,\langle s,\{...,\langle id,\{...,\langle b,\{...\}\rangle\},\{...,id'\}\rangle,...\}\rangle,...\} \rangle$
				\item On a déjà tout pris : 
				\\$\gamma(\{...,\langle s,\{...,\langle id,valeurs,\{...,id',...\}\rangle,...\}\rangle,...\},s,id,id') = throw$ $erreur_{e}$
			\end{enumerate} 
		\end{ex}
		\item[]
		
		\item[] $\iota(l,s,i) =$ la fonction qui, pour une liste de signaux courant $l$, un signal $s$, renvoie une liste des signaux courants avec le signal $s$ initialisé.
		\begin{ex}
			$\iota(\{...\},s) = \{...,\langle s,\{\},false\rangle\}$
		\end{ex}
		\item[]
		
		\item[] $\beta(l,s) =$ la fonction qui, pour une liste de signal courant $l$ et un signal $s$ donnés, renvoie le booléen $emit$.
		\begin{ex}
			$\beta(\{...,\langle s,\{...\},vraie\rangle,...\},s) = vraie$ ou $\beta(\{...,\langle s,\{...\},faux\rangle,...\},s) = faux$
		\end{ex}
		\item[] 
		
		\item[] $\varepsilon(l,s) =$ la fonction qui, pour une liste de signaux courants $l$ et un signal $s$ donnés, renvoie la liste avec le booléen représentant l'émission du signal $emit$ à vraie.
		\begin{ex}
			$\varepsilon(\{...,\langle s,\{...\},faux\rangle,...\},s) = \{...,\langle s,\{...\},vraie\rangle,...\}$
		\end{ex}
		\item[] 
		
		\item[] $\alpha(\langle CS,SSI\rangle) =$ la fonction qui, pour la liste des signaux courants $CS$ et la liste des signaux partagées $SSI$ données, renvoie la liste des signaux courants vidée de ses listes de valeurs et avec le booléen représentant l'émission $emit$ mis à nul. La liste des signaux partagées est remplacée par les listes de valeurs de la liste des signaux courants qui sont émis.
		\begin{ex}
			$\alpha(\langle CS,SSI\rangle) = SSI$ vidé et
			\\ $\forall$ $x$ $\in CS$ telle que $\langle s,\{...,\langle id,\{...,b,...\}\rangle,...\},true\rangle$, on ajoute $x$ dans $SSI$
			\\ $\forall$ $x$ $\in CS$ telle que $\langle s,\{...,\langle id,\{...,b,...\}\rangle,...\},emit\rangle$ on le remplace par $\langle s,\{...,\langle id,\{\}\rangle,...\},faux\rangle$  
		\end{ex}
	\end{itemize}
	\newpage
	
	
	
	\textbf{\textit{Soit $\langle I,S,E,C,D,TL,SI,H,IP\rangle$ avec :}}
	
	\begin{itemize}
		\item[] $V = b$	
		\begin{itemize}
			\item[|] $\langle\langle X,C' \rangle E\rangle$
			\item[|] $erreur_{e}$
		\end{itemize}
		\item[] $I =$ un entier représentant l'identifiant du thread
		\item[] $S =  \emptyset$ 
		\begin{itemize}
			\item[|] $V S$
			\item[|] $signal$ $S$
			\item[|] $throw$ $S$
		\end{itemize}
		\item[] $E = \{...,\langle X,V\rangle,...\}$
		\item[] $C = \epsilon$
		\begin{itemize}
			\item[|] $b~C$~~~~~~~~~~~~~~~~~~~~~~~~~~    (une constante)
			\item[|] $X~C$~~~~~~~~~~~~~~~~~~~~~~~~~~(une variable)
			\item[|] $s~C$~~~~~~~~~~~~~~~~~~~~~~~~~~~(un signal)
			\item[|] $\langle X,C'\rangle~C$~~~~~~~~~~~~~~~~~~~(une abstraction)
			\item[|] $ap~C$~~~~~~~~~~~~~~~~~~~~~~~~~(une application)
			\item[|] $prim_{o^{n}}~C$~~~~~~~~~~~~~~~~~~~(un opérateur)
			\item[|] $bspawn~C$~~~~~~~~~~~~~~~~~~~(début d'un nouveau thread)
			\item[|] $espawn~C$~~~~~~~~~~~~~~~~~~(fin d'un nouveau thread)
			\item[|] $\langle C',C''\rangle~C$~~~~~~~~~~~~~~~~~~(le test de présence d'un signal)
			\item[|] $emit~C$~~~~~~~~~~~~~~~~~~~~~~(émet un signal)
			\item[|] $init~C$~~~~~~~~~~~~~~~~~~~~~~~(initialise un signal)
			\item[|] $put~C$~~~~~~~~~~~~~~~~~~~~~~~~(insère une valeur dans la liste de valeurs d'un signal)
			\item[|] $get~C$~~~~~~~~~~~~~~~~~~~~~~~~(prends une valeurs dans la liste de valeurs d'un signal)
			\item[|] $erreur_{e}~C$~~~~~~~~~~~~~~~~~~(une erreur)
			\item[|] $throw~C$~~~~~~~~~~~~~~~~~~~~(lève une erreur)
			\item[|] $\langle C',\langle X,C''\rangle\rangle~C$~~~~~~~~~~~(un gestionnaire d'erreur)
		\end{itemize}
		\item[] $TL = \langle W,ST\rangle$
		\begin{itemize}
			\item[] $W = \{...,\langle I,S,E,C,D\rangle,...\}$~~~~~~~~(liste des threads en attente)
			\item[] $ST = \{...,\langle s,\langle I,S,E,C,D\rangle\rangle,...\}$~~(liste des threads en attente d'un signal)
		\end{itemize}
		\item[] $SI = \langle CS,SSI\rangle$
		\begin{itemize}
			\item[] $CS = \{...,\langle s,\{...,\langle id,\{...,b,...\}\rangle,...\},emit\rangle,...\}$~~~~~~~~~~~~~~~~~~~~~~~~~~(liste des signaux courants)
			\begin{itemize}
				\item[] on va découper cette élément pour mieux en comprendre le sens :
				\item[] - $\{...,*,...\}$ Une liste. 
				\item[] - $\langle s,\{...,**,...\},emit\rangle$ \\
				Une liste composée de trinôme comportant le identifiant du signal, une sous-liste et un booléen exprimant l'émission de ce signal.
				\item[] - $\langle id,\{...,b,...\}\rangle$ \\
				Une sous-liste composée d'un trinôme comportant l'identifiant du thread et une liste de valeur.
			\end{itemize}
			\item[]
			\item[] $SSI =  \{...,\langle s,\{...,\langle id,\{...,\langle b,\{...,id',...\}\rangle,...\},\{...,id'',...\}\rangle,...\}\rangle,...\}$~~~~~(liste des signaux partagés)
			\begin{itemize}
				\item[] comme pour $CS$ on va découper cette élément pour pouvoir le comprendre :
				\item[] - $\{...,*,...\}$ Une liste. 
				\item[] - $\langle s,\{...,**,...\}\rangle$\\
				Une liste composée d'un couple comportant un identifiant de signal et d'une sous-liste
				\item[] - $\langle id,\{...,***,...\},\{...,id'',...\}\rangle$\\
				Une sous-liste composée d'un trinôme comportant un identifiant d'un thread, d'un liste et d'une sous-sous-liste d'identifiant de thread représentant la liste des threads ayant fini leurs parcours de la sous-sous-liste.
				\item[] - $\langle b,\{...,id',...\}\rangle$\\
				Une sous-sous-liste composée d'un couple comportant une valeur et une liste d'identifiant de threads qui représente un pointeur
			\end{itemize}
		\end{itemize}
		\item[] $D = \emptyset$
		\begin{itemize}
			\item[|] $\langle S,E,C,D\rangle$~~~~~~~~~(une sauvegarde liée à une abstraction)
		\end{itemize}
		\item[] $H = \emptyset$ 
		\begin{itemize}
			\item[|] $\langle e\langle I,S,E,\langle X,C' \rangle C,D,TL,SI,H,IP\rangle\rangle$
		\end{itemize} 
		\item[] $IP =$ un entier servant à attribuer l'identifiant à un nouveau thread 
	\end{itemize}
	\newpage
	
	
	
	\textbf{\textit{Les éléments étant expliqués, voici les nouvelles règles de la machine :}}
	\smallbreak
	\begin{enumerate}
		\item[] \textbf{Partie de base de la machine SECD} 
		\item[]
		\begin{itemize}
			\item[] \textbf{Constante :} On a une constante, on la déplace dans la pile.
			\smallbreak
			$\langle I,S,E,b~C,D,TL,SI,H,IP\rangle 
			\longrightarrow_{secdv4} \langle I,b~S,E,C,D,TL,SI,H,IP\rangle$
			\item[]
			
			\item[] \textbf{Substitution :} On a une variable, on prend la substitution dans l'environnement lié à la variable via la fonction $E$ et on la met dans la pile.
			\smallbreak
			$\langle I,S,E,X~C,D,TL,SI,H,IP\rangle
			\longrightarrow_{secdv4} \langle I,V~S,E,C,D,TL,SI,H,IP\rangle$\\ avec $E(X) = V$
			\item[]
			
			\item[] \textbf{Opération :} On a un opérateur et le nombre de constante nécessaire dans la pile, \\via la fonction $\delta$ on retourne le résultat dans la pile.
			\smallbreak
			$\langle I,b_{n},...,b_{1}~S,E,prim_{o^{n}}~C,D,TL,SI,H,IP\rangle
			\longrightarrow_{secdv4} \langle I,V~S,E,C,D,TL,SI,H,IP\rangle$
			\\avec $\delta(o^{n}~b_{1}...b_{n}) = V$
			\item[]
			
			\item[]  \textbf{Abstraction :} On a une abstraction, on crée une fermeture comportant l'abstraction et l'environnement courant et on met la fermeture dans la pile.
			\smallbreak
			$\langle I,S,E,\langle X,C'\rangle~C,D,TL,SI,H,IP\rangle
			\longrightarrow_{secdv4} \langle I,\langle\langle X,C'\rangle,E\rangle~S,E,C,D,TL,SI,H,IP\rangle$
			\item[]
			
			\item[]  \textbf{Application :} On a une application, donc on sauvegarde dans le dépôt, on remplace la chaîne de contrôle et l'environnement par ceux présent dans la fermeture et on ajoute une substitution dans le nouvel environnement.
			\smallbreak
			$\langle I,V~\langle\langle X,C'\rangle,E'\rangle~S,E,ap~C,D,TL,SI,H,IP\rangle
			\longrightarrow_{secdv4} \langle I,\epsilon,E'[X \leftarrow V],C',\langle S,E,C,D\rangle,TL,SI,H,IP\rangle$
			\item[] 
			
			\item[] \textbf{Récupération de sauvegarde :}  On a rien mais le dépôt comporte une sauvegarde donc on prend celle-ci.
			\smallbreak  
			$\langle I,V~S,E,\epsilon,\langle S',E',C,D\rangle,TL,SI,H,IP\rangle
			\longrightarrow_{secdv4} \langle I,V~S',E',C,D,TL,SI,H,IP\rangle$
		\end{itemize}
		\item[]
		\item[] \textbf{Partie pour les erreurs} 
		\item[]
		\begin{itemize}
			\item[] \textbf{Erreur :} On a une erreur, on la déplace en tête de la pile.
			\smallbreak
			$\langle I,S,E,erreur_{e}~C,D,TL,SI,H,IP\rangle
			\longrightarrow_{secdv4} \langle I,erreur_{e}~S,E,C,D,TL,SI,H,IP\rangle$
			\item[]
			
			\item[] \textbf{Lever erreur :} On a un throw, on le déplace en tête de la pile.
			\smallbreak
			$\langle I,S,E,throw~C,D,TL,SI,H,IP\rangle
			\longrightarrow_{secdv4} \langle I,throw~S,E,C,D,TL,SI,H,IP\rangle$
			\item[]
			
			\item[] \textbf{Opération sur erreur :} On a l'opérateur qui traite cette erreur donc on met le résultat de la fonction $\delta$ dans la pile.
			\smallbreak
			$\langle I,throw~erreur_{e}~S,E,prim_{o^{1_{e}}}~C,D,TL,SI,H,IP\rangle
			\longrightarrow_{secdv4} \langle I,V~S,E,C,D,TL,SI,H,IP\rangle$
			\\ avec $\delta(o^{1_{e}}~erreur_{e}) = V$
			\item[]
			
			\item[] \textbf{Propagation :} On a un un élément excepté l'opérateur qui traite cette erreur donc on propage l'erreur.
			\smallbreak
			$\langle I,throw~erreur_{e}~S,E,M~C,D,TL,SI,H,IP\rangle
			\longrightarrow_{secdv4} \langle I,throw~erreur_{e}~S,E,C,D,TL,SI,H,IP\rangle$ 
			\\avec $M = $ un élément de $C \backslash prim_{o^{1_{e}}}$
			\item[]
			
			\item[] \textbf{Traiter erreur via gestionnaire d'erreur :} On a plus rien mais on a une erreur levée dans la pile du coup on regarde si le gestionnaire d'erreur gère celle-ci ; oui du coup prend la sauvegarde.
			\smallbreak 
			$\langle I,throw~erreur_{e}~S,E,\epsilon,D,TL,SI,\langle e,\langle I',S',E',\langle X,C'' \rangle C',D',TL',SI',H,IP'\rangle\rangle,IP\rangle \\\longrightarrow_{secdv4} \langle I',\emptyset,E'[X \leftarrow erreur_{e}],C'',\langle S',E',C',D'\rangle,TL',SI',H,IP'\rangle$
			\item[]
			
			\item[]  \textbf{Erreur non traitée :} On a plus rien mais on a une erreur levé dans la pile du coup on arrête la machine en vidant tout sauf l'erreur
			\smallbreak 
			$\langle I,throw~erreur_{e}~S,E,\epsilon,D,TL,SI,\emptyset,IP\rangle \longmapsto_{secdv4} \langle I,throw~erreur_{e},E,\epsilon,\emptyset,\emptyset,\emptyset,\emptyset,\emptyset,IP\rangle$  
			\item[]
			
			\item[]  \textbf{Traitement erreur récursif :} On a plus rien mais on a une erreur levée dans la pile du coup on regarde 
			\\si le gestionnaire d'erreur gère celle-ci mais non du coup on regarde pour le gestionnaire sauvegardé.
			\smallbreak 
			$\langle I,throw~erreur_{e}~S,E,\epsilon,D,TL,SI,\langle e',\langle I',S',E',\langle X,C'' \rangle C',D',TL',SI',H,IP'\rangle\rangle,IP\rangle \\\longrightarrow_{secdv4}\langle I,throw~erreur_{e}~S,E,\epsilon,D,TL,SI,H,IP\rangle$
			\item[] 
			
			\item[]  \textbf{Création d'un gestionnaire d'erreur :} On a un try...catch donc on teste avec la chaîne de contrôle du try et on sauvegarde catch dans le gestionnaire d'erreur.
			\smallbreak 
			$\langle I,erreur_{e}~S,E,\langle C',\langle X,C''\rangle\rangle~C,D,TL,SI,H,IP\rangle 
			\\\longrightarrow_{secdv4} \langle I,S,E,C'~C,D,TL,SI,\langle e,\langle I,erreur_{e}~S,E,\langle X,C'' \rangle~C,D,TL,SI,H,IP\rangle\rangle,IP\rangle$
		\end{itemize}
		\item[]
		\item[] \textbf{Partie pour la concurrence} 
		\item[]
		\begin{itemize}
			\item[]  \textbf{Création thread :} On crée un nouveau thread.
			\smallbreak 
			$\langle I,S,E,bspawn~C'~espawn~C,D,\langle W,ST\rangle,SI,H,IP\rangle 
			\\\longrightarrow_{secdv4} \langle I,S,E,C,D,\langle W~\langle IP,S,E,C',D\rangle,ST\rangle,SI,H,IP+1\rangle$
			\item[]
			
			\item[]  \textbf{Signal :} On a un signal, on le déplace dans la pile.
			\smallbreak 
			$\langle I,S,E,s~C,D,TL,SI,H,IP\rangle
			\longrightarrow_{secdv4} \langle I,s~S,E,C,D,TL,SI,H,IP\rangle$
			\item[]
			
			\item[] \textbf{Ajouter dans un signal :} On ajoute une constante dans une liste de valeurs d'un signal via la fonction $\rho$
			\smallbreak
			$\langle I,s~b~S,E,put~C,D,TL,\langle CS,SSI\rangle,H,IP\rangle \longrightarrow_{secdv4} \langle I,S,E,C,D,TL,\langle CS',SSI\rangle,H,IP\rangle$ \\
			avec $CS' = \rho(CS,b,s,I)$ et $s$ initialisé
			\item[]
			
			\item[] \textbf{Prendre une valeur partagée (possible) :} On prend dans la liste de valeurs d'un signal partagé lié à un identifant une constante via la fonction $\gamma$ .
			\smallbreak
			$\langle I,s~b~\langle\langle X,C'\rangle,E'\rangle~S,E,get~C,D,TL,\langle CS,SSI\rangle,H,IP\rangle 
			\\\longrightarrow_{secdv4} \langle I,\emptyset,E'[X \leftarrow V],C',\langle S,E,C,D\rangle,TL,\langle CS,SSI'\rangle,H,IP\rangle$\\
			avec $ \gamma(SSI,s,I,b) = \langle V,SSI'\rangle$ si il reste une valeur à prendre et $s$ un signal partagé
			\item[]
			
			\item[] \textbf{Prendre une valeur partagée (impossible) :} On prend dans la liste de valeurs d'un signal partagé lié à un identifant une constante via la fonction $\gamma$. Or on a déjà tout pris donc on lève une erreur.
			\smallbreak 
			$\langle I,s~b~\langle\langle X,C'\rangle,E'\rangle~S,E,get~C,D,TL,\langle CS,SSI\rangle,H,IP\rangle 
			\\\longrightarrow_{secdv4} \langle I,throw~erreur_{e}~S,E,C,D,TL,\langle CS,SSI'\rangle,H,IP\rangle$\\
			avec $ \gamma(SSI,s,I,b) = throw~erreur_{e}$ si il reste aucune valeur à prendre et $s$ un signal partagé
			\item[]
			
			\item[] \textbf{Initialisation signal :} On initialise le signal via la fonction $\iota$.
			\smallbreak 
			$\langle I,s~S,E,init~C,D,TL,\langle CS,SSI\rangle,H,IP\rangle 
			\longrightarrow_{secdv4} \langle I,S,E,C,D,TL,\langle CS',SSI\rangle,H,IP\rangle$\\
			avec $\iota(CS,s) = CS'$
			\item[]	
			
			\item[] \textbf{Présence signal :} On teste la présence d'un signal, via la fonction $\beta$ on sait qu'il est émis donc on prend le 1er choix.
			\smallbreak
			$\langle I,s~S,E,\langle C',C''\rangle~C,D,TL,\langle CS,SSI\rangle,H,IP\rangle 
			\longrightarrow_{secdv4} \langle I,S,E,C'~C,D,TL,\langle CS,SSI\rangle,H,IP\rangle$ \\
			avec $\beta(CS,s) = vraie$
			\item[]
			
			
			\item[] \textbf{Thread bloqué remplacé :} On teste la présence d'un signal, via la fonction $\beta$ on sait qu'il n'est pas émis et il y a un thread dans la file d'attente
			donc on met ce thread dans la liste de threads bloqués et on prend le thread en tête de la file.
			\smallbreak
			$\langle I,s~S,E,\langle C',C''\rangle~C,D,\langle\langle I',S',E',C''',D'\rangle W,ST\rangle,\langle CS,SSI\rangle,H,IP\rangle 
			\\\longrightarrow_{secdv4} \langle I',S',E',C''',D',\langle W,ST\langle s,\langle I,s~S,E,\langle C',C''\rangle~C,D\rangle\rangle\rangle,\langle CS,SSI\rangle,H,IP\rangle$ \\
			avec $\beta(CS,s) = faux$
			\item[]	
			
			\item[] \textbf{Thread bloqué non remplacé :} On teste la présence d'un signal, via la fonction $\beta$ on sait qu'il n'est pas émis donc on met ce thread dans la liste de threads bloqués.
			\smallbreak 
			$\langle I,s~S,E,\langle C',C''\rangle~C,D,\langle \emptyset,ST\rangle,\langle CS,SSI\rangle,H,IP\rangle 
			\\\longrightarrow_{secdv4} \langle IP,\emptyset,\emptyset,\epsilon,\emptyset,\langle W,ST\langle s,\langle I,s~S,E,\langle C',C''\rangle~C,D\rangle\rangle\rangle,\langle CS,SSI\rangle,H,IP+1\rangle$ \\
			avec $\beta(CS,s) = faux$
			\item[]	
			\newpage
			
			
			
			\item[] \textbf{Émission :} On émet un signal donc on met dans la file d'attente tous les threads attendant le signal.
			\smallbreak
			$\langle I,s~S,E,emit~C,D,TL,\langle CS,SSI\rangle,H,IP\rangle 
			\longrightarrow_{secdv4} \langle I,Unit~S,E,C,D,TL',\langle CS',SSI\rangle,H,IP\rangle$\\
			avec $\varepsilon(CS,s) = CS'$ et $TL' = \langle W',ST'\rangle$ et $TL = \langle W,ST\rangle$ :
			\begin{itemize}
				\item[] $W' = W~\cup$ les éléments de $ST$ qui attendent le signal $s$ 
				\item[] $ST' = ST~\setminus$ les éléments de $ST$ qui attendent le signal $s$ 
			\end{itemize}
			\item[]
			
			\item[] \textbf{Récupération dans la file d'attente :} On a plus rien à traiter et on a aucune sauvegarde, du coup on change le thread courant par le thread en tête de la file d'attente.
			\smallbreak
			$\langle I,V~S,E,\epsilon,\emptyset,\langle\langle I',S',E',C,D\rangle W,ST\rangle,SI,H,IP\rangle 
			\longrightarrow_{secdv4} \langle I',V~S',E',C,D,\langle W,ST\rangle,SI,H,IP\rangle$
			\item[]
			
			\item[] \textbf{Fin d'instant logique :} On a plus rien à traiter, on a aucune sauvegarde et on a plus rien dans la file d'attente, c'est la fin d'un instant logique.
			\smallbreak
			$\langle I,V~S,E,\epsilon,\emptyset,\langle\emptyset,ST\rangle,SI,H,IP\rangle 
			\longrightarrow_{secdv4} \langle I,V~S,E,\epsilon,\emptyset,\langle W,\emptyset\rangle,SI',H,IP\rangle$\\
			avec $W = ST$ avec tous ses éléments qui prennent en compte l'absence de l'émission du signal attendu
			\\et  $\alpha(SI) = SI'$ 
		\end{itemize}
		\item[]
		\item[] \textbf{Partie commune} 
		\item[]
		\begin{itemize}
			\item[] \textbf{Application neutre :} On a une application sur rien, cela revient à rien faire.
			\smallbreak 
			$\langle I,S,E,ap~C,D,TL,SI,H,IP\rangle
			\longrightarrow_{secdv4} \langle I,S,E,C,D,TL,SI,H,IP\rangle$
			\item[]
			
			\item[] \textbf{Récupération de sauvegarde neutre :}  On a rien mais le dépôt comporte une sauvegarde donc on prend celle-ci.
			\smallbreak  
			$\langle I,S,E,\epsilon,\langle S',E',C,D\rangle,TL,SI,H,IP\rangle
			\longrightarrow_{secdv4} \langle I,S',E',C,D,TL,SI,H,IP\rangle$
		\end{itemize}
	\end{enumerate}
	\bigbreak
	\bigbreak
	
	
	
	
	\textbf{\textit{la machine SECD version 4 peut s'arrêter dans 4 états différents:}}
	\smallbreak
	\begin{itemize}
		\item[] - Soit on a une \textbf{constante} telle que $\langle 0,\emptyset,\emptyset,\emptyset,\textlbrackdbl M\textrbrackdbl_{secdv4},\langle\emptyset,\emptyset\rangle,\langle\emptyset,\emptyset\rangle,\emptyset,\emptyset,1\rangle \\
		\twoheadrightarrow_{secdv4} \langle I,b~S,E,\epsilon,\emptyset,\langle\emptyset,\emptyset\rangle,SI,H,IP\rangle$;
		\item[] 
		\item[] - Soit on a une \textbf{fonction} telle que
		$\langle 0,\emptyset,\emptyset,\textlbrackdbl M\textrbrackdbl_{secdv4},\emptyset,\langle\emptyset,\emptyset\rangle,\langle\emptyset,\emptyset\rangle,\emptyset,\emptyset,1\rangle \\
		\twoheadrightarrow_{secdv4} \langle I,\langle\langle X,C\rangle,E'\rangle~S,E,\epsilon,\emptyset,\langle\emptyset,\emptyset\rangle,SI,H,IP\rangle$;
		\item[] 
		\item[] - Soit on a \textbf{rien} telle que $\langle 0,\emptyset,\emptyset,\emptyset,\textlbrackdbl M\textrbrackdbl_{secdv4},\langle\emptyset,\emptyset\rangle,\langle\emptyset,\emptyset\rangle,\emptyset,\emptyset,1\rangle \\
		\twoheadrightarrow_{secdv4} \langle I,\epsilon,E,\epsilon,\emptyset,\langle\emptyset,\emptyset\rangle,SI,H,IP\rangle$;
		\item[] 
		\item[] - Sinon on a une \textbf{erreur} telle que 
		$\langle 0,\emptyset,\emptyset,\textlbrackdbl M\textrbrackdbl_{secdv4},\emptyset,\langle\emptyset,\emptyset\rangle,\langle\emptyset,\emptyset\rangle,\emptyset,\emptyset,1\rangle \\
		\twoheadrightarrow_{secdv4} \langle I,throw_{e}~S,E,\epsilon,\emptyset,\langle\emptyset,\emptyset\rangle,SI,H,IP\rangle$;
	\end{itemize}
	
\end{document}